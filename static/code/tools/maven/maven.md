

MAVEN IN 5 MINUTES


# COMMANDS

```bash
$ mvn –-version
$ mvn --help

# run generate goal
$ mvn archetype:generate -DgroupId=com.reissenzahn.hello-world
  -DartifactId=hello-world 
  -DarchetypeArtifactId=maven-archetype-quickstart 
  -DarchetypeVersion=1.4
  -DinteractiveMode=false
```

# PROJECT STRUCTURE

hello-world
|-- pom.xml
`-- src
    |-- main
    |   `-- java
    `-- test
        `-- java

- src/main/java: application/library source files.
- src/main/resources: application/library resources.
- src/main/webapp: web application source files.
- src/test/java: test source files.
- src/test/resources: test resources.
- src/site: website.

The target directory is used to house all output of the build.

The src directory contains all of the source material for building the project, its site and so on.


# Project Object Model

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
 
  <groupId>com.mycompany.app</groupId>
  <artifactId>my-app</artifactId>
  <version>1.0-SNAPSHOT</version>
 
  <properties>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>
 
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>


mvn plugin_name:goal_name



# PLUGINS

A plugin is a collection of goals with a general common purpose.


Build the Project

mvn package

- A phase is a step in the build lifecycle which is an ordered sequence of phases.
- When a phase is given, Maven executes every phase in the sequence up to and including the one defined.

java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App



 version of Maven might use an old version of the maven-compiler-plugin that is not compatible with Java 9 or later versions. To target Java 9 or later, you should at least use version 3.6.0 of the maven-compiler-plugin and set the maven.compiler.release property to the Java release you are targetting (e.g. 9, 10, 11, 12, etc.).

In the following example, we have configured our Maven project to use version 3.8.1 of maven-compiler-plugin and target Java 11:

    <properties>
        <maven.compiler.release>11</maven.compiler.release>
    </properties>
 
    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.8.1</version>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>



# Phases

The most common default lifecycle phases are:

1. validate: validate the project is correct and all necessary information is available.
2. compile: compile the source code of the project.
3. test: test the compiled source code using a suitable unit testing framework.
4. package: take the compiled code and package it in its distributable format such as a JAR.
5. integration-test: process and deploy the package if necessary into an environment where integration tests can be run.
6. verify: run any checks to verify the package is valid and meets quality criteria.
install: install the package into the local repository for use as a dependency in other projects locally.
deploy: done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.

There are two other Maven lifecycles of note beyond the default list above. They are

clean: cleans up artifacts created by prior builds
site: generates site documentation for this project


Phases are actually mapped to underlying goals. The specific goals executed per phase is dependant upon the packaging type of the project. For example, package executes jar:jar if the project type is a JAR, and war:war if the project type is - you guessed it - a WAR.

An interesting thing to note is that phases and goals may be executed in sequence.

mvn clean dependency:copy-dependencies package

This command will clean the project, copy dependencies, and package the project (executing all phases up to package, of course).


# DEPENDENCIES

Each Maven dependency is uniquely identified
using the following group, artifact, and version (GAV) coordinates:

- groupId: Identifier of the organization or group that is responsible for this project.
- artifactId: Identifier of the artifact being generated by the project. This must be unique among the projects using the same groupId.
- version: Indicates the version number of the project.
- type: Indicates the packing of the generated artifact (e.g. JAR, WAR, and EAR).

<dependencies>
 <dependency>
 <groupId>org.hibernate</groupId>
 <artifactId>hibernate-tools</artifactId>
 <version>5.4.2.Final</version>
 </dependency>
</dependencies>


- Dependencies declared in your project’s pom.xml file often have their own dependencies. Such dependencies are called transitive dependencies.
- Maven automatically deals with transitive dependencies and includes them in your project.


Maven uses dependency mediation to resolve version conflicts. This allows Maven to pull the dependency that is closest to the project in the dependency tree.

Maven provides a handy dependency
plug-in that allows you to visualize project dependency tree.

$ mvn dependency:tree

Maven provides an
“excludes” tag to exclude a transitive dependency. Listing 3-3 shows the
code to exclude the hamcrest library from JUnit dependency. As you can
see, the exclusion element takes the groupId and artifactId coordinates
of the dependency that you would like to exclude.
Listing 3-3. JUnit Dependency with Exclusion

<dependencies>
 <dependency>
 <groupId>junit</groupId>
 <artifactId>junit</artifactId>
 <version>${junit.version}</version>
 <scope>test</scope>
 <exclusions>
 <exclusion>
 <groupId>org.hamcrest</groupId>
<artifactId>hamcrest</artifactId>
 </exclusion>
 </exclusions>
 </dependency>
</dependencies>
Chapter 3 Maven Dependency Management
32
Dependency Scope
Consider a Java project that uses JUnit for its unit testing. The JUnit JAR file
you included in your project is only needed during testing. You really don’t
need to bundle the JUnit JAR in your final production archive. Similarly,
consider the MySQL database driver, mysql-connector-java.jar file. You
need the JAR file when you are running the application inside a container
such as Tomcat but not during code compilation or testing. Maven uses the
concept of scope, which allows you to specify when and where you need a
particular dependency.
Maven provides the following six scopes:
compile: Dependencies with the compile scope are
available in the class path in all phases on a project
build, test, and run. This is the default scope.
provided: Dependencies with the provided scope
are available in the class path during the build and
test phases. They don’t get bundled within the
generated artifact. Examples of dependencies that
use this scope include Servlet api, JSP api, and so on.
runtime: Dependencies with the runtime scope
are not available in the class path during the build
phase. Instead they get bundled in the generated
artifact and are available during runtime.
test: Dependencies with the test scope are
available during the test phase. JUnit and TestNG
are good examples of dependencies with the
test scope.
Chapter 3 Maven Dependency Management
33
system: Dependencies with the system scope are
similar to dependencies with the provided scope,
except that these dependencies are not retrieved
from the repository. Instead, a hard-coded path
to the file system is specified from which the
dependencies are used.
import: The import scope is applicable for .pom
file dependencies only. It allows you to include
dependency management information from a
remote .pom file. The import scope is available only
in Maven 2.0.9 or later.






APRESS BOOK


# 2. Setting Up Maven

user-specific configuration is
provided in a settings.xml file. Maven looks for the settings.xml file in
two locations – in the conf folder of Maven’s installation and .m2 folder in
the user’s home directory.

The settings.xml file under conf folder is called
global settings, and the file under .m2 folder is referred to as user settings.

If both files exist, Maven will merge the contents of two files and the user settings will take precedence.


<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
 http://maven.apache.org/xsd/settings--
1.0.0.xsd">
 <localRepository/>
 <interactiveMode/>
 <offline/>
 <pluginGroups/>
 <servers/>
 <mirrors/>
 <proxies/>
 <profiles/>
 <activeProfiles/>
</settings>

Element Name Description
localRepository Maven stores copies of plug-ins and dependencies
locally in the c:\Users\<<your_user_name>>
\.m2\repository folder. The localRepository element
can be used to change the path of the local repository.
For example, <localRepository>c:\mavenrepo
</localRepository> will change the repository location
to the mavenrepo folder.
interactiveMode As the name suggests, when this value is set to true, Maven
interacts with the user for input. If the value is false, Maven
will try to use sensible defaults. The default is true.
offline When set to true, this configuration instructs Maven to not
connect to network and operate in an offline mode. With
offline mode set to true, Maven will not attempt to download
new dependencies or updates to dependencies. The default
is false.
servers Maven can interact with a variety of servers, such as Git servers,
build servers, and remote repository servers. This element
allows you to specify security credentials, such as the username
and password, which you need to connect to those servers.
mirrors As the name suggests, mirrors allow you to specify alternate
locations for downloading dependencies from remote
repositories. For example, your organization might have
mirrored a public repository on their internal network. The
mirror element allows you to force Maven use the internal
mirrored repository instead of the public repository.
proxies Proxies contain the HTTP proxy information needed to
connect to the Internet.




# 3. Maven Dependency Management

# Dependency Identification




# 4. Maven Project Basics

```java
gswm
  src
    main
      java
    test
      java
  target
pom.xml


• The gswm is the root folder of the project. Typically,
the name of the root folder matches the name of the
generated artifact.
• The src folder contains project-related artifacts such as
source code or property files.
• The src/main/java folder contains the Java
source code.
• The src/test/java folder contains the Java unit
test code.
• The target folder holds generated artifacts, such as
.class files.
• Every Maven project has a pom.xml file at the root of the
project. It holds project and configuration information,
such as dependencies and plug-ins.



We start the pom.xml file with the project
element. Then we provide the groupId, artifactId, and version
coordinates.

The packaging element tells Maven that it needs to create a
JAR archive for this project. 

<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://
maven.apache.org/xsd/maven-4.0.0.xsd">
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.apress.gswmbook</groupId>
 <artifactId>gswm</artifactId>
 <version>1.0.0-SNAPSHOT</version>
 <packaging>jar</packaging>
 <name>Getting Started with Maven</name>
 <url>http://apress.com</url>
 <developers>
 <developer>
 <id>balaji</id>
 <name>Balaji Varanasi</name>
 <email>balaji@inflinx.com</email>
 <properties>
 <active>true</active>
 </properties>
 </developer>
 <developer>
 <id>sudha</id>
 <name>Sudha Belida</name>
 <email>sudha@inflinx.com</email>
 <properties>
 <active>true</active>
 </properties>
 </developer>
 </developers>
</project>


It is recommended that Maven projects use the following conventions for
versioning:
<major-version>.<minor-version>.<incremental-version>-qualifier
The major, minor, and incremental values are numeric, and the qualifier can
have values such as RC, alpha, beta, and SNAPSHOT. Some examples that
follow this convention are 1.0.0, 2.4.5-SNAPSHOT, 3.1.1-RC1, and so forth.
The SNAPSHOT qualifier in the project’s version carries a special meaning. It
indicates that the project is in a development stage. When a project uses a
SNAPSHOT dependency, every time the project is built, Maven will fetch and
use the latest SNAPSHOT artifact.
Most repository managers accept release builds only once. However, when
you are developing an application in a continuous integration environment,
you want to build often and push your latest build to the repository manager.
Thus, it is the best practice to suffix your version with SNAPSHOT during
development.
Building a Project
Before we look at building a project, let’s add the HelloWorld Java
class under src/main/java folder. Listing 4-2 shows the code for the
HelloWorld class.
Listing 4-2. Code for HelloWorld Java Class
public class HelloWorld {
 public void sayHello() {
 System.out.print("Hello World");
 }
}

Figure 4-3 shows the project structure after adding the class.
Figure 4-3. Project structure with Java class added
Now you’re ready to build the application, so let’s run the mvn package
from gswm. You should see output similar to that shown in Listing 4-3.

The package suffix after the mvn command is a Maven phase that
compiles Java code and packages it into the JAR file. The packaged JAR file
ends up in the gswm\target folder, as shown in Figure 4-4.
Testing the Project
Now that you have completed the project build, let’s add a JUnit test that tests
the sayHello() method. Let’s start this process by adding JUnit dependency
to the pom.xml file. You accomplish this by using the dependencies element.
Listing 4-4 shows the updated pom.xml file with JUnit dependency.
Listing 4-4. Updated POM with JUnit Dependency
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://
maven.apache.org/xsd/maven-4.0.0.xsd">
 <modelVersion>4.0.0</modelVersion>
Figure 4-4. Packaged JAR located under the target folder
Chapter 4 Maven Project Basics
45
 <groupId>com.apress.gswmbook</groupId>
 <artifactId>gswm</artifactId>
 <version>1.0.0-SNAPSHOT</version>
 <packaging>jar</packaging>
 <name>Getting Started with Maven</name>
 <url>http://apress.com</url>
 <developers>
 <developer>
 <id>balaji</id>
 <name>Balaji Varanasi</name>
 <email>balaji@inflinx.com</email>
 <properties>
 <active>true</active>
 </properties>
 </developer>
 <developer>
 <id>sudha</id>
 <name>Sudha Belida</name>
 <email>sudha@inflinx.com</email>
 <properties>
 <active>true</active>
 </properties>
 </developer>
 </developers>
 <dependencies>
 <dependency>
 <groupId>junit</groupId>
 <artifactId>junit</artifactId>
Chapter 4 Maven Project Basics
46
 <version>4.12</version>
 <scope>test</scope>
 </dependency>
</dependencies>
</project>
Notice that you have used the scope test, indicating that the
JUnit .jar is needed only during the testing phase. Let’s make sure
that this dependency has been successfully added by running mvn
dependency:tree in the command line. Listing 4-5 shows the output of
this operation.
Listing 4-5. Maven Tree Command Output
C:\apress\gswm-book\chapter4\gswm>mvn dependency:tree
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli)
@ gswm ---
[INFO] com.apress.gswmbook:gswm:jar:1.0.0-SNAPSHOT
[INFO] \- junit:junit:jar:4.12:test
[INFO] \- org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] --------------------------------------------------------
[INFO] BUILD SUCCESS
The tree goal in the dependency plug-in displays the project’s
dependencies as tree. Notice that the JUnit dependency pulled in a
transitive dependency named hamcrest, which is an open source project
that makes it easy to write matcher objects.
Now that you have the JUnit dependency in the class path, let’s add a
unit test HelloWorldTest.java to the project. Create the folders test/java
under src and add HelloWorldTest.java beneath it. The updated project
structure is shown in Figure 4-5.
Chapter 4 Maven Project Basics
47
The source code for HelloWorldTest is shown in Listing 4-6.
Listing 4-6. Code for HelloWorldTest Java Class
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
public class HelloWorldTest {
 private final ByteArrayOutputStream outStream =
new ByteArrayOutputStream();
 @Before
 public void setUp() {
 System.setOut(new PrintStream(outStream));
 }
 @Test
 public void testSayHello() {
 HelloWorld hw = new HelloWorld();
 hw.sayHello();
Figure 4-5. Maven structure with test class
Chapter 4 Maven Project Basics
48
 Assert.assertEquals("Hello World", outStream.
toString());
 }
 @After
 public void cleanUp() {
 System.setOut(null);
 }
}

You now have everything set up in this project, so you can run the mvn
packge one more time.

Properties in pom.xml
Maven provides properties AKA placeholders that can be used inside
pom.xml file. Maven properties are referenced in pom.xml file using the
${property_name} notation. There are two types of properties – implicit
and user-defined properties.
Chapter 4 Maven Project Basics
50
Implicit Properties
Implicit properties are properties that are available by default to any
Maven project. For example, Maven exposes its Project Object Model
properties using the “project.” prefix. To access the artifactId value inside
the pom.xml file, you can use the ${project. artifactId} as shown in the
following:
<build>
 <finalName>${project.artifactId}</finalName>
</build>
Simillarly, to access properties from settings.xml file, you can use
the “settings.” prefix. Finally, the “env.” prefix can be used to access
environment variable values. For example, ${env.PATH} will return the
value of PATH environment variable.
User-Defined Properties
Maven allows you to declare custom properties in the pom.xml file using
the <properties /> element. These properties are highly useful for
declaring dependency versions. Listing 4-8 shows the updated pom.xml
file with the JUnit version declared as a property. This is especially useful
when pom.xml has a lot of dependencies and you need to know or change a
version of a particular dependency.
Listing 4-8. pom.xml File with Properties
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://
maven.apache.org/xsd/maven-4.0.0.xsd">
 <modelVersion>4.0.0</modelVersion>
Chapter 4 Maven Project Basics
51
 <groupId>com.apress.gswmbook</groupId>
 <!-- Removed for brevity -->
 <properties>
 <junit.version>4.12</junit.version>
 </properties>
 <developers>
 <!-- Removed for brevity -->
 </developers>
 <dependencies>
 <dependency>
 <groupId>junit</groupId>
 <artifactId>junit</artifactId>
 <version>${junit.version}</version>
 <scope>test</scope>
 </dependency>
</dependencies>
</project>

```


# 5. Maven Lifecycle

```java
Central to Maven is its lifecycle that provides a uniform interface for
building and distributing projects.

Build processes generating artifacts such as JAR or WAR files typically
require several steps and tasks to be completed successfully in a welldefined order.

Examples of such tasks include compiling source code,
running unit tests, and packaging of the artifact. Maven uses the concept of
goals to represent such granular tasks.

Goals in Maven are packaged in plug-ins, which are essentially a
collection of one or more goals.

mvn compiler:compile
mvn clean:clean

The
clean before the colon (:) represents the clean plug-in, and the clean
following the colon represents the clean goal.


By now it should be obvious
that running a goal in the command line requires the following syntax:
mvn plugin_identifier:goal_identifier

Maven provides an out-of-the box Help plug-in that can be used to
list available goals in a given plug-in.

mvn help:describe -Dplugin=compiler


Plug-ins and their behavior can be configured using the plug-in section of pom.xml. Consider the case where you want to enforce that your project
must be compiled with Java 8.
```

<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd">
 <modelVersion>4.0.0</modelVersion>
 <!-- Project details omitted for brevity -->
 <dependencies>
 <!-- Dependency details omitted for brevity -->
 </dependencies>
 <build>
 <plugins>
 <plugin>
 <groupId>org.apache.maven.plugins</groupId>
 <artifactId>maven-compiler-plugin</artifactId>
 <version>3.8.1</version>
 <configuration>
 <source>1.8</source>
 <target>1.8</target>
 </configuration>
 </plugin>
 </plugins>
 </build>
</project>

Now if you were to run the mvn compiler:compile command, the
generated class files will be of Java version 1.8.



Note The <build /> element in pom.xml has a very useful
child element called finalName. By default, the name of the
Maven-generated artifact follows the <<project_artifiact_
id>>-<<project_version>> format. However, sometimes you
might want to change the name of the generated artifact without
changing the artifactId. You can accomplish this by declaring the
finalName element as <finalName>new_name</finalName>.




Lifecycle and Phases
Maven goals are granular and typically perform one task. Multiple goals need to be executed in an orderly fashion to perform complex operations such as generating artifacts or documentation. Maven simplifies these
complex operations via lifecycle and phase abstractions such that buildrelated operations could be completed with a handful of commands.
Maven’s build lifecycle constitutes a series of stages that get executed
in the same order, independent of the artifact being produced. Maven
refers to the stages in a lifecycle as phases. Every Maven project has the
following three built-in lifecycles:
default: This lifecycle handles the compiling,
packaging, and deployment of a Maven project.
clean: This lifecycle handles the deletion of
temporary files and generated artifacts from the
target directory.
site: This lifecycle handles the generation of
documentation and site generation.
Chapter 5 Maven Lifecycle
58
To better understand the build lifecycle and its phases, let’s look at
some of the phases associated with the default lifecycle:
validate: Runs checks to ensure that the project is
correct and that all dependencies are downloaded
and available.
compile: Compiles the source code.
test: Runs unit tests using frameworks. This step
doesn’t require that the application be packaged.
package: Assembles compiled code into a
distributable format, such as JAR or WAR.
install: Installs the packaged archive into a local
repository. The archive is now available for use by
any project running on that machine.
deploy: Pushes the built archive into a remote
repository for use by other teams and team
members.
Maven lifecycle is an abstract concept and can’t be directly executed.
Instead, you execute one or more phases. For example, the command mvn
package will execute the package phase of the default lifecycle. In addition
to clearly defining the ordering of phases in a lifecycle, Maven also
automatically executes all the phases prior to a requested phase. So, when
the mvn package command is run, Maven will run all prior phases such as
compile and test.
A number of tasks need to be performed in each phase. For that to
happen, each phase is associated with zero or more goals. The phase
simply delegates those tasks to its associated goals. Figure 5-1 shows the
association between lifecycle, phases, goals, and plug-ins.
Chapter 5 Maven Lifecycle
59
It is valid for a Maven phase to not have any goals associated with it.
In that case, Maven will skip the phase execution. Such phases serve as
placeholders for users and third-party vendors to associate their custombuilt goals.
Figure 5-1. Association between lifecycle, phases, goals, and plug-ins
Chapter 5 Maven Lifecycle
60
The <packaging /> element in the pom.xml file will automatically
assign the right goals for each of the phases without any additional
configuration. Remember that this is a benefit of CoC. For example, if the
packaging element is jar, then the package phase will be bound to the jar
goal in the jar plug-in. Similarly, for a WAR artifact, pom.xml will bind the
package to a war goal in the war plug-in. Figure 5-2 shows a portion of the
internal lifecycle associated with a WAR project.
Figure 5-2. Default lifecycle for WAR project
Chapter 5 Maven Lifecycle
61
SKIPPING TESTS
As discussed earlier, when you run the package phase, the test phase is also
run and all of the unit tests get executed. If there are any failures in the test
phase, the build fails. This is the desired behavior. However, there are times,
for example, when dealing with a legacy project, where you would like to skip
compiling and running the tests so you can build a project successfully. You
can achieve this using the maven.test.skip property. Here is an example of
using this property:
mvn package –Dmaven.test.skip=true
Plug-in Development
Developing custom plug-ins for Maven is very straightforward. As
discussed earlier, a plug-in is simply a collection of goals. Thus, when
we talk about plug-in development, we are essentially talking about
developing goals. In Java, these goals are implemented using MOJOs,
which stands for Maven Old Java Object, and it is similar to Java’s Plain Old
Java Object (POJO).
This section explains how to develop a SystemInfoPlugin that displays
system information such as Java version, operating system, and the like, on
the console running Maven command.
Let’s start this plug-in development by creating a Maven Java project,
named gswm-maven-plugin, as shown in Figure 5-3.
Chapter 5 Maven Lifecycle
62
Note In this chapter, we are manually creating the plug-in project.
Maven provides a mavan-archetype-mojo, which would jumpstart your
plug-in development. We will learn about Maven archetypes in Chapter 6.
The content of the pom.xml file is shown in Listing 5-5. Notice that the
packaging type is maven-plugin. We added the maven-plugin-api and
maven-plugin-annotations dependencies, because they are needed for
plug-in development. We will be leveraging Apache Commons Lang to get
system information. Hence, we have also added the Apache Commons
Lang 3 dependency.
Listing 5-5. The pom.xml with Dependencies
<?xml version="1.0" encoding="UTF-8"?>
<project>
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.apress.plugins</groupId>
 <artifactId>gswm-maven-plugin</artifactId>
 <version>1.0.0</version>
 <packaging>maven-plugin</packaging>
 <description>System Info Plugin</description>
Figure 5-3. Maven project for plug-in development
Chapter 5 Maven Lifecycle
63
 <properties>
 <maven.compiler.source>1.8</maven.compiler.source>
 <maven.compiler.target>1.8</maven.compiler.target>
 </properties>
 <dependencies>
 <dependency>
 <groupId>org.apache.maven</groupId>
 <artifactId>maven-plugin-api</artifactId>
 <version>3.6.1</version>
 </dependency>
 <dependency>
 <groupId>org.apache.maven.plugin-tools</groupId>
 <artifactId>maven-plugin-annotations</artifactId>
 <version>3.6.0</version>
 <scope>provided</scope>
 </dependency>
 <dependency>
 <groupId>org.apache.commons</groupId>
 <artifactId>commons-lang3</artifactId>
 <version>3.9</version>
 </dependency>
 </dependencies>
 <!-- Use the latest version of Plugin -->
 <build>
 <plugins>
 <plugin>
 <groupId>org.apache.maven.plugins</groupId>
 <artifactId>maven-plugin-plugin</artifactId>
 <version>3.6.0</version>
 </plugin>
Chapter 5 Maven Lifecycle
64
 </plugins>
 </build>
</project>
The next step in the development process is creating the MOJO. 
Listing 5-6 shows the code for SystemInfoMojo. The @Mojo annotation
marks the SystemInfoMojo class as a Mojo with “systeminfo” as the goal
name. The execute method contains that goal logic. In SystemInfoMojo,
we simply log several pieces of system information to the console.
Listing 5-6. SystemInfoMojo Java Class
package com.apress.plugins;
import org.apache.commons.lang3.SystemUtils;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Mojo;
@Mojo( name = "systeminfo")
public class SystemInfoMojo extends AbstractMojo {
@Override
 public void execute() throws MojoExecutionException,
MojoFailureException {
 getLog().info( "Java Home: " + SystemUtils.JAVA_HOME );
 getLog().info( "Java Version: "+ SystemUtils.JAVA_
VERSION);
 getLog().info( "OS Name: " + SystemUtils.OS_NAME );
 getLog().info( "OS Version: " + SystemUtils.OS_
VERSION );
 getLog().info( "User Name: " + SystemUtils.USER_NAME );
}
}
Chapter 5 Maven Lifecycle
65
The final step in this process is installing the plug-in in the Maven
repository. Run the mvn install command at the root of the directory and
you should get the output shown in Listing 5-7.
Listing 5-7. Maven install Command
C:\apress\gswm-book\chapter5\gswm-maven-plugin>mvn install
[INFO] Scanning for projects...
[INFO]
[INFO] --------< com.apress.plugins:gswm-maven-plugin >--------
[INFO] Building gswm-maven-plugin 1.0.0
[INFO] -------------------[ maven-plugin ]---------------------
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (defaultresources) @ gswm-maven-plugin
[INFO] java-annotations mojo extractor found 1 mojo descriptor.
[INFO] --- maven-install-plugin:2.4:install (default-install)
@ gswm-maven-plugin ---
[INFO] Installing C:\apress\gswm-book\chapter5\gswm-mavenplugin\target\gswm-maven-plugin-1.0.0.jar to C:\Users\<<USER_
NAME>>\.m2\repository\com\apress\plugins\gswm-plugin\1.0.0\
gswm-maven-plugin-1.0.0.jar
[INFO] Installing C:\apress\gswm-book\chapter5\gswm-mavenplugin\pom.xml to C:\Users\<<USER_NAME>>\.m2\repository\com\
apress\plugins\gswm-maven-plugin\1.0.0\gswm-maven-plugin--
1.0.0.pom
[INFO] --------------------------------------------------------
[INFO] BUILD SUCCESS
Chapter 5 Maven Lifecycle
66
Now you’re ready to start using this plug-in. Remember that the syntax
to run any goal is mvn pluginId:goal-name. Listing 5-8 shows this plug-in
in action. Notice system information displayed on the console.
Listing 5-8. Running the SystemInfoMojo Plug-in
C:\apress\gswm-book\chapter5\gswm-plugin>mvn com.apress.
plugins:gswm-maven-plugin:systeminfo
[INFO] Scanning for projects...
[INFO] --- gswm-maven-plugin:1.0.0:systeminfo (default-cli)
@ gswm-maven-plugin ---
[INFO] Java Home: C:\java\jdk-11
[INFO] Java Version: 11.0.1
[INFO] OS Name: Windows
[INFO] OS Version: 10
[INFO] User Name: Balaji
[INFO] --------------------------------------------------------
The newly developed plug-in is also ready to be used in other
Maven projects. Listing 5-9 shows a portion of the POM file that attaches
systeminfo goal to the validate phase.
Listing 5-9. POM File Using systeminfo Goal
<project>
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.apress.plugins</groupId>
 <artifactId>gswm-plugin-test</artifactId>
 <version>1.0.0</version>
 <packaging>jar</packaging>
 <description>Plugin Test</description>
Chapter 5 Maven Lifecycle
67
 <properties>
 <maven.compiler.source>1.8</maven.compiler.source>
 <maven.compiler.target>1.8</maven.compiler.target>
 </properties>
 <dependencies />
 <build>
 <plugins>
 <plugin>
 <groupId>com.apress.plugins</groupId>
 <artifactId>gswm-maven-plugin
</artifactId>
 <version>1.0.0</version>
<executions>
 <execution>
 <phase>validate</phase>
<goals>
 <goal>systeminfo
</goal>
 </goals>
 </execution>
 </executions>
 </plugin>
 </plugins>
 </build>
</project>
When the Maven phase such as compile or package is invoked, you will
see the output of the systeminfo goal as shown in Listing 5-10.
Chapter 5 Maven Lifecycle
68
Listing 5-10. Compile Phase Output
mvn compile
[INFO] Scanning for projects...
[INFO] Building gswm-plugin-test 1.0.0
[INFO] Java Home: C:\java\jdk-11
[INFO] Java Version: 11.0.1
[INFO] OS Name: Windows
[INFO] OS Version: 10
[INFO] User Name: Balaji
[INFO] --- maven-resources-plugin:2.6:resources (default-resources)
@ gswm-plugin-test ---
Summary
Maven uses plug-in-based architecture that allows its functionality to be
extended easily. Each plug-in is a collection of one or more goals that can
be used to execute tasks, such as compiling source code or running tests.
Maven ties goals to phases. Phases are typically executed in a sequence as
part of a build lifecycle. You also learned the basics of creating a plug-in.
In the next chapter, you will be introduced to archetypes and learn
about multimodule projects.






# 6. Maven Archetypes

Maven archetypes are project templates that allow users to generate new projects easily.

Maven also provides an
archetype plug-in with goals to create new archetypes and generate
projects from existing archetypes.

The archetype plug-in’s generate goal allows you to view and select
an archetype for use

$ mvn archetype:generate
$ mvn archetype:generate -DarchetypeArtifactId=maven-archetypewebapp



# 7. Documentation and Reporting

Maven provides the site lifecycle that can
be used to generate a project’s documentation.


<project>
 <!—Content removed for brevity-->
 <reporting>
Figure 7-7. About page with the new logo
Chapter 7 Documentation and Reporting
100
 <plugins>
 <plugin>
 <artifactId>maven-javadoc-plugin</artifactId>
 </plugin>
 </plugins>
 </reporting>
</project>
Now that you have the Javadoc plug-in configured, let’s run mvn clean
site to generate the Javadoc. After the command successfully runs, you
will notice the apidocs folder created under gswm /target/site. Launch
index.html file under site, and navigate to Project Reports ➤ Javadoc.
Figure 7-8 shows the Javadoc generated for the gswm project.
Figure 7-8. Generated Javadoc page
Chapter 7 Documentation and Reporting
101
Generating Unit Test Reports
Test-driven development has become the norm in enterprises today. Unit
tests provide immediate feedback to developers and allow them to build
quality code. Considering how important tests are, Maven executes all of
the tests for each build. Any test failure results in a failed build.
Maven offers the Surefire plug-in that provides a uniform interface
for running tests created by frameworks such as JUnit or TestNG. It also
generates execution results in various formats such as XML and HTML.
These published results enable developers to find and fix broken tests
quickly.
The Surefire plug-in is configured in the same way as the Javadoc plugin in the reporting section of the pom file. Listing 7-5 shows the Surefire
plug-in configuration.
Listing 7-5. The pom.xml Snippet with Surefire Plug-in
<project>
 <!—Content removed for brevity-->
 <reporting>
 <plugins>
 <plugin>
 <groupId>org.apache.maven.plugins</groupId>
 <artifactId>maven-surefire-report-plugin</artifactId>
 <version>2.17</version>
 </plugin>
 </plugins>
 </reporting>
</project>
Now that Surefire is configured, let’s generate a Maven site by running
mvn clean site command. Upon successful execution of the command,
you will see a Surefire Reports folder generated under gswm\target.
Chapter 7 Documentation and Reporting
102
It contains the test execution results in XML and TXT formats. The same
information will be available in HTML format in the surefire-report.
html file under site folder. Launch index.html file under site, and navigate
to Project Reports ➤ Surefire Report. Figure 7-9 shows Surefire Report for
the gswm project.
Generating Code Coverage Reports
Code coverage is a measurement of how much source code is being
exercised by automated tests. Essentially, it provides an indication of the
quality of your tests. JaCoCo (open source) and Atlassian’s Clover are two
popular code coverage tools for Java.
In this section, you will use JaCoCo for measuring this project’s code
coverage. Listing 7-6 shows JaCoCo plugin configuration. The prepareagent goal sets a property pointing to JaCoCo runtime environment
that gets passed as a VM argument when unit tests are run. The report
goal generates the code coverage reports after the unit test execution is
complete.
Figure 7-9. Generated Surefire Report
Chapter 7 Documentation and Reporting
103
Listing 7-6. The pom.xml Snippet with the JaCoCo Plug-in
<project>
 <build>
 <plugins>
 <!--Content removed for brevity-->
 <plugin>
 <groupId>org.jacoco</groupId>
 <artifactId>jacoco-maven-plugin
</artifactId>
 <version>0.8.4</version>
 <executions>
 <execution>
 <id>jacoco-init</id>
 <goals>
 <goal>prepare-agent</goal>
 </goals>
 </execution>
<execution>
 <id>jacoco-report</id>
<phase>test</phase>
 <goals>
 <goal>report</goal>
 </goals>
 </execution>
 </executions>
 </plugin>
 </plugins>
 <build>
</project>
Chapter 7 Documentation and Reporting
104
Now that the plug-in is configured, let’s generate the site using the
mvn clean site command. Upon successful completion of the command,
JaCoCo will create a jacoco folder under gswm\target\site. Launch the
code coverage report by double-clicking the index.html file under jacoco
folder. The report should be similar to the one shown in Figure 7-10.
Generating the SpotBugs Report
SpotBugs is a tool for detecting defects in Java code. It uses static analysis
to detect bug patterns, such as infinite recursive loops and null pointer
dereferences. Listing 7-7 shows the SpotBugs configuration.
Listing 7-7. The pom.xml Snippet with SpotBugs Plug-in
<project>
 <!—Content removed for brevity-->
 <reporting>
 <plugins>
 <plugin>
 <groupId>com.github.spotbugs</groupId>
 <artifactId>spotbugs-maven-plugin</artifactId>
 <version>3.1.12</version>
 </plugin>
 </plugins>
 </reporting>
</project>
Figure 7-10. Generated JaCoCo report
Chapter 7 Documentation and Reporting
105
Once the Maven site gets generated, open index.html file under site
folder and navigate to Project Reports ➤ SpotBugs to view the SpotBugs
report. It should be similar to the one shown in Figure 7-11.
Summary
The documentation and reporting capabilities provided by Maven play
an important role in creating maintainable, quality software. This chapter
explained the basics of using the site lifecycle and the configuration
needed to produce documentation. You also looked at generating
Javadocs, test coverage, and SpotBugs reports.
In the next chapter, we will explain how to integrate Maven with Nexus
and Git. You will also learn about Maven’s release process.


# 8. Maven Release

Maven provides the release plugin that automates steps involved with
releasing software.

Integration with Nexus
Repository managers are a key part of Maven deployment in enterprises.
Repository managers act as a proxy of public repositories, facilitate artifact
sharing and team collaboration, ensure build stability, and enable the
governance of artifacts used in the enterprise.
Sonatype Nexus repository manager is a popular open source software
that allows you to maintain internal repositories and access external
repositories. It allows repositories to be grouped and accessed via a single
URL. This enables the repository administrator to add and remove new
repositories behind the scenes without requiring developers to change the
configuration on their computers. Additionally, it provides hosting capabilities
for sites generated using Maven site and artifact search capabilities.
Before we look at integrating Maven with Nexus, you will need to install
Nexus on your local machine. Nexus is distributed as an archive, and it
comes bundled with a Jetty instance. Download the Nexus distribution
(.zip version for Windows) from Sonatype’s web site at https://help.
sonatype.com/repomanager3/download. At the time of this writing, 
108
version 3.18.1-01 of Nexus is available. Unzip the file, and place the
contents on your machine. In this book, we assume the contents to be
under C:\tools\nexus folder.
Note Most enterprises typically have repository managers installed
and available on a central server. If you already have access to a
repository manager, skip this part of the installation.
Launch your command line in administrator mode and navigate to the
bin folder located under C:\tools\nexus\nexus-3.18.1-01. Then run the
command nexus /install Nexus_Repo_Manager. You will see the success
message as illustrated in Figure 8-1.
Note Nexus 3.18 requires JRE 8 to function properly. Make sure
you have version 8 of JDK/JRE installed on your local machine. Also,
make sure that JAVA_HOME is pointing to version 8 of the JDK.
On the same command line, run the command nexus start to launch
Nexus. Figure 8-2 shows the result of running this command.
Figure 8-1. Success message when installing Nexus
Figure 8-2. Starting Nexus
By default, Nexus runs on port 8081. Launch a web browser and navigate
to Nexus at http://localhost:8081/. It will take several minutes, but
eventually you should see the Nexus launch screen as shown in Figure 8-3.
Chapter 8 Maven Release
109
Click the “Sign In” link on the top-right corner to log in to Nexus. You
will be presented with a login modal containing the location to the file with
autogenerated admin password as shown in Figure 8-4.
Log in to Nexus with the username admin and password copied from
admin.password file. You will be asked to change the password as shown
in Figure 8-5. For the exercises in this book, I changed the password to
admin123.
Figure 8-3. Nexus launch screen
Figure 8-4. Nexus login modal
Chapter 8 Maven Release
110
Now that Nexus is installed and running, let’s modify the gwsm project
located under C:\apress\gswm-book\chapter8. You will start by adding a
distributionManagement element in the pom.xml file, as shown in Listing 8-1.
This element is used to provide repository information on where the
project’s artifacts will be deployed. The repository subelement indicates
the location where the released artifacts will be deployed. Similarly, the
snapshotRepository element identifies the location where the SNAPSHOT
versions of the project will be stored.
Listing 8-1. The pom.xml with distributionManagement
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/maven-v4_0_0.xsd">
 <dependencies>
 <!-- Content removed for brevity -->
 </dependencies>
 <distributionManagement>
 <repository>
 <id>nexusReleases</id>
 <name>Releases</name>
Figure 8-5. Nexus change password screen
Chapter 8 Maven Release
111
 <url>http://localhost:8081/repository/maven-releases
</url>
 </repository>
 <snapshotRepository>
 <id>nexusSnapshots</id>
 <name>Snapshots</name>
 <url>http://localhost:8081/repository/mavensnapshots</url>
 </snapshotRepository>
 </distributionManagement>
 <build>
 <!-- Content removed for brevity -->
 </build>
</project>
Note Out of the box, Nexus comes with Releases and Snapshots
repositories. By default, SNAPSHOT artifacts will be stored in the
Snapshots Repository, and release artifacts will be stored in the
Releases repository.
Like most repository managers, deployment to Nexus is a protected
operation. For Maven to interact and deploy artifacts on Nexus, you need
to provide user with the right access roles in the settings.xml file.
Listing 8-2 shows the settings.xml file with the server information.
As you can see, we are using admin user information to connect to
Nexus. Notice that the IDs declared in the server tag – nexusReleases
and nexusSnapshots – must match the IDs of the repository and
snapshotRepository declared in the pom.xml file. Replace the contents of
the settings.xml file in the C:\Users\<<USER_NAME>>\.m2 folder with the
code in Listing 8-2.
Chapter 8 Maven Release
112
Listing 8-2. Settings.xml File with Server Information
<?xml version="1.0" encoding="UTF-8" ?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
http://maven.apache.org/xsd/settings-1.0.0.xsd">
<servers>
 <server>
 <id>nexusReleases</id>
 <username>admin</username>
 <password>admin123</password>
 </server>
 <server>
 <id>nexusSnapshots</id>
 <username>admin</username>
 <password>admin123</password>
 </server>
</servers>
</settings>
This concludes the configuration steps for interacting with Nexus.
At the command line, run the command mvn deploy under the directory
C:\apress\gswm-book\chapter8\gswm. Upon successful execution of
the command, you will see the SNAPSHOT artifact under Nexus at
http://localhost:8081/#browse/browse:maven-snapshots, as shown in
Figure 8-6.
Chapter 8 Maven Release
113
Project Release
Releasing a project is a complex process, and it typically involves the
following steps:
• Verify that there are no uncommitted changes on the
local machine.
• Remove SNAPSHOT from the version in the pom.xml file.
• Make sure that project is not using any SNAPSHOT
dependencies.
• Check in the modified pom.xml file to your source
control.
• Create a source control tag of the source code.
Figure 8-6. SNAPSHOT artifact under Nexus
Chapter 8 Maven Release
114
• Build a new version of the artifact, and deploy it to a
repository manager.
• Increment the version in the pom.xml file, and prepare
for the next development cycle.
Maven has a release plug-in that provides a standard mechanism for
executing the preceding steps and releasing project artifacts. As you can
see, as part of its release process, Maven heavily interacts with the source
control system. In this section, you will be using Git as the source controls
system and GitHub as the remote server that houses repositories. A typical
interaction between Maven and GitHub is shown in Figure 8-7. Maven
releases are typically performed on a developer or build machine. Maven
requires Git client to be installed on such machines. These command-line
tools allow Maven to interact with GitHub and perform operations such as
checking out code, creating tags, and so forth.
Before we delve deeper into the Maven release process, you need to set
up the environment by completing the following steps:
1. Install Git client on your local machine.
2. Create a new remote repository on GitHub.
3. Check the project you will be using into the remote
repository.
Figure 8-7. Interaction between Maven and GitHub
Chapter 8 Maven Release
115
Git Client Installation
There are several Git clients that make it easy to interact with Git
repositories. Popular ones include SourceTree (www.sourcetreeapp.com/)
and GitHub Desktop (https://desktop.github.com/). In this book, we
will be using the client that comes with Git SCM distribution. Navigate to
https://git-scm.com/downloads and download the Windows version
of Git distribution. Double-click the downloaded exe file and accept the
default installation options. After the installation is complete, open a new
command-line window and type git --version. You should see a message
similar to Figure 8-8.
Creating a GitHub Repository
GitHub is a collaborative development platform that allows you to host
public and private Git repositories for free. Before you can create a new
repository on GitHub, you need to create an account at https://github.
com/join. Once you have logged into GitHub using your credentials,
navigate to https://github.com/new and create a new repository as
shown in Figure 8-9.
Figure 8-8. Git version
Chapter 8 Maven Release
116
Checking in Source Code
The final step in getting your environment ready for Maven release is
checking in the gswm project under C:\apress\gswm-book\chapter8\
gswm to the newly created remove repository. Using your command line,
navigate to the C:\apress\gswm-book\chapter8\gswm folder and run the
following commands sequentially. Make sure you use the right remote
Figure 8-9. New GitHub repository
Chapter 8 Maven Release
117
repository URL by replacing your GitHub account in the following remote
add command:
git init
git add .
git commit -m "Initial commit"
git remote add origin https://github.
com/<<your_git_hub_account>>/intro-maven.git
git push -u origin master
The Git push command will prompt you for your GitHub username
and password. Successful completion of the push command should give
the output shown in Figure 8-10.
Using your browser, navigate to your remote repository on GitHub and
you will see the checked-in code. Figure 8-11 shows the expected browser
screen.
Figure 8-10. Output from the Git initial commit
Chapter 8 Maven Release
118
The preceding commands have pushed the code into the mater branch
on GitHub. However, Maven release plug-in interacts with the code in
the release branch. So, the final step in this setup is to create a new local
release branch and push it to GitHub by running the following commands:
git checkout –b release
git push origin release
Maven Release
Releasing an artifact using Maven’s release process requires using two
important goals: prepare and perform. Additionally, the release plug-in
provides a clean goal that comes in handy when things go wrong.
Prepare Goal
The prepare goal, as the name suggests, prepares a project for release.
As part of this stage, Maven performs the following operations:
• check-poms: Checks that the version in the pom.xml file
has SNAPSHOT in it.
• scm-check-modifications: Checks if there are any
uncommitted changes.
Figure 8-11. Project checked into GitHub
Chapter 8 Maven Release
119
• check-dependency-snapshots: Checks the pom file to see
if there are any SNAPSHOT dependencies. It is a best
practice for your project to use released dependencies.
Any SNAPSHOT dependencies found in the pom.xml
file will result in release failure.
• map-release-versions: When prepare is run in an
interactive mode, the user is prompted for a release
version.
• map-development-versions: When prepare is run in
an interactive mode, the user is prompted for the next
development version.
• generate-release-poms: Generates the release pom file.
• scm-commit-release: Commits the release of the pom file
to the SCM.
• scm-tag: Creates a release tag for the code in the SCM.
• rewrite-poms-for-development: The pom file is updated
for the new development cycle.
• remove-release-poms: Deletes the pom file generated for
the release.
• scm-commit-development: Submits the pom.xml file
with the development version.
• end-release: Completes the prepare phase of the
release.
To facilitate this, you would provide the SCM information in the
project’s pom.xml file. Listing 8-3 shows the pom.xml file snippet with the
SCM information.
Chapter 8 Maven Release
120
Listing 8-3. The pom.xml with SCM Information
<project>
 <modelVersion>4.0.0</modelVersion>
 <!-- Content removed for brevity -->
 <scm>
 <connection>scm:git:https://github.com/bava/intro-maven.
git</connection>
 <developerConnection>scm:git:https://github.com/bava/
intro-maven.git</developerConnection>
 <url>https://github.com/bava/intro-maven</url>
 </scm>
 <!-- Content removed for brevity -->
</project>
Once you have updated the pom.xml file on your local machine,
commit the modified file to GitHub by running the following commands:
git commit . -m "Added SCM Information"
git push origin release
In order for Maven to communicate successfully with the GitHub, it
needs GitHub credentials. You provide that information in the settings.xml
file, as shown in Listing 8-4. The ID for the server element is declared as
GitHub, as it must match the hostname.
Listing 8-4. The settings.xml with GitHub Details
<?xml version="1.0" encoding="UTF-8" ?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
http://maven.apache.org/xsd/settings-1.0.0.xsd">
Chapter 8 Maven Release
121
<servers>
 <server>
 <id>nexusReleases</id>
 <username>admin</username>
 <password>admin123</password>
 </server>
 <server>
 <id>nexusSnapshots</id>
 <username>admin</username>
 <password>admin123</password>
 </server>
 <server>
 <id>github</id>
 <username>[your_github_account_name]</username>
 <password>[your_github_account_password]</password>
 </server>
 </servers>
</settings>
You now have all of the configuration required for Maven’s prepare
goal. Listing 8-5 shows the results of running the prepare goal. Because
the prepare goal was run in interactive mode, Maven will prompt you
for the release version, release tag or label, and the new development
version. Accept Maven’s proposed default values by pressing Enter for each
prompt.
Listing 8-5. Maven prepare Command
C:\apress\gswm-book\chapter8\gswm>mvn release:prepare
[INFO] Scanning for projects...
[INFO]
[INFO] --------------< com.apress.gswmbook:gswm >--------------
[INFO] Building Getting Started with Maven 1.0.0-SNAPSHOT
Chapter 8 Maven Release
122
[INFO] --- maven-release-plugin:2.5.3:prepare (default-cli)
@ gswm ---
[INFO] Verifying that there are no local modifications...
[INFO] Executing: cmd.exe /X /C "git rev-parse --show-toplevel"
[INFO] Working directory: C:\apress\gswm-book\chapter8\gswm
[INFO] Executing: cmd.exe /X /C "git status --porcelain ."
What is the release version for "Getting Started with Maven"?
(com.apress.gswmbook:gswm) 1.0.0: :
What is SCM release tag or label for "Getting Started with
Maven"? (com.apress.gswmbook:gswm) gswm-1.0.0: :
What is the new development version for "Getting Started with
Maven"? (com.apress.gswmbook:gswm) 1.0.1-SNAPSHOT: :
[INFO] Checking in modified POMs...
[INFO] Tagging release with the label gswm-1.0.0...
[INFO] Executing: cmd.exe /X /C "git tag -F C:\Users\bavara\
AppData\Local\Temp\maven-scm-73613791.commit gswm-1.0.0"
[INFO] Executing: cmd.exe /X /C "git push https://github.com/
bava/intro-maven.git refs/tags/gswm-1.0.0"
[INFO] Release preparation complete.
[INFO] BUILD SUCCESS
Notice the Git commands getting executed as part of the prepare goal.
Successful completion of the prepare goal will result in the creation of a
Git tag, as shown in Figure 8-12. The pom.xml file in the gswm project will
now have version 1.0.1-SNAPSHOT.
Chapter 8 Maven Release
123
Clean Goal
The prepare goal performs a lot of activities and generates temporary files,
such as release.properties and pom.xml.releaseBackup, as part of its
execution. Upon successful completion, it cleans up those temporary files.
Sometimes the prepare goal might fail (e.g., is unable to connect to Git)
and leave the project in a dirty state. This is where the release plug-in’s
clean goal comes into the picture. As the name suggests, it deletes any
temporary files generated as part of release execution.
Note The release plug-in’s clean goal must be used only when the
prepare goal fails.
Perform Goal
The perform goal is responsible for checking out code from the newly
created tag and builds and deploys the released code into the remote
repository.
The following phases are executed as part of perform goal:
• verify-completed-prepare-phases: This validates that a
prepare phase has been executed prior to running the
perform goal.
Figure 8-12. Git tag created upon prepare execution
Chapter 8 Maven Release
124
• checkout-project-from-scm: Checks out the released
code from the SCM tag.
• run-perform-goal: Executes the goals associated with
perform. The default goal is deploy.
The output of running the perform goal on gswm project is shown in
Listing 8-6.
Listing 8-6. Maven perform Command
C:\apress\gswm-book\chapter8\gswm>mvn release:perform
[INFO] Scanning for projects...
[INFO] -------------< com.apress.gswmbook:gswm >---------------
[INFO] Building Getting Started with Maven 1.0.1-SNAPSHOT
[INFO] --------------------[ jar ]-----------------------------
[INFO] --- maven-release-plugin:2.5.3:perform (default-cli)
@ gswm ---
[INFO] Checking out the project to perform the release ...
[INFO] Executing: cmd.exe /X /C "git clone --branch gswm-1.0.0
https://github.com/bava/intro-maven.git C:\apress\gswm-book\
chapter8\gswm\target\checkout"
[INFO] Invoking perform goals in directory C:\apress\gswm-book\
chapter8\gswm\target\checkout
[INFO] Executing goals 'deploy'...
 [INFO] Building jar: C:\apress\gswm-book\chapter8\gswm\target\
checkout\target\gswm-1.0.0-javadoc.jar
 [INFO] --- maven-install-plugin:2.4:install (default-install)
@ gswm ---
Chapter 8 Maven Release
125
 [INFO] Installing C:\apress\gswm-book\chapter8\gswm\target\
checkout\target\gswm-1.0.0.jar to C:\Users\bavara\.m2\
repository\com\apress\gswmbook\gswm\1.0.0\gswm-1.0.0.jar
 [INFO] --- maven-deploy-plugin:2.7:deploy (default-deploy)
@ gswm ---
[INFO] Uploading to nexusReleases: http://localhost:8081/
repository/maven-releases/com/apress/gswmbook/gswm/1.0.0/
gswm-1.0.0.jar
[INFO] Uploaded to nexusReleases: http://localhost:8081/
repository/maven-releases/com/apress/gswmbook/gswm/1.0.0/
gswm-1.0.0.jar (2.4 kB at 14 kB/s)
[INFO] Uploading to nexusReleases: http://localhost:8081/
repository/maven-releases/com/apress/gswmbook/gswm/1.0.0/
gswm-1.0.0.pom
[INFO] Uploaded to nexusReleases: http://localhost:8081/
repository/maven-releases/com/apress/gswmbook/gswm/1.0.0/
gswm-1.0.0-javadoc.jar (22 kB at 84 kB/s)
[INFO] BUILD SUCCESS
This completes the release of the 1.0.0 version of the gswm project. The
artifact ends up in the Nexus repository manager, as shown in Figure 8-13.



# APPENDIX A: MAVEN

<dependencies>
 <dependency>
 <groupId>org.junit.jupiter</groupId>
 <artifactId>junit-jupiter-api</artifactId>
 <version>5.6.0</version>
 <scope>test</scope>
 </dependency>
 <dependency>
 <groupId>org.jmock</groupId>
 <artifactId>jmock-junit5</artifactId>
 <version>2.12.0</version>
 </dependency>
 </dependencies>

Maven also introduced the concept of the local repository: a folder on a hard disk
(~/.m2/repository/) where Maven keeps the artifacts that it just downloaded from
the central repository. After we build our project, our artifacts are installed in the local
repository for later use by other projects, which is simple and neat.
 A developer might join a project managed by Maven and need access only to the
sources of the project. Maven downloads the needed dependencies from the central
repository and brings them to the local repository, where they will be available for
other projects that the same developer may work on.
Maven build life cycles 515




A.3 Maven build life cycles

A maven project can produce only one artifact.

Following are the three built-in Maven life cycles:

 Default—For generating the project artifact
 Clean—For cleaning the project
 Site—For generating the project documentation

Each of these life cycles is composed of several phases. To navigate a certain life cycle, the build follows its phases (figure A.1).

Following are the phases of the default life cycle:

1 Validate—Validate that the project is correct and all necessary information is
available.
2 Compile—Compile the source code of the project.
3 Test—Test the compiled source code using a suitable unit testing framework
(perhaps JUnit 5, in this case). The test should not require the code to be packaged or deployed.
4 Package—Package the compiled code in its distributable format, such as a jar
file.
Validate
Compile
Test
Package
Integration-test
Verify
Install
Deploy
5 Integration-test—Process and deploy the package (if necessary) into an environment where integration tests can be run.
6 Verify—Run any checks to verify that the package is valid and meets quality
criteria.
7 Install—Install the package in the local repository for use as a dependency in
other projects locally.
8 Deploy—In an integration or release environment, copy the final package to the
remote repository for sharing with other developers and projects.


Maven
invokes these phases in a very strict order; the phases are executed sequentially in the
order in which they are listed here, to complete the life cycle. If we invoke any of these
phases—if we type

mvn compile

on the command line in our project home directory, for example—Maven first validates the project and then tries to compile the sources of the project.
 One last thing: it is useful to think of all these phases as extension points. We can
attach additional Maven plugins to the phases and orchestrate the order and the way
in which these plugins are executed.


A.4 Plugin-based architecture
The last feature of Maven that we will mention here is its plugin-based architecture. We
mentioned that Maven is a source-building environment. More specifically, Maven is a
plugin-execution source-building environment. The core of the project is very small,
but the architecture of the project allows multiple plugins to be attached to the core.
This way, Maven builds an environment in which different plugins can be executed.
 Each phase in a given life cycle has several plugins attached, and Maven invokes
them when passing through the given phase in the order in which the plugins are
declared. Here are some of the core Maven plugins:
 Clean—Cleans up after the build
 Compiler—Compiles Java sources
 Deploy—Deploys the built artifact to the remote repository
 Install—Installs the built artifact in the local repository
 Resources—Copies the resources to the output directory for inclusion in the jar file
 Site—Generates a site that includes information about the current project
 Surefire—Runs the JUnit tests in an isolated classloader
 Verifier—Verifies the existence of certain conditions (useful for integration tests)
In addition to these core Maven plugins, other Maven plugins are available for many
situations, such as WAR (for packaging a web application) and Javadoc (for generating project documentation).
The Maven project object model (POM) 517
 Plugins are declared in the plugins section of the build configuration file, as in
this example:
<build>
 <plugins>
 <plugin>
 <artifactId>maven-surefire-plugin</artifactId>
 <version>2.22.2</version>
 </plugin>
 </plugins>
</build>
A plugin declaration can have a groupId, artifactId, and version. This way, the
plugins look like dependencies. In fact, plugins are handled the same way as dependencies; they are downloaded to the local repository like dependencies. When we
specify a plugin, the groupId and version parameters are optional; if we do not
declare them, Maven looks for a plugin with the specified artifactId and one of the
following groupIds: org.apache.maven.plugins or org.codehaus.mojo. As the
version is optional, Maven tries to download the latest available plugin version. Specifying the plugin versions is highly recommended to prevent auto-updates and nonreproducible builds. We may have built our project with the most recently updated
Maven plugin; but later, if another developer tries to make the same build with the
same configuration, and if the Maven plugin has since been updated, using the newest update may result in a nonreproducible build.
A.5 The Maven project object model (POM)
Maven has a build descriptor called pom.xml (short for project object model) by default.
We do not imperatively specify the things we want to do. We declaratively specify general information for the project itself, as in the following listing.
<project>
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.manning.junitbook</groupId>
 <artifactId>example-pom</artifactId>
 <packaging>jar</packaging>
 <version>1.0-SNAPSHOT</version>
</project>
This code looks really simple, doesn’t it? But one big question may arise: how is Maven
capable of building source code with so little information?
 The answer lies in the inheritance feature of the pom.xml files. Every simple
pom.xml inherits most of its functionality from a Super POM. As in Java, in which
every class inherits certain methods from the java.lang.Object class, the Super
POM empowers each pom.xml with Maven features.
 We can see the analogy between Java and Maven. To take this analogy even further,
Maven pom.xmls can inherit from one another; just as in Java, some classes can act as
Listing A.1 Very simple pom.xml
518 APPENDIX A Maven
parents for others. If we want to use the pom from listing A.1 for our parent, all we
have to do is change its packaging value to pom. Parent and aggregation (multimodule) projects can have pom only as a packaging value. We also need to define in our
parent which modules are the children.
<project>
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.manning.junitbook</groupId>
 <artifactId>example-pom</artifactId>
 <packaging>pom</packaging>
 <version>1.0-SNAPSHOT</version>
 <modules>
 <module>example-module</module>
 </modules>
</project>
Listing A.2 is an extension of listing A.1. We declare that this pom is an aggregation
module by declaring the package to be of pom type B and adding a modules section
c. The modules section lists all the children modules that our module has by providing the relative path to the project folder (example-module, in this case). The following listing shows the child pom.xml.
<project>
 <modelVersion>4.0.0</modelVersion>
 <parent>
 <groupId>com.manning.junitbook</groupId>
 <artifactId>example-pom</artifactId>
 <version>1.0-SNAPSHOT</version>
 </parent>
 <artifactId>example-child</artifactId>
</project>
Remember that this pom.xml resides in the folder that the parent XML has declared
(example-module, in this case).
 Two things are worth noticing here. First, because we inherit from some other pom,
we don’t need to specify groupId and version for the child pom; second, Maven
expects the values to be the same as in the parent.
 Going further with the analogy of Java, it seems reasonable to ask what kinds of
objects poms can inherit from their parents. Here are all the elements that a pom can
inherit from its parent:
 Dependencies
 Developers and contributors
 Plugins and their configurations
 Reports lists
Listing A.2 Parent pom.xml with a child module
Listing A.3 pom.xml that inherits the parent pom.xml
b
c
Each of these elements specified in the parent pom is automatically specified in the
child pom.


