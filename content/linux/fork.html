---
title: "Fork & Exec"
date: 2021-11-24
draft: false
---

<!--
COVERAGE: 24, 25, 26, 27
-->

<ul>
  <li>
    The <code>fork()</code> system call allows a parent process to create a new duplicate child process.
  </li>
  <li>
    The <code>exit()</code> function terminates a process with a specified integer indicating its termination status. All resources (memory, open file descriptors, etc.) used by the process are released back to the kernel.
  </li>
  <li>
    The <code>wait()</code> system call suspends execution of the calling process until one of its children has terminated and allows the calling process to obtain the termination status of the child.
  </li>
  <li>

  </li>
</ul>

<!--
- 
- The exit() function is layered on top of the _exit() system call. After a fork(), generally only one of the parent and child terminate by calling exit() while the other process should terminate using _exit().
- 
- The execve() system call loads a new program from the specified pathname and loads that program into the memory of the calling process. The existing program text is discarded, and the stack, data, and heap segments are freshly created for the new program.
-->



<h3>Forking a Child Process</h3>

{{% code c %}}#include <unistd.h>

pid_t fork(void);{{% /code %}}

<ul>
  <li>
    The <code>fork()</code> system call creates a new child process which is an (almost) exact duplicate of the parent process. The child obtains copies of the parent stack, heap and text segments.
  </li>
  <li>
    Execution continues in each process from the point where <code>fork()</code> returns.
  </li>
  <li>
    A call to <code>fork()</code> returns the PID of the created child process in the parent and <code>0</code> in the child process or <code>-1</code> on failure.
  </li>
  <li>
    After the <code>fork()</code>, each process can modify the variables in its stack, data and heap segments without affecting the other process.
  </li>
  <li>
    The child can obtain its own process ID using <code>getpid()</code> and the process ID of its parent using <code>getppid()</code>.
  </li>
  <li>
    When a <code>fork()</code> is performed, the child receives duplicates of all of the file descriptors of the parent. These duplicates are made in the manner of <code>dup()</code> which means that corresponding descriptors in the parent and the child refer to the same open file description amd the current file offsets are shared.
  </li>
</ul>


<h3>Process Termination</h3>

<!--
#include <unistd.h>

void _exit(int status);

A process can either terminate abnormally as a result of receiving a signal whose default action is to terminate the process or it can terminate normally using the _exit() system call.

The least significant 8 bits of the status argument given to _exit() define the termination status of the process and this status is made available to the parent of this process when it calls wait().

By convention, a termination status of 0 indicates that a process completed successfully and a nonzero status value indicates that the process terminated unsuccessfully.
The constants EXIT_SUCCESS (0) and EXIT_FAILURE (1) are defined 

A process is always successfully terminated by _exit() and so the call never returns.
-->


{{% code c %}}#include <stdlib.h>

void exit(int status);{{% /code %}}

<ul>
  <li>
    The <code>exit()</code> function calls any registered exit handlers in reverse order of their registration, flushes the stdio stream buffers and invokes <code>_exit()</code>.
  </li>
</ul>


<h3>Exit Handlers</h3>

{{% code c %}}#include <stdlib.h>

int atexit(void (*func)(void));{{% /code %}}

<ul>
  <li>
    The <code>atexit()</code> function adds a function that takes no arguments and returns no value to the list of exit handlers that are automatically called when the process terminates via <code>exit()</code>.
  </li>
  <li>
    It is possible to register multiple exit handlers. These functions are called in reverse order of registration when <code>exit()</code> is called.
  </li>
  <li>
    Exit handlers are not called if a program calls <code>_exit()</code>.
  </li>
  <li>
    Exit handlers are also not called if a process is abnormally terminated by a signal. Instead, we can establish handlers for the signals that might be sent to the process and have these handlers set a flag that causes the main program to call <code>exit()</code>. We generally cannot <code>exit()</code> from a signal handler.
  </li>
  <li>
    A child process created via <code>fork()</code> inherits a copy of the exit handler registrations of the parent. When a process performs an <code>exec()</code>, all exit handler registrations are removed.
  </li>
  <li>
    A call to <code>atexit()</code> returns <code>0</code> on success or a nonzero value on error.
  </li>
</ul>

<!-- 
If the child needs to inform the parent that it terminated because of a signal,
then the child’s signal handler should first disestablish itself, and then raise the
same signal once more, which this time will terminate the process. The signal
handler would contain code such as the following:

void handler(int sig)
{
 /* Perform cleanup steps */
 signal(sig, SIG_DFL); /* Disestablish handler */
 raise(sig); /* Raise signal again */
}
-->


<h3>wait()</h3>

{{% code c %}}#include <sys/wait.h>

pid_t wait(int *status);{{% /code %}}

<ul>
  <li>
    The <code>wait()</code> system call waits for one of the children of the calling process to terminate and returns the termination status of that child in the buffer pointed to by <code>status</code>.
  </li>
  <li>
    If no child has yet terminated then the call blocks until one of the children terminates. If a child has already terminated then the call returns immediately.
  </li>
  <li>
    A call to <code>wait()</code> returns the PID of the child that has terminated and or <code>-1</code> on error.
  </li>
  <li>
    One possible error is that the calling process has no children left to wait for which is indicated by the errno value <code>ECHILD</code>.
  </li>
</ul>

<!--
while ((childPid = wait(NULL)) != -1)
  continue;
if (errno != ECHILD) {
  fprintf(stderr, "wait: %s\n", strerror(errno));
  exit(EXIT_FAILURE);
}
-->



<h3>waitpid()</h3>

{{% code c %}}#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);{{% /code %}}

<ul>
  <li>
    The <code>waitpid()</code> system waits for one of the children of the calling process to terminate and also enables the selection of the child to be waited for using the <code>pid</code> argument as follows:
    
    <ul>
      <li>
        <code>pid > 0</code>: Wait for the child whose process ID equals <code>pid</code>.
      </li>
      <li>
        <code>pid = 0</code>: Wait for any child in the same process group as the parent.
      </li>
      <li>
        <code>pid < -1</code>: Wait for any child whose process group identifier equals the absolute value of <code>pid</code>.
      </li>
      <li>
        <code>pid = -1</code>: Wait for any child.
      </li>
    </ul>
  </li>
  <li>
    The <code>options</code> argument is a bit mask that can include zero or more of the following flags:

    <ul>
      <li>
        <code>WUNTRACED</code>: In addition to returning information about terminated children, also return information when a child is stopped by a signal.
      </li>
      <li>
        <code>WCONTINUED</code>: Also return status information about stopped children that have been resumed by delivery of a SIGCONT signal.
      </li>
      <li>
        <code>WNOHANG</code>: If no child specified by <code>pid</code> has yet changed state then return immediately with a return value of <code>0</code>.
      </li>
    </ul>
  </li>
  <li>
    The <sys/wait.h> header file defines a standard set of macros that can be used to dissect a wait status value. When applied to a status value returned by wait() or waitpid(), only one of the following will return true:

    <ul>
      <li>
        <code>WIFEXITED(status)</code>: Returns true if the child process exited normally. In this case, the macro <code>WEXITSTATUS(status)</code> returns the exit status of the child process.
      </li>
      <li>
        <code>WIFSIGNALED(status)</code>: This macro returns true if the child process was killed by a signal. In this case, the macro <code>WTERMSIG(status)</code> returns the number of the signal that caused the process to terminate.
      </li>
      <li>
        <code>WIFSTOPPED(status)</code>: This macro returns true if the child process was stopped by a signal. In this case, the macro <code>WSTOPSIG(status)</code> returns the number of the signal that stopped the process.
      </li>
      <li>
        <code>WIFCONTINUED(status)</code>: This macro returns true if the child was resumed by delivery of <code>SIGCONT</code>.
      </li>
    </ul>
  </li>
</ul>







<h3>Orphans and Zombies</h3>

<!--
- If a parent process terminates before one of its child processes then the child becomes and orphan and is adopted by the init process (pid = 1).
- If a child terminates before its parent has called wait() then the child becomes a zombie. Most of the resources held by the child are released except for an entry in the process table including the pid of the child and its termination status.
- This allows the parent to obtain the status by calling wait() at which point the kernel removes the zombie.
- If a parent terminates wuithout calling wait() then a zombie child process is adopted by init which automatically performs a wait().
- A zombie process cannot be be killed by a signal (even SIGKILL).
- If a large number of such zombie children are created, they will eventually fill the kernel process table and so prevent the creation of new processes.
- The parent can periodically poll for dead children via a call to waitpid() specifying the WNOHANG flag.
- Using the PR_SET_PDEATHSIG operation of the Linux-specific prctl() system call, it is possible to arrange that a process receives a specified signal when it becomes an orphan.

zombies.c
-->



<h3>The SIGCHLD Signal</h3>

<!--
-  The SIGCHLD signal is sent to a parent process whenever one of its children terminates.
- By default, this signal is ignored though we can establish a signal handler to catch the signal and use wait() to reap the zombie child.
- However, when a signal handler is called, the signal that caused its invocation is temporarily blocked. Further, standard signals (of which SIGCHLD is one) are not queued.
- Consequently, if a second and third child terminate in quick succession while a SIGCHLD handler is executing for an already terminated child, then, although SIGCHLD is generated twice, it is queued only once to the parent.
- As a result, if the SIGCHLD handler called wait() only once each time it was invoked then it might fail to reap some zombie children.
- The solution is to loop inside the SIGCHLD handler, repeatedly calling waitpid() with the WNOHANG flag until there are no more dead children to be reaped (return value 0) or an error occurs (return value -1).
- A further point to consider is the issue of reentrancy.Using a system call like waitpid() from within a signal handler may change the value of errno. Such a change could interfere with attempts by the main program to explicitly set errno or check its value after a failed system call. For this reason, it is sometimes necessary to code a SIGCHLD handler to save errno in a local variable on entry to the handler, and then restore the errno value just prior to returning. 

reaper.c
-->




26.3.2 Delivery of SIGCHLD for Stopped Children

Just as waitpid() can be used to monitor stopped children, so is it possible for a parent
process to receive the SIGCHLD signal when one of its children is stopped by a signal. This
behavior is controlled by the SA_NOCLDSTOP flag when using sigaction() to establish a
handler for the SIGCHLD signal. If this flag is omitted, a SIGCHLD signal is delivered to
the parent when one of its children stops; if the flag is present, SIGCHLD is not delivered for stopped children. (The implementation of signal() given in Section 22.7
doesn’t specify SA_NOCLDSTOP.)
Since SIGCHLD is ignored by default, the SA_NOCLDSTOP flag has a meaning only if
we are establishing a handler for SIGCHLD. Furthermore, SIGCHLD is the only signal
for which the SA_NOCLDSTOP flag has an effect.
SUSv3 also allows for a parent to be sent a SIGCHLD signal if one of its stopped children is resumed by being sent a SIGCONT signal. (This corresponds to the WCONTINUED
flag for waitpid().) This feature is implemented in Linux since kernel 2.6.9.
26.3.3 Ignoring Dead Child Processes
There is a further possibility for dealing with dead child processes. Explicitly setting
the disposition of SIGCHLD to SIG_IGN causes any child process that subsequently terminates to be immediately removed from the system instead of being converted
into a zombie. In this case, since the status of the child process is simply discarded,
a subsequent call to wait() (or similar) can’t return any information for the terminated child.
Note that even though the default disposition for SIGCHLD is to be ignored,
explicitly setting the disposition to SIG_IGN causes the different behavior
described here. In this respect, SIGCHLD is treated uniquely among signals.
On Linux, as on many UNIX implementations, setting the disposition of SIGCHLD to
SIG_IGN doesn’t affect the status of any existing zombie children, which must still be
waited upon in the usual way. On some other UNIX implementations (e.g., Solaris 8),
setting the disposition of SIGCHLD to SIG_IGN does remove existing zombie children.
560 Chapter 26
The SIG_IGN semantics for SIGCHLD have a long history, deriving from System V.
SUSv3 specifies the behavior described here, but these semantics were left unspecified
in the original POSIX.1 standard. Thus, on some older UNIX implementations,
ignoring SIGCHLD has no effect on the creation of zombies. The only completely portable
way of preventing the creation of zombies is to call wait() or waitpid(), possibly from
within a handler established for SIGCHLD.
Deviations from SUSv3 in older Linux kernels
SUSv3 specifies that if the disposition of SIGCHLD is set to SIG_IGN, the resource usage
information for the child should be discarded and not included in the totals
returned when the parent makes a call to getrusage() specifying the RUSAGE_CHILDREN
flag (Section 36.1). However, on Linux versions before kernel 2.6.9, the CPU times
and resources used by the child are recorded and are visible in calls to getrusage().
This nonconformance is fixed in Linux 2.6.9 and later.
Setting the disposition of SIGCHLD to SIG_IGN should also prevent the child CPU
times from being included in the structure returned by times() (Section 10.7).
However, on Linux kernels before 2.6.9, a similar nonconformance applies for
the information returned by times().
SUSv3 specifies that if the disposition of SIGCHLD is set to SIG_IGN, and the parent has
no terminated children that have been transformed into zombies and have not yet
been waited for, then a call to wait() (or waitpid()) should block until all of the parent’s
children have terminated, at which point the call should terminate with the error
ECHILD. Linux 2.6 conforms to this requirement. However, in Linux 2.4 and earlier,
wait() blocks only until the next child terminates, and then returns the process ID
and status of that child (i.e., the behavior is the same as if the disposition of SIGCHLD
had not been set to SIG_IGN).
The sigaction() SA_NOCLDWAIT flag
SUSv3 specifies the SA_NOCLDWAIT flag, which can be used when setting the disposition of the SIGCHLD signal using sigaction(). This flag produces behavior similar to
that when the disposition of SIGCHLD is set to SIG_IGN. This flag was not implemented
in Linux 2.4 and earlier, but is implemented in Linux 2.6.
The principal difference between setting the disposition of SIGCHLD to SIG_IGN
and employing SA_NOCLDWAIT is that, when establishing a handler with SA_NOCLDWAIT,
SUSv3 leaves it unspecified whether or not a SIGCHLD signal is sent to the parent
when a child terminates. In other words, an implementation is permitted to deliver
SIGCHLD when SA_NOCLDWAIT is specified, and an application could catch this signal
(although the SIGCHLD handler would not be able to reap the child status using
wait(), since the kernel has already discarded the zombie).




<h3>Executing a New Program</h3>

#include <unistd.h>
int execve(const char *pathname, char *const argv[], char *const envp[]);

- The execve() system call loads a new program into a process’s memory. During this operation, the old program is discarded, and the process’s stack, data, and heap are replaced by those of the new program.
= After executing various C library run-time
startup code and program initialization code, the
new program commences execution at its main() function.
Various library functions, all with names beginning with exec, are layered on
top of the execve() system call. Each of these functions provides a different interface
to the same functionality.


- The pathname argument contains the pathname of the new program to be loaded into the process’s memory. The argv argument is a NULL-terminated list of pointers to character strings that specifies the command-line arguments to be passed to the
new program. The value supplied for argv[0] corresponds to the command name.
The final argument, envp, specifies the environment list for the new program. The envp argument corresponds to the environ array of the new program; it is a NULL-terminated list of pointers to character strings of the form name=value (Section 6.7).

Since it replaces the program that called it, a successful execve() never returns. We never need to check the return value from execve(); it will always be –1. The very fact that it returned informs us that an error occurred, and, as usual, we can use
errno to determine the cause.



#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 char *argVec[10]; /* Larger than required */
 char *envVec[] = { "GREET=salut", "BYE=adieu", NULL };
 if (argc != 2 || strcmp(argv[1], "--help") == 0)
 usageErr("%s pathname\n", argv[0]);
 argVec[0] = strrchr(argv[1], '/'); /* Get basename from argv[1] */
 if (argVec[0] != NULL)
 argVec[0]++;
 else
 argVec[0] = argv[1];
 argVec[1] = "hello world";
 argVec[2] = "goodbye";
 argVec[3] = NULL; /* List must be NULL-terminated */
 execve(argv[1], argVec, envVec);
 errExit("execve"); /* If we get here, something went wrong */
}
–––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/t_execve.c
Listing 27-2: Display argument list and environment
––––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/envargs.c
#include "tlpi_hdr.h"
extern char **environ;
int
main(int argc, char *argv[])
{
 int j;
 char **ep;
 for (j = 0; j < argc; j++)
 printf("argv[%d] = %s\n", j, argv[j]);
 for (ep = environ; *ep != NULL; ep++)
 printf("environ: %s\n", *ep);
 exit(EXIT_SUCCESS);
}
––––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/envargs.c



<h3>The exec() Library Functions</h3>

#include <unistd.h>
  int execle(const char *pathname, const char *arg, ...
   /* , (char *) NULL, char *const envp[] */ );
  int execlp(const char *filename, const char *arg, ...
   /* , (char *) NULL */);
  int execvp(const char *filename, char *const argv[]);
  int execv(const char *pathname, char *const argv[]);
  int execl(const char *pathname, const char *arg, ...
   /* , (char *) NULL */);
  None of the above returns on success; all return –1 on error


The library functions described in this section provide alternative APIs for performing an exec().

All of these functions are layered on top of execve() and they differ from one another and from execve() only in the way in which the program name,
argument list, and environment of the new program are specified.

z Most of the exec() functions expect a pathname as the specification of the new
program to be loaded. However, execlp() and execvp() allow the program to be specified using just a filename. The filename is sought in the list of directories specified in the PATH environment variable (explained in more detail below). This is the
kind of searching that the shell performs when given a command name. To
indicate this difference in operation, the names of these functions contain the
letter p (for PATH). The PATH variable is not used if the filename contains a slash
(/), in which case it is treated as a relative or absolute pathname.
z Instead of using an array to specify the argv list for the new program, execle(),
execlp(), and execl() require the programmer to specify the arguments as a list of
strings within the call. The first of these arguments corresponds to argv[0] in
the main function of the new program, and is thus typically the same as the
filename argument or the basename component of the pathname argument. A
NULL pointer must terminate the argument list, so that these calls can locate the
end of the list. (This requirement is indicated by the commented (char *) NULL
in the above prototypes; for a discussion of why the cast is required before the
NULL, see Appendix C.) The names of these functions contain the letter l (for list) to
distinguish them from those functions requiring the argument list as a NULLterminated array. The names of the functions that require the argument list as an
array (execve(), execvp(), and execv()) contain the letter v (for vector).
z The execve() and execle() functions allow the programmer to explicitly specify
the environment for the new program using envp, a NULL-terminated array of
pointers to character strings. The names of these functions end with the letter e
(for environment) to indicate this fact. All of the other exec() functions use the
caller’s existing environment (i.e., the contents of environ) as the environment
for the new program.
Version 2.11 of glibc added a nonstandard function, execvpe(file, argv, envp).
This function is like execvp(), but instead of taking the environment for the new
program from environ, the caller specifies the new environment via the envp
argument (like execve() and execle()).
In the next few pages, we demonstrate the use of some of these exec() variants.



27.2.1 The PATH Environment Variable
The value of PATH is a string consisting of colon-separated directory names called path prefixes.

t_execlp.c
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 if (argc != 2 || strcmp(argv[1], "--help") == 0)
 usageErr("%s pathname\n", argv[0]);
 execlp(argv[1], argv[1], "hello world", (char *) NULL);
 errExit("execlp"); /* If we get here, something went wrong */
}
–––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/t_execlp.c



27.2.2 Specifying Program Arguments as a List
When we know the number of arguments for an exec() at the time we write a program,
we can use execle(), execlp(), or execl() to specify the arguments as a list within the
function call. This can be convenient, since it requires less code than assembling
the arguments in an argv vector. The program in Listing 27-4 achieves the same
result as the program in Listing 27-1 but using execle() instead of execve().
Listing 27-4: Using execle() to specify program arguments as a list
–––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/t_execle.c
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 char *envVec[] = { "GREET=salut", "BYE=adieu", NULL };
 char *filename;
 if (argc != 2 || strcmp(argv[1], "--help") == 0)
 usageErr("%s pathname\n", argv[0]);
 filename = strrchr(argv[1], '/'); /* Get basename from argv[1] */
 if (filename != NULL)
 filename++;
 else
 filename = argv[1];
 execle(argv[1], filename, "hello world", (char *) NULL, envVec);
 errExit("execle"); /* If we get here, something went wrong */
}
–––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/t_execle.c
27.2.3 Passing the Caller’s Environment to the New Program
The execlp(), execvp(), execl(), and execv() functions don’t permit the programmer to
explicitly specify an environment list; instead, the new program inherits its environment from the calling process (Section 6.7). This may, or may not, be desirable. For
Program Execution 571
security reasons, it is sometimes preferable to ensure that a program is execed with
a known environment list. We consider this point further in Section 38.8.
Listing 27-5 demonstrates that the new program inherits its environment from
the caller during an execl() call. This program first uses putenv() to make a change
to the environment that it inherits from the shell as a result of fork(). Then the
printenv program is execed to display the values of the USER and SHELL environment
variables. When we run this program, we see the following:
$ echo $USER $SHELL Display some of the shell’s environment variables
blv /bin/bash
$ ./t_execl
Initial value of USER: blv Copy of environment was inherited from the shell
britta These two lines are displayed by execed printenv
/bin/bash
Listing 27-5: Passing the caller’s environment to the new program using execl()
––––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/t_execl.c
#include <stdlib.h>
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 printf("Initial value of USER: %s\n", getenv("USER"));
 if (putenv("USER=britta") != 0)
 errExit("putenv");
 execl("/usr/bin/printenv", "printenv", "USER", "SHELL", (char *) NULL);
 errExit("execl"); /* If we get here, something went wrong */
}
––––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/t_execl.c




27.4 File Descriptors and exec()
By default, all file descriptors opened by a program that calls exec() remain open
across the exec() and are available for use by the new program. This is frequently
useful, because the calling program may open files on particular descriptors, and
these files are automatically available to the new program, without it needing to
know the names of, or open, the files.
The shell takes advantage of this feature to handle I/O redirection for the
programs that it executes. For example, suppose we enter the following shell
command:
$ ls /tmp > dir.txt
The shell performs the following steps to execute this command:
1. A fork() is performed to create a child process that is also running a copy of the
shell (and thus has a copy of the command).
2. The child shell opens dir.txt for output using file descriptor 1 (standard output).
This can be done in either of the following ways:
a) The child shell closes descriptor 1 (STDOUT_FILENO) and then opens the file
dir.txt. Since open() always uses the lowest available file descriptor, and
standard input (descriptor 0) remains open, the file will be opened on
descriptor 1.
b) The shell opens dir.txt, obtaining a new file descriptor. Then, if that file
descriptor is not standard output, the shell uses dup2() to force standard
output to be a duplicate of the new descriptor and closes the new descriptor,
since it is no longer required. (This method is safer than the preceding
576 Chapter 27
method, since it doesn’t rely on lower-numbered descriptors being open.)
The code sequence is something like the following:
fd = open("dir.txt", O_WRONLY | O_CREAT,
 S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
/* rw-rw-rw- */
if (fd != STDOUT_FILENO) {
 dup2(fd, STDOUT_FILENO);
 close(fd);
}
3. The child shell execs the ls program. The ls program writes its output to standard output, which is the file dir.txt.
The explanation given here of how the shell performs I/O redirections simplifies some points. In particular, certain commands—so-called shell built-in
commands—are executed directly by the shell, without performing a fork() or
an exec(). Such commands must be treated somewhat differently for the purposes
of I/O redirection.
A shell command is implemented as a built-in for either of two reasons:
efficiency and to obtain side effects within the shell. Some frequently used
commands—such as pwd, echo, and test—are sufficiently simple that it is a worthwhile efficiency to implement them inside the shell. Other commands are
implemented within the shell so that they have side effects on the shell itself—
that is, they change information stored by the shell, or modify attributes of or
affect the execution of the shell process. For example, the cd command must
change the working directory of the shell itself, and so can’t be executed
within a separate process. Other examples of commands that are built in for
their side effects include exec, exit, read, set, source, ulimit, umask, wait, and the
shell job-control commands (jobs, fg, and bg). The full set of built-in commands
understood by a shell is documented in the shell’s manual page.
The close-on-exec flag (FD_CLOEXEC)
Sometimes, it may be desirable to ensure that certain file descriptors are closed
before an exec(). In particular, if we exec() an unknown program (i.e., one that we
did not write) from a privileged process, or a program that doesn’t need descriptors for files we have already opened, then it is secure programming practice to
ensure that all unnecessary file descriptors are closed before the new program is
loaded. We could do this by calling close() on all such descriptors, but this suffers
the following limitations:
z The file descriptor may have been opened by a library function. This function
has no mechanism to force the main program to close the file descriptor
before the exec() is performed. (As a general principle, library functions should
always set the close-on-exec flag, using the technique described below, for any
files that they open.)
Program Execution 577
z If the exec() call fails for some reason, we may want to keep the file descriptors
open. If they are already closed, it may be difficult, or impossible, to reopen
them so that they refer to the same files.
For these reasons, the kernel provides a close-on-exec flag for each file descriptor.
If this flag is set, then the file descriptor is automatically closed during a successful
exec(), but left open if the exec() fails. The close-on-exec flag for a file descriptor can
be accessed using the fcntl() system call (Section 5.2). The fcntl() F_GETFD operation
retrieves a copy of the file descriptor flags:
int flags;
flags = fcntl(fd, F_GETFD);
if (flags == -1)
 errExit("fcntl");
After retrieving these flags, we can modify the FD_CLOEXEC bit and use a second fcntl()
call specifying F_SETFD to update the flags:
flags |= FD_CLOEXEC;
if (fcntl(fd, F_SETFD, flags) == -1)
 errExit("fcntl");
FD_CLOEXEC is actually the only bit used in the file descriptor flags. This bit corresponds to the value 1. In older programs, we may sometimes see the close-onexec flag set using just the call fcntl(fd, F_SETFD, 1), relying on the fact that
there are no other bits that can be affected by this operation. Theoretically,
this may not always be so (in the future, some UNIX system might implement
additional flag bits), so we should use the technique shown in the main text.
Many UNIX implementations, including Linux, also allow the close-onexec flag to be modified using two unstandardized ioctl() calls: ioctl(fd,
FIOCLEX) to set the close-on-exec flag for fd, and ioctl(fd, FIONCLEX) to clear
the flag.
When dup(), dup2(), or fcntl() is used to create a duplicate of a file descriptor, the
close-on-exec flag is always cleared for the duplicate descriptor. (This behavior is
historical and an SUSv3 requirement.)
Listing 27-6 demonstrates the manipulation of the close-on-exec flag. Depending on the presence of a command-line argument (any string), this program first
sets the close-on-exec flag for standard output and then execs the ls program. Here
is what we see when we run the program:
$ ./closeonexec Exec ls without closing standard output
-rwxr-xr-x 1 mtk users 28098 Jun 15 13:59 closeonexec
$ ./closeonexec n Sets close-on-exec flag for standard output
ls: write error: Bad file descriptor
In the second run shown above, ls detects that its standard output is closed and
prints an error message on standard error.
578 Chapter 27
Listing 27-6: Setting the close-on-exec flag for a file descriptor
–––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/closeonexec.c
#include <fcntl.h>
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 int flags;
 if (argc > 1) {
 flags = fcntl(STDOUT_FILENO, F_GETFD); /* Fetch flags */
 if (flags == -1)
 errExit("fcntl - F_GETFD");
 flags |= FD_CLOEXEC; /* Turn on FD_CLOEXEC */
 if (fcntl(STDOUT_FILENO, F_SETFD, flags) == -1) /* Update flags */
 errExit("fcntl - F_SETFD");
 }
 execlp("ls", "ls", "-l", argv[0], (char *) NULL);
 errExit("execlp");
}


27.5 Signals and exec()
During an exec(), the text of the existing process is discarded. This text may include
signal handlers established by the calling program. Because the handlers disappear,
the kernel resets the dispositions of all handled signals to SIG_DFL. The dispositions
of all other signals (i.e., those with dispositions of SIG_IGN or SIG_DFL) are left
unchanged by an exec(). This behavior is required by SUSv3.
SUSv3 makes a special case for an ignored SIGCHLD signal. (We noted in Section 26.3.3 that ignoring SIGCHLD prevents the creation of zombies.) SUSv3 leaves it
unspecified whether an ignored SIGCHLD remains ignored across an exec() or its disposition is reset to SIG_DFL. Linux does the former, but some other UNIX implementations (e.g., Solaris) do the latter. This implies that, in programs that ignore
SIGCHLD, for maximum portability, we should perform a signal(SIGCHLD, SIG_DFL)
call prior to an exec(), and ensure that we don’t write programs that rely on the initial disposition of SIGCHLD being anything other than SIG_DFL.
The destruction of the old program’s data, heap, and stack also means that any
alternate signal stack established by a call to sigaltstack() (Section 21.3) is lost. Since
an alternate signal stack is not preserved across an exec(), the SA_ONSTACK bit is also
cleared for all signals.
During an exec(), the process signal mask and set of pending signals are both
preserved. This feature allows us to block and queue signals for the newly execed
program. However, SUSv3 notes that many existing applications wrongly assume
that they are started with the disposition of certain signals set to SIG_DFL or that
these signals are unblocked. (In particular, the C standards provide a much weaker
Program Execution 579
specification of signals, which doesn’t specify signal blocking; therefore, C programs written on non-UNIX systems won’t know to unblock signals.) For this reason,
SUSv3 recommends that signals should not be blocked or ignored across an exec()
of an arbitrary program. Here, “arbitrary” means a program that we did not write.
It is acceptable to block or ignore signals when execing a program we have written
or one with known behavior with respect to signals.



27.6 Executing a Shell Command: system()

#include <stdlib.h>

int system(const char *command);

- The system() function allows the calling program to execute an arbitrary shell command.

The system() function creates a child process that invokes a shell to execute
command. Here is an example of a call to system():

system("ls | wc");

z Error and signal handling are performed by system() on our behalf.
z Because system() uses the shell to execute command, all of the usual shell processing, substitutions, and redirections are performed on command before it is
executed. This makes it easy to add an “execute a shell command” feature to an
application. (Many interactive applications provide such a feature in the form
of a ! command.)

Executing a command using system()
requires the creation of at least two processes—one for the shell and one or more
for the command(s) it executes—each of which performs an exec(). 

The return value of system() is as follows:
z If command is a NULL pointer, then system() returns a nonzero value if a shell is
available, and 0 if no shell is available. This case arises out of the C programming
language standards, which are not tied to any operating system, so a shell
might not be available if system() is running on a non-UNIX system. Furthermore, even though all UNIX implementations have a shell, this shell might not

See main text for a description of return value
580 Chapter 27
be available if the program called chroot() before calling system(). If command is
non-NULL, then the return value for system() is determined according to the
remaining rules in this list.
z If a child process could not be created or its termination status could not be
retrieved, then system() returns –1.
z If a shell could not be execed in the child process, then system() returns a value
as though the child shell had terminated with the call _exit(127).
z If all system calls succeed, then system() returns the termination status of the
child shell used to execute command. (The termination status of a shell is the termination status of the last command it executes.)
It is impossible (using the value returned by system()) to distinguish the case
where system() fails to exec a shell from the case where the shell exits with the
status 127 (the latter possibility can occur if the shell could not find a program
with the given name to exec).
In the last two cases, the value returned by system() is a wait status of the same
form returned by waitpid(). This means we should use the functions described in
Section 26.1.3 to dissect this value, and we can display the value using our
printWaitStatus() function (Listing 26-2, on page 546).
Example program
Listing 27-7 demonstrates the use of system(). This program executes a loop that
reads a command string, executes it using system(), and then analyzes and displays
the value returned by system(). Here is a sample run:
$ ./t_system
Command: whoami
mtk
system() returned: status=0x0000 (0,0)
child exited, status=0
Command: ls | grep XYZ Shell terminates with the status of…
system() returned: status=0x0100 (1,0) its last command (grep), which…
child exited, status=1 found no match, and so did an exit(1)
Command: exit 127
system() returned: status=0x7f00 (127,0)
(Probably) could not invoke shell Actually, not true in this case
Command: sleep 100
Type Control-Z to suspend foreground process group
[1]+ Stopped ./t_system
$ ps | grep sleep Find PID of sleep
29361 pts/6 00:00:00 sleep
$ kill 29361 And send a signal to terminate it
$ fg Bring t_system back into foreground
./t_system
system() returned: status=0x000f (0,15)
child killed by signal 15 (Terminated)
Command: ^D$ Type Control-D to terminate program
Program Execution 581
Listing 27-7: Executing shell commands with system()
–––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/t_system.c
#include <sys/wait.h>
#include "print_wait_status.h"
#include "tlpi_hdr.h"
#define MAX_CMD_LEN 200
int
main(int argc, char *argv[])
{
 char str[MAX_CMD_LEN]; /* Command to be executed by system() */
 int status; /* Status return from system() */
 for (;;) { /* Read and execute a shell command */
 printf("Command: ");
 fflush(stdout);
 if (fgets(str, MAX_CMD_LEN, stdin) == NULL)
 break; /* end-of-file */
 status = system(str);
 printf("system() returned: status=0x%04x (%d,%d)\n",
 (unsigned int) status, status >> 8, status & 0xff);
 if (status == -1) {
 errExit("system");
 } else {
 if (WIFEXITED(status) && WEXITSTATUS(status) == 127)
 printf("(Probably) could not invoke shell\n");
 else /* Shell successfully executed command */
 printWaitStatus(NULL, status);
 }
 }
 exit(EXIT_SUCCESS);
}
–––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/t_system.c
Avoid using system() in set-user-ID and set-group-ID programs
Set-user-ID and set-group-ID programs should never use system() while operating
under the program’s privileged identifier. Even when such programs don’t allow
the user to specify the text of the command to be executed, the shell’s reliance on
various environment variables to control its operation means that the use of system()
inevitably opens the door for a system security breach.
For example, in older Bourne shells, the IFS environment variable, which
defined the internal field separator used to break a command line into separate
words, was the source of a number of successful system break-ins. If we defined IFS
to have the value a, then the shell would treat the command string shar as the word
sh followed by the argument r, and invoke another shell to execute the script file
named r in the current working directory, instead of the intended purpose (executing a command named shar). This particular security hole was fixed by applying IFS
582 Chapter 27
only to the words produced by shell expansions. In addition, modern shells reset
IFS (to a string consisting of the three characters space, tab, and newline) on shell
startup to ensure that scripts behave consistently if they inherit a strange IFS value.
As a further security measure, bash reverts to the real user (group) ID when
invoked from a set-user-ID (set-group-ID) program.
Secure programs that need to spawn another program should use fork() and
one of the exec() functions—other than execlp() or execvp()—directly.



27.7 Implementing system()

What adds complexity to the implementation of system() is the correct treatment
with signals.
The first signal to consider is SIGCHLD. Suppose that the program calling system()
is also directly creating children, and has established a handler for SIGCHLD that performs its own wait(). In this situation, when a SIGCHLD signal is generated by the termination of the child created by system(), it is possible that the signal handler of the
main program will be invoked—and collect the child’s status—before system() has a
chance to call waitpid(). (This is an example of a race condition.) This has two undesirable consequences:
z The calling program would be deceived into thinking that one of the children
that it created has terminated.
z The system() function would be unable to obtain the termination status of the
child that it created.
Therefore, system() must block delivery of SIGCHLD while it is executing.
The other signals to consider are those generated by the terminal interrupt
(usually Control-C) and quit (usually Control-\) characters, SIGINT and SIGQUIT, respectively. Consider what is happening when we execute the following call:
system("sleep 20");
At this point, three processes are running: the process executing the calling program,
a shell, and sleep, as shown in Figure 27-2.
As an efficiency measure, when the string given to the –c option is a simple
command (as opposed to a pipeline or a sequence), some shells (including
bash) directly exec the command, rather than forking a child shell. For shells
that perform such an optimization, Figure 27-2 is not strictly accurate, since
there will be only two processes (the calling process and sleep). Nevertheless,
the arguments in this section about how system() should handle signals still apply.
All of the processes shown in Figure 27-2 form part of the foreground process
group for the terminal. (We consider process groups in detail in Section 34.2.)
Therefore, when we type the interrupt or quit characters, all three processes are sent
the corresponding signal. The shell ignores SIGINT and SIGQUIT while waiting for its
584 Chapter 27
child. However, both the calling program and the sleep process would, by default,
be killed by these signals.
How should the calling process and the executed command respond to these
signals? SUSv3 specifies the following:
z SIGINT and SIGQUIT should be ignored in the calling process while the command
is being executed.
z In the child, SIGINT and SIGQUIT should be treated as they would be if the calling
process did a fork() and exec(); that is, the disposition of handled signals is reset
to the default, and the disposition of other signals remains unchanged.
Figure 27-2: Arrangement of processes during execution of system(“sleep 20”)
Dealing with signals in the manner specified by SUSv3 is the most reasonable
approach, for the following reasons:
z It would not make sense to have both processes responding to these signals,
since this could lead to confusing behaviors for the user of the application.
z Similarly, it would not make sense to ignore these signals in the process executing
the command while treating them according to their default dispositions in the
calling process. This would allow the user to do things such as killing the calling
process while the executed command was left running. It is also inconsistent
with the fact that the calling process has actually given up control (i.e., is
blocked in a waitpid() call) while the command passed to system() is being executed.
z The command executed by system() may be an interactive application, and it
makes sense to have this application respond to terminal-generated signals.
SUSv3 requires the treatment of SIGINT and SIGQUIT described above, but notes that
this could have an undesirable effect in a program that invisibly uses system() to perform some task. While the command is being executed, typing Control-C or Control-\
will kill only the child of system(), while the application (unexpectedly, to the user)
continues to run. A program that uses system() in this way should check the termination status returned by system(), and take appropriate action if it detects that the
command was killed by a signal.
fork(), exec()
fork(), exec()
Foreground process group
Child shell created by system()
Child process created by
shell (executes command
given to system())
calling process Caller of system()
sh
sleep
Program Execution 585
An improved system() implementation
Listing 27-9 shows an implementation of system() conforming to the rules described
above. Note the following points about this implementation:
z As noted earlier, if command is a NULL pointer, then system() should return nonzero if a shell is available or 0 if no shell is available. The only way to reliably
determine this information is to try to execute a shell. We do this by recursively
calling system() to execute the : shell command and checking for a return status
of 0 from the recursive call q. The : command is a shell built-in command that
does nothing, but always returns a success status. We could have executed the
shell command exit 0 to achieve the same result. (Note that it isn’t sufficient to
use access() to check whether the file /bin/sh exists and has execute permission
enabled. In a chroot() environment, even if the shell executable is present, it
may not be executable it if it is dynamically linked and the required shared
libraries are not available.)
z It is only in the parent process (the caller of system()) that SIGCHLD needs to be
blocked w, and SIGINT and SIGQUIT need to be ignored e. However, we must
perform these actions prior to the fork() call, because, if they were done in the parent after the fork(), we would create a race condition. (Suppose, for example,
that the child exited before the parent had a chance to block SIGCHLD.) Consequently, the child must undo these changes to the signal attributes, as
described shortly.
z In the parent, we ignore errors from the sigaction() and sigprocmask() calls used
to manipulate signal dispositions and the signal mask w e o. We do this for
two reasons. First, these calls are very unlikely to fail. In practice, the only thing
that can realistically go wrong with these calls is an error in specifying their
arguments, and such an error should be eliminated during initial debugging.
Second, we assume that the caller is more interested in knowing if fork() or
waitpid() failed than in knowing if these signal-manipulation calls failed. For
similar reasons, we bracket the signal-manipulation calls used at the end of
system() with code to save i and restore errno a, so that if fork() or waitpid()
fails, then the caller can determine why. If we returned –1 because these signalmanipulation calls failed, then the caller might wrongly assume that system()
failed to execute command.
SUSv3 merely says that system() should return –1 if a child process could not be
created or its status could not be obtained. No mention is made of a –1 return
because of failures in signal-manipulation operations by system().
z Error checking is not performed for signal-related system calls in the child r
t. On the one hand, there is no way of reporting such an error (the use of
_exit(127) is reserved for reporting an error when execing the shell); on the
other hand, such failures don’t affect the caller of system(), which is a separate
process.
586 Chapter 27
z On return from fork() in the child, the disposition of SIGINT and SIGQUIT is
SIG_IGN (i.e., the disposition inherited from the parent). However, as noted earlier,
in the child, these signals should be treated as if the caller of system() did a fork()
and an exec(). A fork() leaves the treatment of signals unchanged in the child.
An exec() resets the dispositions of handled signals to their defaults and leaves
the dispositions of other signals unchanged (Section 27.5). Therefore, if the
dispositions of SIGINT and SIGQUIT in the caller were other than SIG_IGN, then the
child resets the dispositions to SIG_DFL r.
Some implementations of system() instead reset the SIGINT and SIGQUIT dispositions to those that were in effect in the caller, relying on the fact that the subsequent execl() will automatically reset the disposition of handled signals to their
defaults. However, this could result in potentially undesirable behavior if the
caller is handling either of these signals. In this case, if a signal was delivered to
the child in the small time interval before the call to execl(), then the handler
would be invoked in the child, after the signal was unblocked by sigprocmask().
z If the execl() call in the child fails, then we use _exit() to terminate the process y,
rather than exit(), in order to prevent flushing of any unwritten data in the
child’s copy of the stdio buffers.
z In the parent, we must use waitpid() to wait specifically for the child that we
created u. If we used wait(), then we might inadvertently fetch the status of
some other child created by the calling program.
z Although the implementation of system() doesn’t require the use of a signal
handler, the calling program may have established signal handlers, and one of
these could interrupt a blocked call to waitpid(). SUSv3 explicitly requires that
the wait be restarted in this case. Therefore, we use a loop to restart waitpid() if
it fails with the error EINTR u; any other error from waitpid() causes this loop to
terminate.
Listing 27-9: Implementation of system()
–––––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/system.c
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <errno.h>
int
system(const char *command)
{
 sigset_t blockMask, origMask;
 struct sigaction saIgnore, saOrigQuit, saOrigInt, saDefault;
 pid_t childPid;
 int status, savedErrno;
q if (command == NULL) /* Is a shell available? */
 return system(":") == 0;
Program Execution 587
 sigemptyset(&blockMask); /* Block SIGCHLD */
 sigaddset(&blockMask, SIGCHLD);
w sigprocmask(SIG_BLOCK, &blockMask, &origMask);
 saIgnore.sa_handler = SIG_IGN; /* Ignore SIGINT and SIGQUIT */
 saIgnore.sa_flags = 0;
 sigemptyset(&saIgnore.sa_mask);
e sigaction(SIGINT, &saIgnore, &saOrigInt);
 sigaction(SIGQUIT, &saIgnore, &saOrigQuit);
 switch (childPid = fork()) {
 case -1: /* fork() failed */
 status = -1;
 break; /* Carry on to reset signal attributes */
 case 0: /* Child: exec command */
 saDefault.sa_handler = SIG_DFL;
 saDefault.sa_flags = 0;
 sigemptyset(&saDefault.sa_mask);
r if (saOrigInt.sa_handler != SIG_IGN)
 sigaction(SIGINT, &saDefault, NULL);
 if (saOrigQuit.sa_handler != SIG_IGN)
 sigaction(SIGQUIT, &saDefault, NULL);
t sigprocmask(SIG_SETMASK, &origMask, NULL);
 execl("/bin/sh", "sh", "-c", command, (char *) NULL);
y _exit(127); /* We could not exec the shell */
 default: /* Parent: wait for our child to terminate */
u while (waitpid(childPid, &status, 0) == -1) {
 if (errno != EINTR) { /* Error other than EINTR */
 status = -1;
 break; /* So exit loop */
 }
 }
 break;
 }
 /* Unblock SIGCHLD, restore dispositions of SIGINT and SIGQUIT */
i savedErrno = errno; /* The following may change 'errno' */
o sigprocmask(SIG_SETMASK, &origMask, NULL);
 sigaction(SIGINT, &saOrigInt, NULL);
 sigaction(SIGQUIT, &saOrigQuit, NULL);
a errno = savedErrno;
 return status;
}
–––––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/system.c
588 Chapter 27
Further details on system()
Portable applications should ensure that system() is not called with the disposition
of SIGCHLD set to SIG_IGN, because it is impossible for the waitpid() call to obtain the
status of the child in this case. (Ignoring SIGCHLD causes the status of a child process
to be immediately discarded, as described in Section 26.3.3.)
On some UNIX implementations, system() handles the case that it is called with the
disposition of SIGCHLD set to SIG_IGN by temporarily setting the disposition of SIGCHLD
to SIG_DFL. This is workable, as long as the UNIX implementation is one of those
that (unlike Linux) reaps existing zombie children when the disposition of SIGCHLD is
reset to SIG_IGN. (If the implementation doesn’t do this, then implementing system()
in this way would have the negative consequence that if another child that was
created by the caller terminated during the execution of system(), it would become a
zombie that might never be reaped.)
On some UNIX implementations (notably Solaris), /bin/sh is not a standard
POSIX shell. If we want to ensure that we exec a standard shell, then we must use
the confstr() library function to obtain the value of the _CS_PATH configuration variable.
This value is a PATH-style list of directories containing the standard system utilities.
We can assign this list to PATH, and then use execlp() to exec the standard shell as follows:
char path[PATH_MAX];
if (confstr(_CS_PATH, path, PATH_MAX) == 0)
 _exit(127);
if (setenv("PATH", path, 1) == -1)
 _exit(127);
execlp("sh", "sh", "-c", command, (char *) NULL);
_exit(127);


27.8 Summary
Using execve(), a process can replace the program that it is currently running by a
new program. Arguments to the execve() call allow the specification of the argument
list (argv) and environment list for the new program. Various similarly named
library functions are layered on top of execve() and provide different interfaces to
the same functionality.
All of the exec() functions can be used to load a binary executable file or to execute an interpreter script. When a process execs a script, the script’s interpreter
program replaces the program currently being executed by the process. The script’s
interpreter is normally identified by an initial line (starting with the characters #!) in
the script that specifies the pathname of the interpreter. If no such line is present,
then the script is executable only via execlp() or execvp(), and these functions exec the
shell as the script interpreter.
We showed how fork(), exec(), exit(), and wait() can be combined to implement
the system() function, which can be used to execute an arbitrary shell command.
Further information
Refer to the sources of further information listed in Section 24.6.
Program Execution 589











 <!-- 
FORK SYNCHRONIZATION WITH SIGNALS

  After a fork(), it is indeterminate which process—the parent or the child—next has
access to the CPU. Applications that implicitly or explicitly rely on a particular
sequence of execution in order to achieve correct results are open to failure due to
race conditions.


After a fork(), if either process needs to wait for the other to complete an action,
then the active process can send a signal after completing the action; the other process waits for the signal.


In this program, we assume that it is
the parent that must wait on the child to carry out some action. 

#include <signal.h>
#include "curr_time.h" /* Declaration of currTime() */
#include "tlpi_hdr.h"
#define SYNC_SIG SIGUSR1 /* Synchronization signal */
static void /* Signal handler - does nothing but return */
handler(int sig)
{
}
int
main(int argc, char *argv[])
{
 pid_t childPid;
 sigset_t blockMask, origMask, emptyMask;
 struct sigaction sa;
 setbuf(stdout, NULL); /* Disable buffering of stdout */
 sigemptyset(&blockMask);
 sigaddset(&blockMask, SYNC_SIG); /* Block signal */
 if (sigprocmask(SIG_BLOCK, &blockMask, &origMask) == -1)
 errExit("sigprocmask");
 sigemptyset(&sa.sa_mask);
 sa.sa_flags = SA_RESTART;
 sa.sa_handler = handler;
 if (sigaction(SYNC_SIG, &sa, NULL) == -1)
 errExit("sigaction");
 switch (childPid = fork()) {
 case -1:
 errExit("fork");
 case 0: /* Child */
 /* Child does some required action here... */
Process Creation 529
 printf("[%s %ld] Child started - doing some work\n",
 currTime("%T"), (long) getpid());
 sleep(2); /* Simulate time spent doing some work */
 /* And then signals parent that it's done */
 printf("[%s %ld] Child about to signal parent\n",
 currTime("%T"), (long) getpid());
 if (kill(getppid(), SYNC_SIG) == -1)
 errExit("kill");
 /* Now child can do other things... */
 _exit(EXIT_SUCCESS);
 default: /* Parent */
 /* Parent may do some work here, and then waits for child to
 complete the required action */
 printf("[%s %ld] Parent about to wait for signal\n",
 currTime("%T"), (long) getpid());
 sigemptyset(&emptyMask);
 if (sigsuspend(&emptyMask) == -1 && errno != EINTR)
 errExit("sigsuspend");
 printf("[%s %ld] Parent got signal\n", currTime("%T"), (long) getpid());
 /* If required, return signal mask to its original state */
 if (sigprocmask(SIG_SETMASK, &origMask, NULL) == -1)
 errExit("sigprocmask");
 /* Parent carries on to do other things... */
 exit(EXIT_SUCCESS);
 }
}
-->

<!-- 
  If the set-user-ID (set-group-ID) permission bit of the program file specified by
pathname is set, then, when the file is execed, the effective user (group) ID of the
process is changed to be the same as the owner (group) of the program file. This is
a mechanism for temporarily granting privileges to users while running a specific
program (see Section 9.3).

After optionally changing the effective IDs, and regardless of whether they
were changed, an execve() copies the value of the process’s effective user ID into its
saved set-user-ID, and copies the value of the process’s effective group ID into its saved
set-group-ID.

 -->
