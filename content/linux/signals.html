---
title: "Signals"
date: 2021-11-24
draft: false
---



<h3>Overview</h3>

<!--
- A signal is a notification to a process that an event has occurred.
- The usual source of many signals sent to a process is the kernel though a process can send a single to itself or to another process (provided it has suitable permissions).
- Each signal is defined as a unique integer. These integers are defined in <signal.h> with symbolic names of the form SIGxxxx.
- Signals fall into two broad categories: the standard signals which are used by the kernel to notify processes of events and the realtime signals.
- A signal is generated by some event after which it is delivered to a process. Between being generated and getting delivered, a signal is said to be pending.
- Normally, a pending signal is delivered to a process as soon as it is next scheduled to run or immediately if the process is already running.

- To ensure a segment of code is not interrupted by the delivery of a signal, we can add a signal to signal mask of the process. If a signal is generated while it is in the signal mask then it will remain pending until it is removed from the signal mask.

- Upon delivery of a signal, a process carries out one of the following default actions depending on the signal:
  - The signal is ignored (i.e. discarded by the kernel such that the process never even knows that it occurred.)
  - The process is terminated. This is referred to as abnormal process termination.
  - A core dump file is generated and the process is terminated. 
  - The process is stopped (i.e. execution of the process is suspended).
  - Execution of the process is resumed after previously being stopped.

- Instead of accepting the default for a particular signal, a program can change the action that occurs when the signal is delivered. This is known as setting the disposition of the signal.
- A program can set one of the following dispositions for a signal:
  - The default action should occur.
  - The signal is ignored.
  - A signal handler function is executed.
- Notifying the kernel that a handler function should be invoked is usually referred to as installing or establishing a signal handler.
- When a signal handler is invoked in response to the delivery of a signal, we say that the signal has been handled or caught.
-->


<h3>Signal Types and Default Actions</h3>

<!-- 
The standard signals are numbered from 1 to 31. Some of these are:

SIGABRT: A process is sent this signal when it calls the abort() function. By default, this terminates the process with a core dump.

SIGALRM: The kernel generates this signal upon the expiration of a real-time timer set by a call to alarm() or setitimer().

SIGBUS: This signal is generated to indicate certain kinds of memory access errors.

SIGCHLD: This signal is sent by the kernel to a parent process when one of its children terminates (either by calling exit() or as a result of being killed by a signal). It may also be sent to a process when one of its children is stopped or resumed by a signal.

SIGCONT: When sent to a stopped process, this signal causes the process to resume. When received by a process that is not currently stopped, this signal is ignored by default.

SIGFPE: This signal is generated for certain types of arithmetic errors, such as divide-by-zero.

SIGINT: When the user types the terminal interrupt character (usually Control-C), the terminal driver sends this signal to the foreground process group. The default action for this signal is to terminate the process.

SIGIO: Using the fcntl() system call, it is possible to arrange for this signal to be generated when an I/O event occurs on certain types of open file descriptors.

SIGKILL: This is the sure kill signal. It cannot be blocked, ignored, or caught by a handler and thus always terminates a process.

SIGPIPE: This signal is generated when a process tries to write to a pipe, a FIFO, or a socket for which there is no corresponding reader process. This normally occurs because the reading process has closed its file descriptor for the IPC channel. 

SIGQUIT: When the user types the quit character (usually Control-\) on the keyboard, this signal is sent to the foreground process group. By default, this signal terminates a process and causes it to produce a core dump.

SIGSEGV: This signal is generated when a program makes an invalid memory reference. A memory reference may be invalid because the referenced page does not exist, the process tried to update a location in read-only memory or the process tried to access a part of kernel memory while running in user mode.

SIGSTOP: This is the sure stop signal. It cannot be blocked, ignored, or caught by a handler; thus, it always stops a process.

SIGTERM: This is the standard signal used for terminating a process. A well-designed application will have a handler for SIGTERM that causes the application to exit gracefully.

SIGTSTP: This is the job-control stop signal, sent to stop the foreground process group when the user types the suspend character (usually Control-Z) on the keyboard.

SIGURG: This signal is sent to a process to indicate the presence of out-of-band (also known as urgent) data on a socket.

SIGUSR1: This signal and SIGUSR2 are available for programmer-defined purposes. The kernel never generates these signals for a process.

SIGXCPU: This signal is sent to a process when it exceeds its CPU time resource limit. -->


<h3>Changing Signal Dispositions</h3>

<!--
- There are two ways of changing the disposition of a signal: signal() and sigaction(). The signal() system call is the original API for setting the disposition of a signal while sigaction() provides additional functionality,
- There are variations in the behavior of signal() across UNIX implementations which mean that it should never be used for establishing signal handlers in portable programs.
-->

<!--
#include <signal.h>
void (*signal(int sig, void (*handler)(int))) (int);

- The sig argument identifies the signal whose disposition we wish to change. The handler argument is the address of the function that should be called when this signal is delivered.
- The return value of signal() is the previous disposition of the signal. Like the handler argument, this is a pointer to a function returning nothing and taking one integer argument.
- Instead of specifying the address of a function as the handler argument of signal(), we can specify one of the following values:
  - SIG_DFL: Reset the disposition of the signal to its default.
  - SIG_IGN: Ignore the signal. If the signal is generated for this process, the kernel silently discards it. The process never even knows that the signal occurred.
- A successful call to signal() returns the previous disposition of the signal or SIG_ERR on error.

void (*oldHandler)(int);
oldHandler = signal(SIGINT, newHandler);
if (oldHandler == SIG_ERR)
 errExit("signal");

 // ...

if (signal(SIGINT, oldHandler) == SIG_ERR)
 errExit("signal");
-->


<h3>Signal Handlers</h3>

- A signal handler is a function that is called when a specified signal is delivered to a process.
- Invocation of a signal handler may interrupt the main program flow at any time. The kernel calls the handler on behalf of the process and execution of the program resumes at the point where the handler interrupted it when the handler returns.
- Although signal handlers can do virtually anything, they should, in general, be designed to be as simple as possible.
- When the kernel invokes a signal handler, it passes the number of the signal that caused the invocation as an integer argument to the handler.



<h3>Sending Signals</h3>

- A process can send a signal to another process using the kill() system call.
- The pid argument identifies one or more processes to which the signal specified by sig is to be sent.

Four different cases determine how pid is interpreted:
z If pid is greater than 0, the signal is sent to the process with the process ID specified by pid.
z If pid equals 0, the signal is sent to every process in the same process group as
the calling process, including the calling process itself. (SUSv3 states that the
signal should be sent to all processes in the same process group, excluding an
“unspecified set of system processes” and adds the same qualification to each
of the remaining cases.)
z If pid is less than –1, the signal is sent to all of the processes in the process group
whose ID equals the absolute value of pid. Sending a signal to all of the processes
in a process group finds particular use in shell job control (Section 34.7).
z If pid equals –1, the signal is sent to every process for which the calling process
has permission to send a signal, except init (process ID 1) and the calling process. If a privileged process makes this call, then all processes on the system will
be signaled, except for these last two. For obvious reasons, signals sent in this
way are sometimes called broadcast signals. (SUSv3 doesn’t require that the calling process be excluded from receiving the signal; Linux follows the BSD
semantics in this regard.)
If no process matches the specified pid, kill() fails and sets errno to ESRCH (“No such
process”).
A process needs appropriate permissions to be able send a signal to another
process. The permission rules are as follows:
z A privileged (CAP_KILL) process may send a signal to any process.
z The init process (process ID 1), which runs with user and group of root, is a
special case. It can be sent only signals for which it has a handler installed. This
prevents the system administrator from accidentally killing init, which is fundamental to the operation of the system.
z An unprivileged process can send a signal to another process if the real or
effective user ID of the sending process matches the real user ID or saved setuser-ID of the receiving process, as shown in Figure 20-2. This rule allows users
to send signals to set-user-ID programs that they have started, regardless of the
current setting of the target process’s effective user ID. Excluding the effective
user ID of the target from the check serves a complementary purpose: it prevents
one user from sending signals to another user’s process that is running a setuser-ID program belonging to the user trying to send the signal. (SUSv3 mandates
the rules shown in Figure 20-2, but Linux followed slightly different rules in
kernel versions before 2.0, as described in the kill(2) manual page.)
#include <signal.h>
int kill(pid_t pid, int sig);
Returns 0 on success, or –1 on error
Signals: Fundamental Concepts 403
z The SIGCONT signal is treated specially. An unprivileged process may send this
signal to any other process in the same session, regardless of user ID checks.
This rule allows job-control shells to restart stopped jobs (process groups),
even if the processes of the job have changed their user IDs (i.e., they are privileged processes that have used the system calls described in Section 9.7 to
change their credentials).
Figure 20-2: Permissions required for an unprivileged process to send a signal
If a process doesn’t have permissions to send a signal to the requested pid, then
kill() fails, setting errno to EPERM. Where pid specifies a set of processes (i.e., pid is
negative), kill() succeeds if at least one of them could be signaled.
We demonstrate the use of kill() in Listing 20-3.


20.6 Checking for the Existence of a Process
The kill() system call can serve another purpose. If the sig argument is specified as 0
(the so-called null signal), then no signal is sent. Instead, kill() merely performs
error checking to see if the process can be signaled. Read another way, this means
we can use the null signal to test if a process with a specific process ID exists. If
sending a null signal fails with the error ESRCH, then we know the process doesn’t
exist. If the call fails with the error EPERM (meaning the process exists, but we don’t
have permission to send a signal to it) or succeeds (meaning we do have permission
to send a signal to the process), then we know that the process exists.
Verifying the existence of a particular process ID doesn’t guarantee that a particular program is still running. Because the kernel recycles process IDs as processes are born and die, the same process ID may, over time, refer to a different
process. Furthermore, a particular process ID may exist, but be a zombie (i.e., a
process that has died, but whose parent has not yet performed a wait() to obtain its
termination status, as described in Section 26.2).
Various other techniques can also be used to check whether a particular process is running, including the following:
z The wait() system calls: These calls are described in Chapter 26. They can be
employed only if the monitored process is a child of the caller.
z Semaphores and exclusive file locks: If the process that is being monitored continuously holds a semaphore or a file lock, then, if we can acquire the semaphore
or lock, we know the process has terminated. We describe semaphores in
Chapters 47 and 53 and file locks in Chapter 55.
Receiving process
real user ID
Sending process
saved set-user-ID
effective user ID
real user ID
saved set-user-ID
effective user ID
indicates that if IDs match,
then sender has permission
to send a signal to receiver
404 Chapter 20
z IPC channels such as pipes and FIFOs: We set up the monitored process so that it
holds a file descriptor open for writing on the channel as long as it is alive.
Meanwhile, the monitoring process holds open a read descriptor for the channel, and it knows that the monitored process has terminated when the write
end of the channel is closed (because it sees end-of-file). The monitoring process can determine this either by reading from its file descriptor or by monitoring the descriptor using one of the techniques described in Chapter 63.
z The /proc/PID interface: For example, if a process with the process ID 12345
exists, then the directory /proc/12345 will exist, and we can check this using a
call such as stat().
All of these techniques, except the last, are unaffected by recycling of process IDs.
Listing 20-3 demonstrates the use of kill(). This program takes two commandline arguments, a signal number and a process ID, and uses kill() to send the signal
to the specified process. If signal 0 (the null signal) is specified, then the program
reports on the existence of the target process.
20.7 Other Ways of Sending Signals: raise() and killpg()
Sometimes, it is useful for a process to send a signal to itself. (We see an example of
this in Section 34.7.3.) The raise() function performs this task.
In a single-threaded program, a call to raise() is equivalent to the following call to kill():
kill(getpid(), sig);
On a system that supports threads, raise(sig) is implemented as:
pthread_kill(pthread_self(), sig)
We describe the pthread_kill() function in Section 33.2.3, but for now it is sufficient
to say that this implementation means that the signal will be delivered to the specific
thread that called raise(). By contrast, the call kill(getpid(), sig) sends a signal to the
calling process, and that signal may be delivered to any thread in the process.
The raise() function originates from C89. The C standards don’t cover operating
system details such as process IDs, but raise() can be specified within the C
standard because it doesn’t require reference to process IDs.
When a process sends itself a signal using raise() (or kill()), the signal is delivered
immediately (i.e., before raise() returns to the caller).
Note that raise() returns a nonzero value (not necessarily –1) on error. The only
error that can occur with raise() is EINVAL, because sig was invalid. Therefore, where
we specify one of the SIGxxxx constants, we don’t check the return status of this
function.
#include <signal.h>
int raise(int sig);
Returns 0 on success, or nonzero on error
Signals: Fundamental Concepts 405
Listing 20-3: Using the kill() system call
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––signals/t_kill.c
#include <signal.h>
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 int s, sig;
 if (argc != 3 || strcmp(argv[1], "--help") == 0)
 usageErr("%s sig-num pid\n", argv[0]);
 sig = getInt(argv[2], 0, "sig-num");
 s = kill(getLong(argv[1], 0, "pid"), sig);
 if (sig != 0) {
 if (s == -1)
 errExit("kill");
 } else { /* Null signal: process existence check */
 if (s == 0) {
 printf("Process exists and we can send it a signal\n");
 } else {
 if (errno == EPERM)
 printf("Process exists, but we don't have "
 "permission to send it a signal\n");
 else if (errno == ESRCH)
 printf("Process does not exist\n");
 else
 errExit("kill");
 }
 }
 exit(EXIT_SUCCESS);
}
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––signals/t_kill.c
The killpg() function sends a signal to all of the members of a process group.
A call to killpg() is equivalent to the following call to kill():
kill(-pgrp, sig);
If pgrp is specified as 0, then the signal is sent to all processes in the same process
group as the caller. SUSv3 leaves this point unspecified, but most UNIX implementations interpret this case in the same way as Linux.
#include <signal.h>
int killpg(pid_t pgrp, int sig);
Returns 0 on success, or –1 on error



20.8 Displaying Signal Descriptions

Each signal has an associated printable description. These descriptions are listed in
the array sys_siglist. For example, we can refer to sys_siglist[SIGPIPE] to get the
description for SIGPIPE (broken pipe). However, rather than using the sys_siglist
array directly, the strsignal() function is preferable.

The strsignal() function performs bounds checking on the sig argument, and then
returns a pointer to a printable description of the signal, or a pointer to an error
string if the signal number was invalid. (On some other UNIX implementations,
strsignal() returns NULL if sig is invalid.)
Aside from bounds checking, another advantage of strsignal() over the direct
use of sys_siglist is that strsignal() is locale-sensitive (Section 10.4), so that signal
descriptions will be displayed in the local language.
An example of the use of strsignal() is shown in Listing 20-4.
The psignal() function displays (on standard error) the string given in its argument msg, followed by a colon, and then the signal description corresponding to
sig. Like strsignal(), psignal() is locale-sensitive.
Although psignal(), strsignal(), and sys_siglist are not standardized as part of SUSv3,
they are nevertheless available on many UNIX implementations. (SUSv4 adds specifications for psignal() and strsignal().)
20.9 Signal Sets
Many signal-related system calls need to be able to represent a group of different signals. For example, sigaction() and sigprocmask() allow a program to specify a group of
signals that are to be blocked by a process, while sigpending() returns a group of signals that are currently pending for a process. (We describe these system calls shortly.)
#define _BSD_SOURCE
#include <signal.h>
extern const char *const sys_siglist[];
#define _GNU_SOURCE
#include <string.h>
char *strsignal(int sig);
Returns pointer to signal description string
#include <signal.h>
void psignal(int sig, const char *msg);
Signals: Fundamental Concepts 407
Multiple signals are represented using a data structure called a signal set, provided by the system data type sigset_t. SUSv3 specifies a range of functions for
manipulating signal sets, and we now describe these functions.
On Linux, as on most UNIX implementations, the sigset_t data type is a bit
mask. However, SUSv3 doesn’t require this. A signal set could conceivably be
represented using some other kind of structure. SUSv3 requires only that the
type of sigset_t be assignable. Thus, it must be implemented using either some
scalar type (e.g., an integer) or a C structure (perhaps containing an array of
integers).
The sigemptyset() function initializes a signal set to contain no members. The
sigfillset() function initializes a set to contain all signals (including all realtime signals).
One of sigemptyset() or sigaddset() must be used to initialize a signal set. This is
because C doesn’t initialize automatic variables, and the initialization of static variables to 0 can’t portably be relied upon as indicating an empty signal set, since signal
sets may be implemented using structures other than bit masks. (For the same
reason, it is incorrect to use memset(3) to zero the contents of a signal set in order to
mark it as empty.)
After initialization, individual signals can be added to a set using sigaddset() and
removed using sigdelset().
For both sigaddset() and sigdelset(), the sig argument is a signal number.
The sigismember() function is used to test for membership of a set.
The sigismember() function returns 1 (true) if sig is a member of set, and 0 (false)
otherwise.
#include <signal.h>
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
Both return 0 on success, or –1 on error
#include <signal.h>
int sigaddset(sigset_t *set, int sig);
int sigdelset(sigset_t *set, int sig);
Both return 0 on success, or –1 on error
#include <signal.h>
int sigismember(const sigset_t *set, int sig);
Returns 1 if sig is a member of set, otherwise 0
408 Chapter 20
The GNU C library implements three nonstandard functions that perform
tasks that are complementary to the standard signal set functions just described.
These functions perform the following tasks:
z sigandset() places the intersection of the sets left and right in the set dest;
z sigorset() places the union of the sets left and right in the set dest; and
z sigisemptyset() returns true if set contains no signals.
Example program
Using the functions described in this section, we can write the functions shown in
Listing 20-4, which we employ in various later programs. The first of these, printSigset(),
displays the signals that are members of the specified signal set. This function uses
the NSIG constant, which is defined in <signal.h> to be one greater than the highest
signal number. We use NSIG as the upper bound in a loop that tests all signal numbers
for membership of a set.
Although NSIG is not specified in SUSv3, it is defined on most UNIX implementations. However, it may be necessary to use implementation-specific compiler
options to make it visible. For example, on Linux, we must define one of the
feature test macros _BSD_SOURCE, _SVID_SOURCE, or _GNU_SOURCE.
The printSigMask() and printPendingSigs() functions employ printSigset() to display,
respectively, the process signal mask and the set of currently pending signals. The
printSigMask() and printPendingSigs() functions use the sigprocmask() and sigpending()
system calls, respectively. We describe the sigprocmask() and sigpending() system calls
in Sections 20.10 and 20.11.
Listing 20-4: Functions for displaying signal sets
––––––––––––––––––––––––––––––––––––––––––––––––– signals/signal_functions.c
#define _GNU_SOURCE
#include <string.h>
#include <signal.h>
#include "signal_functions.h" /* Declares functions defined here */
#include "tlpi_hdr.h"
/* NOTE: All of the following functions employ fprintf(), which
 is not async-signal-safe (see Section 21.1.2). As such, these
#define _GNU_SOURCE
#include <signal.h>
int sigandset(sigset_t *set, sigset_t *left, sigset_t *right);
int sigorset(sigset_t *dest, sigset_t *left, sigset_t *right);
Both return 0 on success, or –1 on error
int sigisemptyset(const sigset_t *set);
Returns 1 if sig is empty, otherwise 0
Signals: Fundamental Concepts 409
 functions are also not async-signal-safe (i.e., beware of
 indiscriminately calling them from signal handlers). */
void /* Print list of signals within a signal set */
printSigset(FILE *of, const char *prefix, const sigset_t *sigset)
{
 int sig, cnt;
 cnt = 0;
 for (sig = 1; sig < NSIG; sig++) {
 if (sigismember(sigset, sig)) {
 cnt++;
 fprintf(of, "%s%d (%s)\n", prefix, sig, strsignal(sig));
 }
 }
 if (cnt == 0)
 fprintf(of, "%s<empty signal set>\n", prefix);
}
int /* Print mask of blocked signals for this process */
printSigMask(FILE *of, const char *msg)
{
 sigset_t currMask;
 if (msg != NULL)
 fprintf(of, "%s", msg);
 if (sigprocmask(SIG_BLOCK, NULL, &currMask) == -1)
 return -1;
 printSigset(of, "\t\t", &currMask);
 return 0;
}
int /* Print signals currently pending for this process */
printPendingSigs(FILE *of, const char *msg)
{
 sigset_t pendingSigs;
 if (msg != NULL)
 fprintf(of, "%s", msg);
 if (sigpending(&pendingSigs) == -1)
 return -1;
 printSigset(of, "\t\t", &pendingSigs);
 return 0;
}
––––––––––––––––––––––––––––––––––––––––––––––––– signals/signal_functions.c
410 Chapter 20
20.10 The Signal Mask (Blocking Signal Delivery)
For each process, the kernel maintains a signal mask—a set of signals whose delivery
to the process is currently blocked. If a signal that is blocked is sent to a process,
delivery of that signal is delayed until it is unblocked by being removed from the
process signal mask. (In Section 33.2.1, we’ll see that the signal mask is actually a
per-thread attribute, and that each thread in a multithreaded process can independently examine and modify its signal mask using the pthread_sigmask() function.)
A signal may be added to the signal mask in the following ways:
z When a signal handler is invoked, the signal that caused its invocation can be
automatically added to the signal mask. Whether or not this occurs depends on
the flags used when the handler is established using sigaction().
z When a signal handler is established with sigaction(), it is possible to specify an
additional set of signals that are to be blocked when the handler is invoked.
z The sigprocmask() system call can be used at any time to explicitly add signals to,
and remove signals from, the signal mask.
We delay discussion of the first two cases until we examine sigaction() in Section 20.13,
and discuss sigprocmask() now.
We can use sigprocmask() to change the process signal mask, to retrieve the existing
mask, or both. The how argument determines the changes that sigprocmask() makes
to the signal mask:
SIG_BLOCK
The signals specified in the signal set pointed to by set are added to the signal mask. In other words, the signal mask is set to the union of its current
value and set.
SIG_UNBLOCK
The signals in the signal set pointed to by set are removed from the signal
mask. Unblocking a signal that is not currently blocked doesn’t cause an
error to be returned.
SIG_SETMASK
The signal set pointed to by set is assigned to the signal mask.
In each case, if the oldset argument is not NULL, it points to a sigset_t buffer that is
used to return the previous signal mask.
If we want to retrieve the signal mask without changing it, then we can specify
NULL for the set argument, in which case the how argument is ignored.
#include <signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
Returns 0 on success, or –1 on error
Signals: Fundamental Concepts 411
To temporarily prevent delivery of a signal, we can use the series of calls shown
in Listing 20-5 to block the signal, and then unblock it by resetting the signal mask
to its previous state.
Listing 20-5: Temporarily blocking delivery of a signal
 sigset_t blockSet, prevMask;
 /* Initialize a signal set to contain SIGINT */
 sigemptyset(&blockSet);
 sigaddset(&blockSet, SIGINT);
 /* Block SIGINT, save previous signal mask */
 if (sigprocmask(SIG_BLOCK, &blockSet, &prevMask) == -1)
 errExit("sigprocmask1");
 /* ... Code that should not be interrupted by SIGINT ... */
 /* Restore previous signal mask, unblocking SIGINT */
 if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)
 errExit("sigprocmask2");
SUSv3 specifies that if any pending signals are unblocked by a call to sigprocmask(),
then at least one of those signals will be delivered before the call returns. In other
words, if we unblock a pending signal, it is delivered to the process immediately.
Attempts to block SIGKILL and SIGSTOP are silently ignored. If we attempt to block
these signals, sigprocmask() neither honors the request nor generates an error. This
means that we can use the following code to block all signals except SIGKILL and SIGSTOP:
sigfillset(&blockSet);
if (sigprocmask(SIG_BLOCK, &blockSet, NULL) == -1)
 errExit("sigprocmask");
20.11 Pending Signals
If a process receives a signal that it is currently blocking, that signal is added to the
process’s set of pending signals. When (and if) the signal is later unblocked, it is
then delivered to the process. To determine which signals are pending for a process, we can call sigpending().
#include <signal.h>
int sigpending(sigset_t *set);
Returns 0 on success, or –1 on error
412 Chapter 20
The sigpending() system call returns the set of signals that are pending for the calling process in the sigset_t structure pointed to by set. We can then examine set using
the sigismember() function described in Section 20.9.
If we change the disposition of a pending signal, then, when the signal is later
unblocked, it is handled according to its new disposition. Although not often used,
one application of this technique is to prevent the delivery of a pending signal by
setting its disposition to SIG_IGN, or to SIG_DFL if the default action for the signal is
ignore. As a result, the signal is removed from the process’s set of pending signals
and thus not delivered.
20.12 Signals Are Not Queued
The set of pending signals is only a mask; it indicates whether or not a signal has
occurred, but not how many times it has occurred. In other words, if the same signal is generated multiple times while it is blocked, then it is recorded in the set of
pending signals, and later delivered, just once. (One of the differences between
standard and realtime signals is that realtime signals are queued, as discussed in
Section 22.8.)
Listing 20-6 and Listing 20-7 show two programs that can be used to observe that
signals are not queued. The program in Listing 20-6 takes up to four command-line
arguments, as follows:
$ ./sig_sender PID num-sigs sig-num [sig-num-2]
The first argument is the process ID of a process to which the program should send
signals. The second argument specifies the number of signals to be sent to the target process. The third argument specifies the signal number that is to be sent to
the target process. If a signal number is supplied as the fourth argument, then the
program sends one instance of that signal after sending the signals specified by the
previous arguments. In the example shell session below, we use this final argument
to send a SIGINT signal to the target process; the purpose of sending this signal will
become clear in a moment.
Listing 20-6: Sending multiple signals
–––––––––––––––––––––––––––––––––––––––––––––––––––––– signals/sig_sender.c
#include <signal.h>
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 int numSigs, sig, j;
 pid_t pid;
 if (argc < 4 || strcmp(argv[1], "--help") == 0)
 usageErr("%s pid num-sigs sig-num [sig-num-2]\n", argv[0]);
Signals: Fundamental Concepts 413
 pid = getLong(argv[1], 0, "PID");
 numSigs = getInt(argv[2], GN_GT_0, "num-sigs");
 sig = getInt(argv[3], 0, "sig-num");
 /* Send signals to receiver */
 printf("%s: sending signal %d to process %ld %d times\n",
 argv[0], sig, (long) pid, numSigs);
 for (j = 0; j < numSigs; j++)
 if (kill(pid, sig) == -1)
 errExit("kill");
 /* If a fourth command-line argument was specified, send that signal */
 if (argc > 4)
 if (kill(pid, getInt(argv[4], 0, "sig-num-2")) == -1)
 errExit("kill");
 printf("%s: exiting\n", argv[0]);
 exit(EXIT_SUCCESS);
}
–––––––––––––––––––––––––––––––––––––––––––––––––––––– signals/sig_sender.c
The program shown in Listing 20-7 is designed to catch and report statistics on signals sent by the program in Listing 20-6. This program performs the following steps:
z The program sets up a single handler to catch all signals w. (It isn’t possible to
catch SIGKILL and SIGSTOP, but we ignore the error that occurs when trying to
establish a handler for these signals.) For most types of signals, the handler q
simply counts the signal using an array. If SIGINT is received, the handler sets a
flag (gotSigint) that causes the program to exit its main loop (the while loop
described below). (We explain the use of the volatile qualifier and the
sig_atomic_t data type used to declare the gotSigint variable in Section 21.1.3.)
z If a command-line argument was supplied to the program, then the program
blocks all signals for the number of seconds specified by that argument, and
then, prior to unblocking the signals, displays the set of pending signals e. This
allows us to send signals to the process before it commences the following step.
z The program executes a while loop that consumes CPU time until gotSigint is
set r. (Sections 20.14 and 22.9 describe the use of pause() and sigsuspend(),
which are more CPU-efficient ways of waiting for the arrival of a signal.)
z After exiting the while loop, the program displays counts of all signals received t.
We first use these two programs to illustrate that a blocked signal is delivered only
once, no matter how many times it is generated. We do this by specifying a sleep
interval for the receiver and sending all signals before the sleep interval completes.
$ ./sig_receiver 15 & Receiver blocks signals for 15 secs
[1] 5368
./sig_receiver: PID is 5368
./sig_receiver: sleeping for 15 seconds
414 Chapter 20
$ ./sig_sender 5368 1000000 10 2 Send SIGUSR1 signals, plus a SIGINT
./sig_sender: sending signal 10 to process 5368 1000000 times
./sig_sender: exiting
./sig_receiver: pending signals are:
 2 (Interrupt)
 10 (User defined signal 1)
./sig_receiver: signal 10 caught 1 time
[1]+ Done ./sig_receiver 15
The command-line arguments to the sending program specified the SIGUSR1 and
SIGINT signals, which are signals 10 and 2, respectively, on Linux/x86.
From the output above, we can see that even though one million signals were
sent, only one was delivered to the receiver.
Even if a process doesn’t block signals, it may receive fewer signals than are
sent to it. This can happen if the signals are sent so fast that they arrive before the
receiving process has a chance to be scheduled for execution by the kernel, with
the result that the multiple signals are recorded just once in the process’s pending
signal set. If we execute the program in Listing 20-7 with no command-line arguments (so that it doesn’t block signals and sleep), we see the following:
$ ./sig_receiver &
[1] 5393
./sig_receiver: PID is 5393
$ ./sig_sender 5393 1000000 10 2
./sig_sender: sending signal 10 to process 5393 1000000 times
./sig_sender: exiting
./sig_receiver: signal 10 caught 52 times
[1]+ Done ./sig_receiver
Of the million signals sent, just 52 were caught by the receiving process. (The precise number of signals caught will vary depending on the vagaries of decisions
made by the kernel scheduling algorithm.) The reason for this is that each time the
sending program is scheduled to run, it sends multiple signals to the receiver. However, only one of these signals is marked as pending and then delivered when the
receiver has a chance to run.
Listing 20-7: Catching and counting signals
––––––––––––––––––––––––––––––––––––––––––––––––––––– signals/sig_receiver.c
#define _GNU_SOURCE
#include <signal.h>
#include "signal_functions.h" /* Declaration of printSigset() */
#include "tlpi_hdr.h"
static int sigCnt[NSIG]; /* Counts deliveries of each signal */
static volatile sig_atomic_t gotSigint = 0;
 /* Set nonzero if SIGINT is delivered */
static void
q handler(int sig)
{
Signals: Fundamental Concepts 415
 if (sig == SIGINT)
 gotSigint = 1;
 else
 sigCnt[sig]++;
}
int
main(int argc, char *argv[])
{
 int n, numSecs;
 sigset_t pendingMask, blockingMask, emptyMask;
 printf("%s: PID is %ld\n", argv[0], (long) getpid());
w for (n = 1; n < NSIG; n++) /* Same handler for all signals */
 (void) signal(n, handler); /* Ignore errors */
 /* If a sleep time was specified, temporarily block all signals,
 sleep (while another process sends us signals), and then
 display the mask of pending signals and unblock all signals */
e if (argc > 1) {
 numSecs = getInt(argv[1], GN_GT_0, NULL);
 sigfillset(&blockingMask);
 if (sigprocmask(SIG_SETMASK, &blockingMask, NULL) == -1)
 errExit("sigprocmask");
 printf("%s: sleeping for %d seconds\n", argv[0], numSecs);
 sleep(numSecs);
 if (sigpending(&pendingMask) == -1)
 errExit("sigpending");
 printf("%s: pending signals are: \n", argv[0]);
 printSigset(stdout, "\t\t", &pendingMask);
 sigemptyset(&emptyMask); /* Unblock all signals */
 if (sigprocmask(SIG_SETMASK, &emptyMask, NULL) == -1)
 errExit("sigprocmask");
 }
r while (!gotSigint) /* Loop until SIGINT caught */
 continue;
t for (n = 1; n < NSIG; n++) /* Display number of signals received */
 if (sigCnt[n] != 0)
 printf("%s: signal %d caught %d time%s\n", argv[0], n,
 sigCnt[n], (sigCnt[n] == 1) ? "" : "s");
 exit(EXIT_SUCCESS);
}
–––––––––––––––––––––––––––––––––––––––––––––––––––– signals/sig_receiver.c
416 Chapter 20




<h3>Changing Signal Dispositions</h3>

The sigaction() system call is an alternative to signal() for setting the disposition of a
signal.
Although sigaction() is somewhat more complex to use than signal(), in
return it provides greater flexibility. In particular, sigaction() allows us to retrieve
the disposition of a signal without changing it, and to set various attributes controlling precisely what happens when a signal handler is invoked.

Additionally, sigaction() is more portable than signal() when establishing a signal handler.

The sig argument identifies the signal whose disposition we want to retrieve or
change. This argument can be any signal except SIGKILL or SIGSTOP.

The act argument is a pointer to a structure specifying a new disposition for the
signal. If we are interested only in finding the existing disposition of the signal,
then we can specify NULL for this argument. The oldact argument is a pointer to a
structure of the same type, and is used to return information about the signal’s previous disposition. If we are not interested in this information, then we can specify
NULL for this argument. The structures pointed to by act and oldact are of the following type:
struct sigaction {
 void (*sa_handler)(int); /* Address of handler */
 sigset_t sa_mask; /* Signals blocked during handler
 invocation */
 int sa_flags; /* Flags controlling handler invocation */
 void (*sa_restorer)(void); /* Not for application use */
};
The sigaction structure is actually somewhat more complex than shown here.
We consider further details in Section 21.4.
The sa_handler field corresponds to the handler argument given to signal(). It specifies the address of a signal handler, or one of the constants SIG_IGN or SIG_DFL. The
sa_mask and sa_flags fields, which we discuss in a moment, are interpreted only if
sa_handler is the address of a signal handler—that is, a value other than SIG_IGN or
SIG_DFL. The remaining field, sa_restorer, is not intended for use in applications (and
is not specified by SUSv3).
The sa_restorer field is used internally to ensure that on completion of a signal
handler, a call is made to the special-purpose sigreturn() system call, which
restores the process’s execution context so that it can continue execution at
the point where it was interrupted by the signal handler. An example of this
usage can be found in the glibc source file sysdeps/unix/sysv/linux/i386/
sigaction.c.
#include <signal.h>
int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);
Returns 0 on success, or –1 on error
Signals: Fundamental Concepts 417
The sa_mask field defines a set of signals that are to be blocked during invocation of
the handler defined by sa_handler. When the signal handler is invoked, any signals in
this set that are not currently part of the process signal mask are automatically
added to the mask before the handler is called. These signals remain in the process
signal mask until the signal handler returns, at which time they are automatically
removed. The sa_mask field allows us to specify a set of signals that aren’t permitted
to interrupt execution of this handler. In addition, the signal that caused the handler to be invoked is automatically added to the process signal mask. This means
that a signal handler won’t recursively interrupt itself if a second instance of the
same signal arrives while the handler is executing. Because blocked signals are not
queued, if any of these signals are repeatedly generated during the execution of the
handler, they are (later) delivered only once.
The sa_flags field is a bit mask specifying various options controlling how the
signal is handled. The following bits may be ORed (|) together in this field:
SA_NOCLDSTOP
If sig is SIGCHLD, don’t generate this signal when a child process is stopped or
resumed as a consequence of receiving a signal. Refer to Section 26.3.2.
SA_NOCLDWAIT
(since Linux 2.6) If sig is SIGCHLD, don’t transform children into zombies
when they terminate. For further details, see Section 26.3.3.
SA_NODEFER
When this signal is caught, don’t automatically add it to the process signal
mask while the handler is executing. The name SA_NOMASK is provided as a
historical synonym for SA_NODEFER, but the latter name is preferable because
it is standardized in SUSv3.
SA_ONSTACK
Invoke the handler for this signal using an alternate stack installed by
sigaltstack(). Refer to Section 21.3.
SA_RESETHAND
When this signal is caught, reset its disposition to the default (i.e., SIG_DFL)
before invoking the handler. (By default, a signal handler remains established until it is explicitly disestablished by a further call to sigaction().) The
name SA_ONESHOT is provided as a historical synonym for SA_RESETHAND, but
the latter name is preferable because it is standardized in SUSv3.
SA_RESTART
Automatically restart system calls interrupted by this signal handler. See
Section 21.5.
SA_SIGINFO
Invoke the signal handler with additional arguments providing further
information about the signal. We describe this flag in Section 21.4.
All of the above options are specified in SUSv3.
An example of the use of sigaction() is shown in Listing 21-1.
418 Chapter 20
20.14 Waiting for a Signal: pause()
Calling pause() suspends execution of the process until the call is interrupted by a
signal handler (or until an unhandled signal terminates the process).
When a signal is handled, pause() is interrupted and always returns –1 with errno set
to EINTR. (We say more about the EINTR error in Section 21.5.)
An example of the use of pause() is provided in Listing 20-2.
In Sections 22.9, 22.10, and 22.11, we look at various other ways that a program can suspend execution while waiting for a signal.
20.15 Summary
A signal is a notification that some kind of event has occurred, and may be sent to a
process by the kernel, by another process, or by itself. There is a range of standard
signal types, each of which has a unique number and purpose.
Signal delivery is typically asynchronous, meaning that the point at which the
signal interrupts execution of the process is unpredictable. In some cases (e.g.,
hardware-generated signals), signals are delivered synchronously, meaning that
delivery occurs predictably and reproducibly at a certain point in the execution of a
program.
By default, a signal either is ignored, terminates a process (with or without a
core dump), stops a running process, or restarts a stopped process. The particular
default action depends on the signal type. Alternatively, a program can use signal()
or sigaction() to explicitly ignore a signal or to establish a programmer-defined signal
handler function that is invoked when the signal is delivered. For portability reasons,
establishing a signal handler is best performed using sigaction().
A process (with suitable permissions) can send a signal to another process
using kill(). Sending the null signal (0) is a way of determining if a particular process ID is in use.
Each process has a signal mask, which is the set of signals whose delivery is currently blocked. Signals can be added to and removed from the signal mask using
sigprocmask().
If a signal is received while it is blocked, then it remains pending until it is
unblocked. Standard signals can’t be queued; that is, a signal can be marked as
pending (and thus later delivered) only once. A process can use the sigpending() system call to retrieve a signal set (a data structure used to represent multiple different
signals) identifying the signals that it has pending.
The sigaction() system call provides more control and flexibility than signal()
when setting the disposition of a signal. First, we can specify a set of additional signals to be blocked when a handler is invoked. In addition, various flags can be used
to control the actions that occur when a signal handler is invoked. For example,
there are flags that select the older unreliable signal semantics (not blocking the
signal causing invocation of a handler, and having the disposition of the signal
reset to its default before the handler is called).
Using pause(), a process can suspend execution until a signal arrives.







SIGNALS: SIGNAL HANDLERS
This chapter continues the description of signals begun in the previous chapter. It
focuses on signal handlers, and extends the discussion started in Section 20.4.
Among the topics we consider are the following:
z how to design a signal handler, which necessitates a discussion of reentrancy
and async-signal-safe functions;
z alternatives to performing a normal return from a signal handler, in particular,
the use of a nonlocal goto for this purpose;
z handling of signals on an alternate stack;
z the use of the sigaction() SA_SIGINFO flag to allow a signal handler to obtain more
detailed information about the signal that caused its invocation; and
z how a blocking system call may be interrupted by a signal handler, and how the
call can be restarted if desired.
422 Chapter 21
21.1 Designing Signal Handlers
In general, it is preferable to write simple signal handlers. One important reason
for this is to reduce the risk of creating race conditions. Two common designs for
signal handlers are the following:
z The signal handler sets a global flag and exits. The main program periodically
checks this flag and, if it is set, takes appropriate action. (If the main program
cannot perform such periodic checks because it needs to monitor one or more
file descriptors to see if I/O is possible, then the signal handler can also write a
single byte to a dedicated pipe whose read end is included among the file
descriptors monitored by the main program. We show an example of this technique in Section 63.5.2.)
z The signal handler performs some type of cleanup and then either terminates
the process or uses a nonlocal goto (Section 21.2.1) to unwind the stack and
return control to a predetermined location in the main program.
In the following sections, we explore these ideas, as well as other concepts that are
important in the design of signal handlers.
21.1.1 Signals Are Not Queued (Revisited)
In Section 20.10, we noted that delivery of a signal is blocked during the execution
of its handler (unless we specify the SA_NODEFER flag to sigaction()). If the signal is
(again) generated while the handler is executing, then it is marked as pending and
later delivered when the handler returns. We also already noted that signals are not
queued. If the signal is generated more than once while the handler is executing,
then it is still marked as pending, and it will later be delivered only once.
That signals can “disappear” in this way has implications for how we design signal handlers. To begin with, we can’t reliably count the number of times a signal is
generated. Furthermore, we may need to code our signal handlers to deal with the
possibility that multiple events of the type corresponding to the signal have
occurred. We’ll see an example of this when we consider the use of the SIGCHLD signal
in Section 26.3.1.
21.1.2 Reentrant and Async-Signal-Safe Functions
Not all system calls and library functions can be safely called from a signal handler.
To understand why requires an explanation of two concepts: reentrant functions
and async-signal-safe functions.
Reentrant and nonreentrant functions
To explain what a reentrant function is, we need to first distinguish between singlethreaded and multithreaded programs. Classical UNIX programs have a single
thread of execution: the CPU processes instructions for a single logical flow of execution
through the program. In a multithreaded program, there are multiple, independent, concurrent logical flows of execution within the same process.
In Chapter 29, we’ll see how to explicitly create programs that contain multiple
threads of execution. However, the concept of multiple threads of execution is also
Signals: Signal Handlers 423
relevant for programs that employ signal handlers. Because a signal handler may
asynchronously interrupt the execution of a program at any point in time, the main
program and the signal handler in effect form two independent (although not concurrent) threads of execution within the same process.
A function is said to be reentrant if it can safely be simultaneously executed by
multiple threads of execution in the same process. In this context, “safe” means
that the function achieves its expected result, regardless of the state of execution of
any other thread of execution.
The SUSv3 definition of a reentrant function is one “whose effect, when called
by two or more threads, is guaranteed to be as if the threads each executed the
function one after the other in an undefined order, even if the actual execution is interleaved.”
A function may be nonreentrant if it updates global or static data structures. (A function that employs only local variables is guaranteed to be reentrant.) If two invocations of (i.e., two threads executing) the function simultaneously attempt to update
the same global variable or data structure, then these updates are likely to interfere
with each other and produce incorrect results. For example, suppose that one thread
of execution is in the middle of updating a linked list data structure to add a new
list item when another thread also attempts to update the same linked list. Since
adding a new item to the list requires updating multiple pointers, if another thread
interrupts these steps and updates the same pointers, chaos will result.
Such possibilities are in fact rife within the standard C library. For example, we
already noted in Section 7.1.3 that malloc() and free() maintain a linked list of freed
memory blocks available for reallocation from the heap. If a call to malloc() in the
main program is interrupted by a signal handler that also calls malloc(), then this
linked list can be corrupted. For this reason, the malloc() family of functions, and
other library functions that use them, are nonreentrant.
Other library functions are nonreentrant because they return information
using statically allocated memory. Examples of such functions (described elsewhere in this book) include crypt(), getpwnam(), gethostbyname(), and getservbyname().
If a signal handler also uses one of these functions, then it will overwrite information returned by any earlier call to the same function from within the main program (or vice versa).
Functions can also be nonreentrant if they use static data structures for their
internal bookkeeping. The most obvious examples of such functions are the members of the stdio library (printf(), scanf(), and so on), which update internal data
structures for buffered I/O. Thus, when using printf() from within a signal handler,
we may sometimes see strange output—or even a program crash or data corruption—
if the handler interrupts the main program in the middle of executing a call to
printf() or another stdio function.
Even if we are not using nonreentrant library functions, reentrancy issues can
still be relevant. If a signal handler updates programmer-defined global data structures that are also updated within the main program, then we can say that the signal handler is nonreentrant with respect to the main program.
If a function is nonreentrant, then its manual page will normally provide an
explicit or implicit indication of this fact. In particular, watch out for statements
that the function uses or returns information in statically allocated variables.
424 Chapter 21
Example program
Listing 21-1 demonstrates the nonreentrant nature of the crypt() function (Section 8.5).
As command-line arguments, this program accepts two strings. The program performs the following steps:
1. Call crypt() to encrypt the string in the first command-line argument, and copy
this string to a separate buffer using strdup().
2. Establish a handler for SIGINT (generated by typing Control-C). The handler calls
crypt() to encrypt the string supplied in the second command-line argument.
3. Enter an infinite for loop that uses crypt() to encrypt the string in the first
command-line argument and check that the returned string is the same as that
saved in step 1.
In the absence of a signal, the strings will always match in step 3. However, if a
SIGINT signal arrives and the execution of the signal handler interrupts the main
program just after the execution of the crypt() call in the for loop, but before the
check to see if the strings match, then the main program will report a mismatch.
When we run the program, this is what we see:
$ ./non_reentrant abc def
Repeatedly type Control-C to generate SIGINT
Mismatch on call 109871 (mismatch=1 handled=1)
Mismatch on call 128061 (mismatch=2 handled=2)
Many lines of output removed
Mismatch on call 727935 (mismatch=149 handled=156)
Mismatch on call 729547 (mismatch=150 handled=157)
Type Control-\ to generate SIGQUIT
Quit (core dumped)
Comparing the mismatch and handled values in the above output, we see that in the
majority of cases where the signal handler is invoked, it overwrites the statically
allocated buffer between the call to crypt() and the string comparison in main().
Listing 21-1: Calling a nonreentrant function from both main() and a signal handler
–––––––––––––––––––––––––––––––––––––––––––––––––––– signals/nonreentrant.c
#define _XOPEN_SOURCE 600
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include "tlpi_hdr.h"
static char *str2; /* Set from argv[2] */
static int handled = 0; /* Counts number of calls to handler */
static void
handler(int sig)
{
 crypt(str2, "xx");
 handled++;
}
Signals: Signal Handlers 425
int
main(int argc, char *argv[])
{
 char *cr1;
 int callNum, mismatch;
 struct sigaction sa;
 if (argc != 3)
 usageErr("%s str1 str2\n", argv[0]);
 str2 = argv[2]; /* Make argv[2] available to handler */
 cr1 = strdup(crypt(argv[1], "xx")); /* Copy statically allocated string
 to another buffer */
 if (cr1 == NULL)
 errExit("strdup");
 sigemptyset(&sa.sa_mask);
 sa.sa_flags = 0;
 sa.sa_handler = handler;
 if (sigaction(SIGINT, &sa, NULL) == -1)
 errExit("sigaction");
 /* Repeatedly call crypt() using argv[1]. If interrupted by a
 signal handler, then the static storage returned by crypt()
 will be overwritten by the results of encrypting argv[2], and
 strcmp() will detect a mismatch with the value in 'cr1'. */
 for (callNum = 1, mismatch = 0; ; callNum++) {
 if (strcmp(crypt(argv[1], "xx"), cr1) != 0) {
 mismatch++;
 printf("Mismatch on call %d (mismatch=%d handled=%d)\n",
 callNum, mismatch, handled);
 }
 }
}
–––––––––––––––––––––––––––––––––––––––––––––––––––– signals/nonreentrant.c
Standard async-signal-safe functions
An async-signal-safe function is one that the implementation guarantees to be safe
when called from a signal handler. A function is async-signal-safe either because it
is reentrant or because it is not interruptible by a signal handler.
Table 21-1 lists the functions that various standards require to be async-signalsafe. In this table, the functions whose names are not followed by a v2 or v3 were
specified as async-signal-safe in POSIX.1-1990. SUSv2 added the functions marked
v2 to the list, and those marked v3 were added by SUSv3. Individual UNIX implementations may make other functions async-signal-safe, but all standards-conformant UNIX implementations must ensure that at least these functions are asyncsignal-safe (if they are provided by the implementation; not all of these functions
are provided on Linux).
SUSv4 makes the following changes to Table 21-1:
z The following functions are removed: fpathconf(), pathconf(), and sysconf().
426 Chapter 21
z The following functions are added: execl(), execv(), faccessat(), fchmodat(),
fchownat(), fexecve(), fstatat(), futimens(), linkat(), mkdirat(), mkfifoat(), mknod(),
mknodat(), openat(), readlinkat(), renameat(), symlinkat(), unlinkat(), utimensat(),
and utimes().
Table 21-1: Functions required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3
_Exit() (v3)
_exit()
abort() (v3)
accept() (v3)
access()
aio_error() (v2)
aio_return() (v2)
aio_suspend() (v2)
alarm()
bind() (v3)
cfgetispeed()
cfgetospeed()
cfsetispeed()
cfsetospeed()
chdir()
chmod()
chown()
clock_gettime() (v2)
close()
connect() (v3)
creat()
dup()
dup2()
execle()
execve()
fchmod() (v3)
fchown() (v3)
fcntl()
fdatasync() (v2)
fork()
fpathconf() (v2)
fstat()
fsync() (v2)
ftruncate() (v3)
getegid()
geteuid()
getgid()
getgroups()
getpeername() (v3)
getpgrp()
getpid()
getppid()
getsockname() (v3)
getsockopt() (v3)
getuid()
kill()
link()
listen() (v3)
lseek()
lstat() (v3)
mkdir()
mkfifo()
open()
pathconf()
pause()
pipe()
poll() (v3)
posix_trace_event() (v3)
pselect() (v3)
raise() (v2)
read()
readlink() (v3)
recv() (v3)
recvfrom() (v3)
recvmsg() (v3)
rename()
rmdir()
select() (v3)
sem_post() (v2)
send() (v3)
sendmsg() (v3)
sendto() (v3)
setgid()
setpgid()
setsid()
setsockopt() (v3)
setuid()
shutdown() (v3)
sigaction()
sigaddset()
sigdelset()
sigemptyset()
sigfillset()
sigismember()
signal() (v2)
sigpause() (v2)
sigpending()
sigprocmask()
sigqueue() (v2)
sigset() (v2)
sigsuspend()
sleep()
socket() (v3)
sockatmark() (v3)
socketpair() (v3)
stat()
symlink() (v3)
sysconf()
tcdrain()
tcflow()
tcflush()
tcgetattr()
tcgetpgrp()
tcsendbreak()
tcsetattr()
tcsetpgrp()
time()
timer_getoverrun() (v2)
timer_gettime() (v2)
timer_settime() (v2)
times()
umask()
uname()
unlink()
utime()
wait()
waitpid()
write()
Signals: Signal Handlers 427
SUSv3 notes that all functions not listed in Table 21-1 are considered to be unsafe
with respect to signals, but points out that a function is unsafe only when invocation of a signal handler interrupts the execution of an unsafe function, and the handler itself also calls an unsafe function. In other words, when writing signal
handlers, we have two choices:
z Ensure that the code of the signal handler itself is reentrant and that it calls
only async-signal-safe functions.
z Block delivery of signals while executing code in the main program that calls
unsafe functions or works with global data structures also updated by the signal handler.
The problem with the second approach is that, in a complex program, it can be difficult to ensure that a signal handler will never interrupt the main program while it
is calling an unsafe function. For this reason, the above rules are often simplified to
the statement that we must not call unsafe functions from within a signal handler.
If we set up the same handler function to deal with several different signals or
use the SA_NODEFER flag to sigaction(), then a handler may interrupt itself. As a
consequence, the handler may be nonreentrant if it updates global (or static)
variables, even if they are not used by the main program.
Use of errno inside signal handlers
Because they may update errno, use of the functions listed in Table 21-1 can nevertheless render a signal handler nonreentrant, since they may overwrite the errno
value that was set by a function called from the main program. The workaround is
to save the value of errno on entry to a signal handler that uses any of the functions
in Table 21-1 and restore the errno value on exit from the handler, as in the following example:
void
handler(int sig)
{
 int savedErrno;
 savedErrno = errno;
 /* Now we can execute a function that might modify errno */
 errno = savedErrno;
}
Use of unsafe functions in example programs in this book
Although printf() is not async-signal-safe, we use it in signal handlers in various
example programs in this book. We do so because printf() provides an easy and
concise way to demonstrate that a signal handler has been called, and to display the
contents of relevant variables within the handler. For similar reasons, we occasionally use a few other unsafe functions in signal handlers, including other stdio functions and strsignal().
428 Chapter 21
Real-world applications should avoid calling non-async-signal-safe functions
from signal handlers. To make this clear, each signal handler in the example programs that uses one of these functions is marked with a comment indicating that
the usage is unsafe:
printf("Some message\n"); /* UNSAFE */
21.1.3 Global Variables and the sig_atomic_t Data Type
Notwithstanding reentrancy issues, it can be useful to share global variables
between the main program and a signal handler. This can be safe as long as the
main program correctly handles the possibility that the signal handler may change
the global variable at any time. For example, one common design is to make a signal
handler’s sole action the setting of a global flag. This flag is periodically checked by
the main program, which then takes appropriate action in response to the delivery
of the signal (and clears the flag). When global variables are accessed in this way
from a signal handler, we should always declare them using the volatile attribute
(see Section 6.8) in order to prevent the compiler from performing optimizations
that result in the variable being stored in a register.
Reading and writing global variables may involve more than one machinelanguage instruction, and a signal handler may interrupt the main program in the
middle of such an instruction sequence. (We say that access to the variable is
nonatomic.) For this reason, the C language standards and SUSv3 specify an integer
data type, sig_atomic_t, for which reads and writes are guaranteed to be atomic.
Thus, a global flag variable that is shared between the main program and a signal
handler should be declared as follows:
volatile sig_atomic_t flag;
We show an example of the use of the sig_atomic_t data type in Listing 22-5, on
page 466.
Note that the C increment (++) and decrement (--) operators don’t fall within
the guarantee provided for sig_atomic_t. On some hardware architectures, these
operations may not be atomic (refer to Section 30.1 for more details). All that we
are guaranteed to be safely allowed to do with a sig_atomic_t variable is set it within
the signal handler, and check it in the main program (or vice versa).
C99 and SUSv3 specify that an implementation should define two constants (in
<stdint.h>), SIG_ATOMIC_MIN and SIG_ATOMIC_MAX, that define the range of values that
may be assigned to variables of type sig_atomic_t. The standards require that this
range be at least –127 to 127 if sig_atomic_t is represented as a signed value, or 0 to 255
if it is represented as an unsigned value. On Linux, these two constants equate to
the negative and positive limits for signed 32-bit integers.
21.2 Other Methods of Terminating a Signal Handler
All of the signal handlers that we have looked at so far complete by returning to the
main program. However, simply returning from a signal handler sometimes isn’t
desirable, or in some cases, isn’t even useful. (We’ll see an example of where
Signals: Signal Handlers 429
returning from a signal handler isn’t useful when we discuss hardware-generated
signals in Section 22.4.)
There are various other ways of terminating a signal handler:
z Use _exit() to terminate the process. Beforehand, the handler may carry out
some cleanup actions. Note that we can’t use exit() to terminate a signal handler,
because it is not one of safe functions listed in Table 21-1. It is unsafe because it
flushes stdio buffers prior to calling _exit(), as described in Section 25.1.
z Use kill() or raise() to send a signal that kills the process (i.e., a signal whose
default action is process termination).
z Perform a nonlocal goto from the signal handler.
z Use the abort() function to terminate the process with a core dump.
The last two of these options are described in further detail in the following sections.
21.2.1 Performing a Nonlocal Goto from a Signal Handler
Section 6.8 described the use of setjmp() and longjmp() to perform a nonlocal goto
from a function to one of its callers. We can also use this technique from a signal
handler. This provides a way to recover after delivery of a signal caused by a hardware exception (e.g., a memory access error), and also allows us to catch a signal
and return control to a particular point in a program. For example, upon receipt of
a SIGINT signal (normally generated by typing Control-C), the shell performs a nonlocal
goto to return control to its main input loop (and thus read a new command).
However, there is a problem with using the standard longjmp() function to exit
from a signal handler. We noted earlier that, upon entry to the signal handler, the
kernel automatically adds the invoking signal, as well as any signals specified in the
act.sa_mask field, to the process signal mask, and then removes these signals from
the mask when the handler does a normal return.
What happens to the signal mask if we exit the signal handler using longjmp()?
The answer depends on the genealogy of the particular UNIX implementation.
Under System V, longjmp() doesn’t restore the signal mask, so that blocked signals
are not unblocked upon leaving the handler. Linux follows the System V behavior.
(This is usually not what we want, since it leaves the signal that caused invocation of
the handler blocked.) Under BSD-derived implementations, setjmp() saves the signal mask in its env argument, and the saved signal mask is restored by longjmp().
(BSD-derived implementations also provide two other functions, _setjmp() and
_longjmp(), which have the System V semantics.) In other words, we can’t portably
use longjmp() to exit a signal handler.
If we define the _BSD_SOURCE feature test macro when compiling a program,
then (the glibc) setjmp() follows the BSD semantics.
Because of this difference in the two main UNIX variants, POSIX.1-1990 chose not
to specify the handling of the signal mask by setjmp() and longjmp(). Instead, it
defined a pair of new functions, sigsetjmp() and siglongjmp(), that provide explicit
control of the signal mask when performing a nonlocal goto.
430 Chapter 21
The sigsetjmp() and siglongjmp() functions operate similarly to setjmp() and longjmp().
The only differences are in the type of the env argument (sigjmp_buf instead of
jmp_buf) and the extra savesigs argument to sigsetjmp(). If savesigs is nonzero, then
the process signal mask that is current at the time of the sigsetjmp() call is saved in
env and restored by a later siglongjmp() call specifying the same env argument. If
savesigs is 0, then the process signal mask is not saved and restored.
The longjmp() and siglongjmp() functions are not listed among the async-signalsafe functions in Table 21-1. This is because calling any non-async-signal-safe function after performing a nonlocal goto carries the same risks as calling that function
from within the signal handler. Furthermore, if a signal handler interrupts the
main program while it is part-way through updating a data structure, and the handler exits by performing a nonlocal goto, then the incomplete update may leave
that data structure in an inconsistent state. One technique that can help to avoid
problems is to use sigprocmask() to temporarily block the signal while sensitive
updates are being performed.
Example program
Listing 21-2 demonstrates the difference in signal mask handling for the two types
of nonlocal gotos. This program establishes a handler for SIGINT. The program is
designed to allow either setjmp() plus longjmp() or sigsetjmp() plus siglongjmp() to be
used to exit the signal handler, depending on whether the program is compiled
with the USE_SIGSETJMP macro defined. The program displays the current settings of
the signal mask both on entry to the signal handler and after the nonlocal goto has
transferred control from the handler back to the main program.
When we build the program so that longjmp() is used to exit the signal handler,
this is what we see when we run the program:
$ make -s sigmask_longjmp Default compilation causes setjmp() to be used
$ ./sigmask_longjmp
Signal mask at startup:
 <empty signal set>
Calling setjmp()
Type Control-C to generate SIGINT
Received signal 2 (Interrupt), signal mask is:
 2 (Interrupt)
After jump from handler, signal mask is:
 2 (Interrupt)
(At this point, typing Control-C again has no effect, since SIGINT is blocked)
Type Control-\ to kill the program
Quit
#include <setjmp.h>
int sigsetjmp(sigjmp_buf env, int savesigs);
Returns 0 on initial call, nonzero on return via siglongjmp()
void siglongjmp(sigjmp_buf env, int val);
Signals: Signal Handlers 431
From the program output, we can see that, after a longjmp() from the signal
handler, the signal mask remains set to the value to which it was set on entry to
the signal handler.
In the above shell session, we built the program using the makefile supplied
with the source code distribution for this book. The –s option tells make not to
echo the commands that it is executing. We use this option to avoid cluttering
the session log. ([Mecklenburg, 2005] provides a description of the GNU make
program.)
When we compile the same source file to build an executable that uses siglongjmp()
to exit the handler, we see the following:
$ make -s sigmask_siglongjmp Compiles using cc –DUSE_SIGSETJMP
$ ./sigmask_siglongjmp x
Signal mask at startup:
 <empty signal set>
Calling sigsetjmp()
Type Control-C
Received signal 2 (Interrupt), signal mask is:
 2 (Interrupt)
After jump from handler, signal mask is:
 <empty signal set>
At this point, SIGINT is not blocked, because siglongjmp() restored the signal mask to
its original state. Next, we type Control-C again, so that the handler is once more
invoked:
Type Control-C
Received signal 2 (Interrupt), signal mask is:
 2 (Interrupt)
After jump from handler, signal mask is:
 <empty signal set>
Type Control-\ to kill the program
Quit
From the above output, we can see that siglongjmp() restores the signal mask to the
value it had at the time of the sigsetjmp() call (i.e., an empty signal set).
Listing 21-2 also demonstrates a useful technique for use with a signal handler
that performs a nonlocal goto. Because a signal can be generated at any time, it
may actually occur before the target of the goto has been set up by sigsetjmp() (or
setjmp()). To prevent this possibility (which would cause the handler to perform a
nonlocal goto using an uninitialized env buffer), we employ a guard variable,
canJump, to indicate whether the env buffer has been initialized. If canJump is false,
then instead of doing a nonlocal goto, the handler simply returns. An alternative
approach is to arrange the program code so that the call to sigsetjmp() (or setjmp())
occurs before the signal handler is established. However, in complex programs, it
may be difficult to ensure that these two steps are performed in that order, and the
use of a guard variable may be simpler.
432 Chapter 21
Note that using #ifdef was the simplest way of writing the program in Listing 21-2
in a standards-conformant fashion. In particular, we could not have replaced the
#ifdef with the following run-time check:
if (useSiglongjmp)
 s = sigsetjmp(senv, 1);
else
 s = setjmp(env);
if (s == 0)
 ...
This is not permitted because SUSv3 doesn’t allow setjmp() and sigsetjmp() to be used
within an assignment statement (see Section 6.8).
Listing 21-2: Performing a nonlocal goto from a signal handler
–––––––––––––––––––––––––––––––––––––––––––––––––– signals/sigmask_longjmp.c
#define _GNU_SOURCE /* Get strsignal() declaration from <string.h> */
#include <string.h>
#include <setjmp.h>
#include <signal.h>
#include "signal_functions.h" /* Declaration of printSigMask() */
#include "tlpi_hdr.h"
static volatile sig_atomic_t canJump = 0;
 /* Set to 1 once "env" buffer has been
 initialized by [sig]setjmp() */
#ifdef USE_SIGSETJMP
static sigjmp_buf senv;
#else
static jmp_buf env;
#endif
static void
handler(int sig)
{
 /* UNSAFE: This handler uses non-async-signal-safe functions
 (printf(), strsignal(), printSigMask(); see Section 21.1.2) */
 printf("Received signal %d (%s), signal mask is:\n", sig,
 strsignal(sig));
 printSigMask(stdout, NULL);
 if (!canJump) {
 printf("'env' buffer not yet set, doing a simple return\n");
 return;
 }
#ifdef USE_SIGSETJMP
 siglongjmp(senv, 1);
#else
 longjmp(env, 1);
#endif
}
Signals: Signal Handlers 433
int
main(int argc, char *argv[])
{
 struct sigaction sa;
 printSigMask(stdout, "Signal mask at startup:\n");
 sigemptyset(&sa.sa_mask);
 sa.sa_flags = 0;
 sa.sa_handler = handler;
 if (sigaction(SIGINT, &sa, NULL) == -1)
 errExit("sigaction");
#ifdef USE_SIGSETJMP
 printf("Calling sigsetjmp()\n");
 if (sigsetjmp(senv, 1) == 0)
#else
 printf("Calling setjmp()\n");
 if (setjmp(env) == 0)
#endif
 canJump = 1; /* Executed after [sig]setjmp() */
 else /* Executed after [sig]longjmp() */
 printSigMask(stdout, "After jump from handler, signal mask is:\n" );
 for (;;) /* Wait for signals until killed */
 pause();
}
–––––––––––––––––––––––––––––––––––––––––––––––––– signals/sigmask_longjmp.c
21.2.2 Terminating a Process Abnormally: abort()
The abort() function terminates the calling process and causes it to produce a
core dump.
The abort() function terminates the calling process by raising a SIGABRT signal. The
default action for SIGABRT is to produce a core dump file and terminate the process.
The core dump file can then be used within a debugger to examine the state of the
program at the time of the abort() call.
SUSv3 requires that abort() override the effect of blocking or ignoring SIGABRT.
Furthermore, SUSv3 specifies that abort() must terminate the process unless the
process catches the signal with a handler that doesn’t return. This last statement
requires a moment’s thought. Of the methods of terminating a signal handler
described in Section 21.2, the one that is relevant here is the use of a nonlocal goto
to exit the handler. If this is done, then the effect of abort() will be nullified; otherwise,
#include <stdlib.h>
void abort(void);
434 Chapter 21
abort() always terminates the process. In most implementations, termination is
guaranteed as follows: if the process still hasn’t terminated after raising SIGABRT
once (i.e., a handler catches the signal and returns, so that execution of abort() is
resumed), abort() resets the handling of SIGABRT to SIG_DFL and raises a second
SIGABRT, which is guaranteed to kill the process.
If abort() does successfully terminate the process, then it also flushes and closes
stdio streams.
An example of the use of abort() is provided in the error-handling functions of
Listing 3-3, on page 54.
21.3 Handling a Signal on an Alternate Stack: sigaltstack()
Normally, when a signal handler is invoked, the kernel creates a frame for it on the
process stack. However, this may not be possible if a process attempts to extend
the stack beyond the maximum possible size. For example, this may occur
because the stack grows so large that it encounters a region of mapped memory
(Section 48.5) or the upwardly growing heap, or it reaches the RLIMIT_STACK resource
limit (Section 36.3).
When a process attempts to grow its stack beyond the maximum possible size,
the kernel generates a SIGSEGV signal for the process. However, since the stack space
is exhausted, the kernel can’t create a frame for any SIGSEGV handler that the program may have established. Consequently, the handler is not invoked, and the process is terminated (the default action for SIGSEGV).
If we instead need to ensure that the SIGSEGV signal is handled in these circumstances, we can do the following:
1. Allocate an area of memory, called an alternate signal stack, to be used for the
stack frame of a signal handler.
2. Use the sigaltstack() system call to inform the kernel of the existence of the
alternate signal stack.
3. When establishing the signal handler, specify the SA_ONSTACK flag, to tell the kernel
that the frame for this handler should be created on the alternate stack.
The sigaltstack() system call both establishes an alternate signal stack and returns
information about any alternate signal stack that is already established.
The sigstack argument points to a structure specifying the location and attributes of
the new alternate signal stack. The old_sigstack argument points to a structure used
to return information about the previously established alternate signal stack (if
there was one). Either one of these arguments can be specified as NULL. For example,
we can find out about the existing alternate signal stack, without changing it, by
#include <signal.h>
int sigaltstack(const stack_t *sigstack, stack_t *old_sigstack);
Returns 0 on success, or –1 on error
Signals: Signal Handlers 435
specifying NULL for the sigstack argument. Otherwise, each of these arguments
points to a structure of the following type:
typedef struct {
 void *ss_sp; /* Starting address of alternate stack */
 int ss_flags; /* Flags: SS_ONSTACK, SS_DISABLE */
 size_t ss_size; /* Size of alternate stack */
} stack_t;
The ss_sp and ss_size fields specify the size and location of the alternate signal stack.
When actually using the alternate signal stack, the kernel automatically takes care
of aligning the value given in ss_sp to an address boundary that is suitable for the
hardware architecture.
Typically, the alternate signal stack is either statically allocated or dynamically
allocated on the heap. SUSv3 specifies the constant SIGSTKSZ to be used as a typical
value when sizing the alternate stack, and MINSIGSTKSZ as the minimum size required
to invoke a signal handler. On Linux/x86-32, these constants are defined with the
values 8192 and 2048, respectively.
The kernel doesn’t resize an alternate signal stack. If the stack overflows the
space we have allocated for it, then chaos results (e.g., overwriting of variables
beyond the limits of the stack). This is not usually a problem—because we normally
use an alternate signal stack to handle the special case of the standard stack overflowing, typically only one or a few frames are allocated on the stack. The job of the
SIGSEGV handler is either to perform some cleanup and terminate the process or to
unwind the standard stack using a nonlocal goto.
The ss_flags field contains one of the following values:
SS_ONSTACK
If this flag is set when retrieving information about the currently established alternate signal stack (old_sigstack), it indicates that the process is
currently executing on the alternate signal stack. Attempts to establish a
new alternate signal stack while the process is already running on an alternate signal stack result in an error (EPERM) from sigaltstack().
SS_DISABLE
Returned in old_sigstack, this flag indicates that there is no currently established alternate signal stack. When specified in sigstack, this disables a
currently established alternate signal stack.
Listing 21-3 demonstrates the establishment and use of an alternate signal stack.
After establishing an alternate signal stack and a handler for SIGSEGV, this program
calls a function that infinitely recurses, so that the stack overflows and the process
is sent a SIGSEGV signal. When we run the program, this is what we see:
$ ulimit -s unlimited
$ ./t_sigaltstack
Top of standard stack is near 0xbffff6b8
Alternate stack is at 0x804a948-0x804cfff
Call 1 - top of stack near 0xbff0b3ac
Call 2 - top of stack near 0xbfe1714c
Many intervening lines of output removed
Call 2144 - top of stack near 0x4034120c
436 Chapter 21
Call 2145 - top of stack near 0x4024cfac
Caught signal 11 (Segmentation fault)
Top of handler stack near 0x804c860
In this shell session, the ulimit command is used to remove any RLIMIT_STACK
resource limit that may have been set in the shell. We explain this resource limit in
Section 36.3.
Listing 21-3: Using sigaltstack()
––––––––––––––––––––––––––––––––––––––––––––––––––––signals/t_sigaltstack.c
#define _GNU_SOURCE /* Get strsignal() declaration from <string.h> */
#include <string.h>
#include <signal.h>
#include "tlpi_hdr.h"
static void
sigsegvHandler(int sig)
{
 int x;
 /* UNSAFE: This handler uses non-async-signal-safe functions
 (printf(), strsignal(), fflush(); see Section 21.1.2) */
 printf("Caught signal %d (%s)\n", sig, strsignal(sig));
 printf("Top of handler stack near %10p\n", (void *) &x);
 fflush(NULL);
 _exit(EXIT_FAILURE); /* Can't return after SIGSEGV */
}
static void /* A recursive function that overflows the stack */
overflowStack(int callNum)
{
 char a[100000]; /* Make this stack frame large */
 printf("Call %4d - top of stack near %10p\n", callNum, &a[0]);
 overflowStack(callNum+1);
}
int
main(int argc, char *argv[])
{
 stack_t sigstack;
 struct sigaction sa;
 int j;
 printf("Top of standard stack is near %10p\n", (void *) &j);
 /* Allocate alternate stack and inform kernel of its existence */
 sigstack.ss_sp = malloc(SIGSTKSZ);
 if (sigstack.ss_sp == NULL)
 errExit("malloc");
Signals: Signal Handlers 437
 sigstack.ss_size = SIGSTKSZ;
 sigstack.ss_flags = 0;
 if (sigaltstack(&sigstack, NULL) == -1)
 errExit("sigaltstack");
 printf("Alternate stack is at %10p-%p\n",
 sigstack.ss_sp, (char *) sbrk(0) - 1);
 sa.sa_handler = sigsegvHandler; /* Establish handler for SIGSEGV */
 sigemptyset(&sa.sa_mask);
 sa.sa_flags = SA_ONSTACK; /* Handler uses alternate stack */
 if (sigaction(SIGSEGV, &sa, NULL) == -1)
 errExit("sigaction");
 overflowStack(1);
}
––––––––––––––––––––––––––––––––––––––––––––––––––––signals/t_sigaltstack.c
21.4 The SA_SIGINFO Flag
Setting the SA_SIGINFO flag when establishing a handler with sigaction() allows the
handler to obtain additional information about a signal when it is delivered. In
order to obtain this information, we must declare the handler as follows:
void handler(int sig, siginfo_t *siginfo, void *ucontext);
The first argument, sig, is the signal number, as for a standard signal handler. The
second argument, siginfo, is a structure used to provide the additional information
about the signal. We describe this structure below. The last argument, ucontext, is
also described below.
Since the above signal handler has a different prototype from a standard signal
handler, C typing rules mean that we can’t use the sa_handler field of the sigaction
structure to specify the address of the handler. Instead, we must use an alternative
field: sa_sigaction. In other words, the definition of the sigaction structure is somewhat more complex than was shown in Section 20.13. In full, the structure is
defined as follows:
struct sigaction {
 union {
 void (*sa_handler)(int);
 void (*sa_sigaction)(int, siginfo_t *, void *);
 } __sigaction_handler;
 sigset_t sa_mask;
 int sa_flags;
 void (*sa_restorer)(void);
};
/* Following defines make the union fields look like simple fields
 in the parent structure */
#define sa_handler __sigaction_handler.sa_handler
#define sa_sigaction __sigaction_handler.sa_sigaction
438 Chapter 21
The sigaction structure uses a union to combine the sa_sigaction and sa_handler
fields. (Most other UNIX implementations similarly use a union for this purpose.)
Using a union is possible because only one of these fields is required during a particular call to sigaction(). (However, this can lead to strange bugs if we naively
expect to be able to set the sa_handler and sa_sigaction fields independently of one
another, perhaps because we reuse a single sigaction structure in multiple sigaction()
calls to establish handlers for different signals.)
Here is an example of the use of SA_SIGINFO to establish a signal handler:
struct sigaction act;
sigemptyset(&act.sa_mask);
act.sa_sigaction = handler;
act.sa_flags = SA_SIGINFO;
if (sigaction(SIGINT, &act, NULL) == -1)
 errExit("sigaction");
For complete examples of the use of the SA_SIGINFO flag, see Listing 22-3 (page 462)
and Listing 23-5 (page 500).
The siginfo_t structure
The siginfo_t structure passed as the second argument to a signal handler that is
established with SA_SIGINFO has the following form:
typedef struct {
 int si_signo; /* Signal number */
 int si_code; /* Signal code */
 int si_trapno; /* Trap number for hardware-generated signal
 (unused on most architectures) */
 union sigval si_value; /* Accompanying data from sigqueue() */
 pid_t si_pid; /* Process ID of sending process */
 uid_t si_uid; /* Real user ID of sender */
 int si_errno; /* Error number (generally unused) */
 void *si_addr; /* Address that generated signal
 (hardware-generated signals only) */
 int si_overrun; /* Overrun count (Linux 2.6, POSIX timers) */
 int si_timerid; /* (Kernel-internal) Timer ID
 (Linux 2.6, POSIX timers) */
 long si_band; /* Band event (SIGPOLL/SIGIO) */
 int si_fd; /* File descriptor (SIGPOLL/SIGIO) */
 int si_status; /* Exit status or signal (SIGCHLD) */
 clock_t si_utime; /* User CPU time (SIGCHLD) */
 clock_t si_stime; /* System CPU time (SIGCHLD) */
} siginfo_t;
The _POSIX_C_SOURCE feature test macro must be defined with a value greater than or
equal to 199309 in order to make the declaration of the siginfo_t structure visible
from <signal.h>.
On Linux, as on most UNIX implementations, many of the fields in the
siginfo_t structure are combined into a union, since not all of the fields are needed
for each signal. (See <bits/siginfo.h> for details.)
Signals: Signal Handlers 439
Upon entry to a signal handler, the fields of the siginfo_t structure are set as follows:
si_signo
This field is set for all signals. It contains the number of the signal causing
invocation of the handler—that is, the same value as the sig argument to the
handler.
si_code
This field is set for all signals. It contains a code providing further information about the origin of the signal, as shown in Table 21-1.
si_value
This field contains the accompanying data for a signal sent via sigqueue().
We describe sigqueue() in Section 22.8.1.
si_pid
For signals sent via kill() or sigqueue(), this field is set to the process ID of
the sending process.
si_uid
For signals sent via kill() or sigqueue(), this field is set to the real user ID of
the sending process. The system provides the real user ID of the sending
process because that is more informative than providing the effective user
ID. Consider the permission rules for sending signals described in
Section 20.5: if the effective user ID grants the sender permission to send
the signal, then that user ID must either be 0 (i.e., a privileged process), or
be the same as the real user ID or saved set-user-ID of the receiving process. In this case, it could be useful for the receiver to know the sender’s
real user ID, which may be different from the effective user ID (e.g., if the
sender is a set-user-ID program).
si_errno
If this field is set to a nonzero value, then it contains an error number (like
errno) that identifies the cause of the signal. This field is generally unused
on Linux.
si_addr
This field is set only for hardware-generated SIGBUS, SIGSEGV, SIGILL, and
SIGFPE signals. For the SIGBUS and SIGSEGV signals, this field contains the
address that caused the invalid memory reference. For the SIGILL and
SIGFPE signals, this field contains the address of the program instruction
that caused the signal.
The following fields, which are nonstandard Linux extensions, are set only on the
delivery of a signal generated on expiration of a POSIX timer (see Section 23.6):
si_timerid
This field contains an ID that the kernel uses internally to identify the timer.
si_overrun
This field is set to the overrun count for the timer.
440 Chapter 21
The following two fields are set only for the delivery of a SIGIO signal (Section 63.3):
si_band
This field contains the “band event” value associated with the I/O event.
(In versions of glibc up until 2.3.2, si_band was typed as int.)
si_fd
This field contains the number of the file descriptor associated with the I/O
event. This field is not specified in SUSv3, but it is present on many other
implementations.
The following fields are set only for the delivery of a SIGCHLD signal (Section 26.3):
si_status
This field contains either the exit status of the child (if si_code is CLD_EXITED)
or the number of the signal sent to the child (i.e., the number of the signal that
terminated or stopped the child, as described in Section 26.1.3).
si_utime
This field contains the user CPU time used by the child process. In kernels
before 2.6, and since 2.6.27, this is measured in system clock ticks (divide
by sysconf(_SC_CLK_TCK)). In 2.6 kernels before 2.6.27, a bug meant that
this field reported times measured in (user-configurable) jiffies (see Section 10.6). This field is not specified in SUSv3, but it is present on many
other implementations.
si_stime
This field contains the system CPU time used by the child process. See the
description of the si_utime field. This field is not specified in SUSv3, but it
is present on many other implementations.
The si_code field provides further information about the origin of the signal, using
the values shown in Table 21-2. Not all of the signal-specific values shown in the second
column of this table occur on all UNIX implementations and hardware architectures (especially in the case of the four hardware-generated signals SIGBUS, SIGSEGV,
SIGILL, and SIGFPE), although all of these constants are defined on Linux and most
appear in SUSv3.
Note the following additional points about the values shown in Table 21-2:
z The values SI_KERNEL and SI_SIGIO are Linux-specific. They are not specified in
SUSv3 and do not appear on other UNIX implementations.
z SI_SIGIO is employed only in Linux 2.2. From kernel 2.4 onward, Linux instead
employs the POLL_* constants shown in the table.
SUSv4 specifies the psiginfo() function, whose purpose is similar to psignal()
(Section 20.8). The psiginfo() function takes two arguments: a pointer to a
siginfo_t structure and a message string. It prints the message string on standard error, followed by information about the signal described in the siginfo_t
structure. The psiginfo() function is provided by glibc since version 2.10. The
glibc implementation prints the signal description, the origin of the signal (as
indicated by the si_code field), and, for some signals, other fields from the
siginfo_t structure. The psiginfo() function is new in SUSv4, and it is not available on all systems.
Signals: Signal Handlers 441
Table 21-2: Values returned in the si_code field of the siginfo_t structure
Signal si_code value Origin of signal
Any SI_ASYNCIO Completion of an asynchronous I/O (AIO) operation
SI_KERNEL Sent by the kernel (e.g., a signal from terminal driver)
SI_MESGQ Message arrival on POSIX message queue (since Linux 2.6.6)
SI_QUEUE A realtime signal from a user process via sigqueue()
SI_SIGIO SIGIO signal (Linux 2.2 only)
SI_TIMER Expiration of a POSIX (realtime) timer
SI_TKILL A user process via tkill() or tgkill() (since Linux 2.4.19)
SI_USER A user process via kill() or raise()
SIGBUS BUS_ADRALN Invalid address alignment
BUS_ADRERR Nonexistent physical address
BUS_MCEERR_AO Hardware memory error; action optional (since Linux 2.6.32)
BUS_MCEERR_AR Hardware memory error; action required (since Linux 2.6.32)
BUS_OBJERR Object-specific hardware error
SIGCHLD CLD_CONTINUED Child continued by SIGCONT (since Linux 2.6.9)
CLD_DUMPED Child terminated abnormally, with core dump
CLD_EXITED Child exited
CLD_KILLED Child terminated abnormally, without core dump
CLD_STOPPED Child stopped
CLD_TRAPPED Traced child has stopped
SIGFPE FPE_FLTDIV Floating-point divide-by-zero
FPE_FLTINV Invalid floating-point operation
FPE_FLTOVF Floating-point overflow
FPE_FLTRES Floating-point inexact result
FPE_FLTUND Floating-point underflow
FPE_INTDIV Integer divide-by-zero
FPE_INTOVF Integer overflow
FPE_SUB Subscript out of range
SIGILL ILL_BADSTK Internal stack error
ILL_COPROC Coprocessor error
ILL_ILLADR Illegal addressing mode
ILL_ILLOPC Illegal opcode
ILL_ILLOPN Illegal operand
ILL_ILLTRP Illegal trap
ILL_PRVOPC Privileged opcode
ILL_PRVREG Privileged register
SIGPOLL/
SIGIO
POLL_ERR I/O error
POLL_HUP Device disconnected
POLL_IN Input data available
POLL_MSG Input message available
POLL_OUT Output buffers available
POLL_PRI High-priority input available
SIGSEGV SEGV_ACCERR Invalid permissions for mapped object
SEGV_MAPERR Address not mapped to object
(continued)
442 Chapter 21
The ucontext argument
The final argument passed to a handler established with the SA_SIGINFO flag,
ucontext, is a pointer to a structure of type ucontext_t (defined in <ucontext.h>).
(SUSv3 uses a void pointer for this argument because it doesn’t specify any of the
details of the argument.) This structure provides so-called user-context information
describing the process state prior to invocation of the signal handler, including the
previous process signal mask and saved register values (e.g., program counter and
stack pointer). This information is rarely used in signal handlers, so we don’t go
into further details.
Another use of ucontext_t structures is with the functions getcontext(),
makecontext(), setcontext(), and swapcontext(), which allow a process to retrieve,
create, change, and swap execution contexts, respectively. (These operations
are somewhat like setjmp() and longjmp(), but more general.) These functions
can be used to implement coroutines, where the thread of execution of a process alternates between two (or more) functions. SUSv3 specifies these functions, but marks them obsolete. SUSv4 removes the specifications, and
suggests that applications should be rewritten to use POSIX threads instead.
The glibc manual provides further information about these functions.
21.5 Interruption and Restarting of System Calls
Consider the following scenario:
1. We establish a handler for some signal.
2. We make a blocking system call, for example, a read() from a terminal device,
which blocks until input is supplied.
3. While the system call is blocked, the signal for which we established a handler
is delivered, and its signal handler is invoked.
What happens after the signal handler returns? By default, the system call fails with
the error EINTR (“Interrupted function”). This can be a useful feature. In Section 23.3,
we’ll see how to use a timer (which results in the delivery of a SIGALRM signal) to set a
timeout on a blocking system call such as read().
Often, however, we would prefer to continue the execution of an interrupted
system call. To do this, we could use code such as the following to manually restart
a system call in the event that it is interrupted by a signal handler:
while ((cnt = read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)
 continue; /* Do nothing loop body */
if (cnt == -1) /* read() failed with other than EINTR */
 errExit("read");
SIGTRAP TRAP_BRANCH Process branch trap
TRAP_BRKPT Process breakpoint
TRAP_HWBKPT Hardware breakpoint/watchpoint
TRAP_TRACE Process trace trap
Table 21-2: Values returned in the si_code field of the siginfo_t structure (continued)
Signal si_code value Origin of signal
Signals: Signal Handlers 443
If we frequently write code such as the above, it can be useful to define a macro
such as the following:
#define NO_EINTR(stmt) while ((stmt) == -1 && errno == EINTR);
Using this macro, we can rewrite the earlier read() call as follows:
NO_EINTR(cnt = read(fd, buf, BUF_SIZE));
if (cnt == -1) /* read() failed with other than EINTR */
 errExit("read");
The GNU C library provides a (nonstandard) macro with the same purpose as
our NO_EINTR() macro in <unistd.h>. The macro is called TEMP_FAILURE_RETRY()
and is made available if the _GNU_SOURCE feature test macro is defined.
Even if we employ a macro like NO_EINTR(), having signal handlers interrupt system
calls can be inconvenient, since we must add code to each blocking system call
(assuming that we want to restart the call in each case). Instead, we can specify the
SA_RESTART flag when establishing the signal handler with sigaction(), so that system
calls are automatically restarted by the kernel on the process’s behalf. This means
that we don’t need to handle a possible EINTR error return for these system calls.
The SA_RESTART flag is a per-signal setting. In other words, we can allow handlers
for some signals to interrupt blocking system calls, while others permit automatic
restarting of system calls.
System calls (and library functions) for which SA_RESTART is effective
Unfortunately, not all blocking system calls automatically restart as a result of specifying SA_RESTART. The reasons for this are partly historical:
z Restarting of system calls was introduced in 4.2BSD, and covered interrupted
calls to wait() and waitpid(), as well as the following I/O system calls: read(),
readv(), write(), writev(), and blocking ioctl() operations. The I/O system calls
are interruptible, and hence automatically restarted by SA_RESTART only when
operating on a “slow” device. Slow devices include terminals, pipes, FIFOs, and
sockets. On these file types, various I/O operations may block. (By contrast,
disk files don’t fall into the category of slow devices, because disk I/O operations generally can be immediately satisfied via the buffer cache. If a disk I/O
is required, the kernel puts the process to sleep until the I/O completes.)
z A number of other blocking system calls are derived from System V, which did
not initially provide for restarting of system calls.
On Linux, the following blocking system calls (and library functions layered on top
of system calls) are automatically restarted if interrupted by a signal handler established using the SA_RESTART flag:
z The system calls used to wait for a child process (Section 26.1): wait(), waitpid(),
wait3(), wait4(), and waitid().
z The I/O system calls read(), readv(), write(), writev(), and ioctl() when applied to
“slow” devices. In cases where data has already been partially transferred at the
444 Chapter 21
time of signal delivery, the input and output system calls will be interrupted,
but return a success status: an integer indicating how many bytes were successfully transferred.
z The open() system call, in cases where it can block (e.g., when opening FIFOs,
as described in Section 44.7).
z Various system calls used with sockets: accept(), accept4(), connect(), send(),
sendmsg(), sendto(), recv(), recvfrom(), and recvmsg(). (On Linux, these system calls
are not automatically restarted if a timeout has been set on the socket using
setsockopt(). See the signal(7) manual page for details.)
z The system calls used for I/O on POSIX message queues: mq_receive(),
mq_timedreceive(), mq_send(), and mq_timedsend().
z The system calls and library functions used to place file locks: flock(), fcntl(),
and lockf().
z The FUTEX_WAIT operation of the Linux-specific futex() system call.
z The sem_wait() and sem_timedwait() functions used to decrement a POSIX semaphore. (On some UNIX implementations, sem_wait() is restarted if the SA_RESTART
flag is specified.)
z The functions used to synchronize POSIX threads: pthread_mutex_lock(),
pthread_mutex_trylock(), pthread_mutex_timedlock(), pthread_cond_wait(), and
pthread_cond_timedwait().
In kernels before 2.6.22, futex(), sem_wait(), and sem_timedwait() always failed with
the error EINTR when interrupted, regardless of the setting of the SA_RESTART flag.
The following blocking system calls (and library functions layered on top of system calls) are never automatically restarted (even if SA_RESTART is specified):
z The poll(), ppoll(), select(), and pselect() I/O multiplexing calls. (SUSv3 explicitly
states that the behavior of select() and pselect() when interrupted by a signal
handler is unspecified, regardless of the setting of SA_RESTART.)
z The Linux-specific epoll_wait() and epoll_pwait() system calls.
z The Linux-specific io_getevents() system call.
z The blocking system calls used with System V message queues and semaphores:
semop(), semtimedop(), msgrcv(), and msgsnd(). (Although System V did not originally provide automatic restarting of system calls, on some UNIX implementations, these system calls are restarted if the SA_RESTART flag is specified.)
z A read() from an inotify file descriptor.
z The system calls and library functions designed to suspend execution of a program for a specified period: sleep(), nanosleep(), and clock_nanosleep().
z The system calls designed specifically to wait until a signal is delivered: pause(),
sigsuspend(), sigtimedwait(), and sigwaitinfo().
Modifying the SA_RESTART flag for a signal
The siginterrupt() function changes the SA_RESTART setting associated with a signal.
Signals: Signal Handlers 445
If flag is true (1), then a handler for the signal sig will interrupt blocking system
calls. If flag is false (0), then blocking system calls will be restarted after execution
of a handler for sig.
The siginterrupt() function works by using sigaction() to fetch a copy of the signal’s
current disposition, tweaking the SA_RESTART flag in the returned oldact structure,
and then calling sigaction() once more to update the signal’s disposition.
SUSv4 marks siginterrupt() obsolete, recommending the use of sigaction()
instead for this purpose.
Unhandled stop signals can generate EINTR for some Linux system calls
On Linux, certain blocking system calls can return EINTR even in the absence of a
signal handler. This can occur if the system call is blocked and the process is
stopped by a signal (SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU), and then resumed by delivery
of a SIGCONT signal.
The following system calls and functions exhibit this behavior: epoll_pwait(),
epoll_wait(), read() from an inotify file descriptor, semop(), semtimedop(), sigtimedwait(),
and sigwaitinfo().
In kernels before 2.6.24, poll() also exhibited this behavior, as did sem_wait(),
sem_timedwait(), futex(FUTEX_WAIT), in kernels before 2.6.22, msgrcv() and msgsnd()
in kernels before 2.6.9, and nanosleep() in Linux 2.4 and earlier.
In Linux 2.4 and earlier, sleep() can also be interrupted in this manner, but,
instead of returning an error, it returns the number of remaining unslept seconds.
The upshot of this behavior is that if there is a chance that our program may be
stopped and restarted by signals, then we may need to include code to restart these
system calls, even in a program that doesn’t install handlers for the stop signals.
21.6 Summary
In this chapter, we considered a range of factors that affect the operation and
design of signal handlers.
Because signals are not queued, a signal handler must sometimes be coded to
deal with the possibility that multiple events of a particular type have occurred,
even though only one signal was delivered. The issue of reentrancy affects how we
can update global variables and limits the set of functions that we can safely call
from a signal handler.
Instead of returning, a signal handler can terminate in a variety of other ways,
including calling _exit(), terminating the process by sending a signal (kill(), raise(),
or abort()), or performing a nonlocal goto. Using sigsetjmp() and siglongjmp() provides a program with explicit control of the treatment of the process signal mask
when a nonlocal goto is performed.
#include <signal.h>
int siginterrupt(int sig, int flag);
Returns 0 on success, or –1 on error
446 Chapter 21
We can use sigaltstack() to define an alternate signal stack for a process. This is
an area of memory that is used instead of the standard process stack when invoking
a signal handler. An alternate signal stack is useful in cases where the standard
stack has been exhausted by growing too large (at which point the kernel sends a
SIGSEGV signal to the process).
The sigaction() SA_SIGINFO flag allows us to establish a signal handler that
receives additional information about a signal. This information is supplied via a
siginfo_t structure whose address is passed as an argument to the signal handler.
When a signal handler interrupts a blocked system call, the system call fails
with the error EINTR. We can take advantage of this behavior to, for example, set a
timer on a blocking system call. Interrupted system calls can be manually restarted
if desired. Alternatively, establishing the signal handler with the sigaction()
SA_RESTART flag causes many (but not all) system calls to be automatically restarted.


SIGNALS: ADVANCED FEATURES
This chapter completes the discussion of signals that we began in Chapter 20, covering a number of more advanced topics, including the following:
z core dump files;
z special cases regarding signal delivery, disposition, and handling;
z synchronous and asynchronous generation of signals;
z when and in what order signals are delivered;
z interruption of system calls by signal handlers, and how to automatically restart
interrupted system calls;
z realtime signals;
z the use of sigsuspend() to set the process signal mask and wait for a signal to arrive;
z the use of sigwaitinfo() (and sigtimedwait()) to synchronously wait for a signal
to arrive;
z the use of signalfd() to receive a signal via file descriptor; and
z the older BSD and System V signal APIs.
448 Chapter 22
22.1 Core Dump Files
Certain signals cause a process to create a core dump and terminate (Table 20-1,
page 396). A core dump is a file containing a memory image of the process at the
time it terminated. (The term core derives from an old memory technology.) This
memory image can be loaded into a debugger in order to examine the state of a
program’s code and data at the moment when the signal arrived.
One way of causing a program to produce a core dump is to type the quit character (usually Control-\), which causes the SIGQUIT signal to be generated:
$ ulimit -c unlimited Explained in main text
$ sleep 30
Type Control-\
Quit (core dumped)
$ ls -l core Shows core dump file for sleep(1)
-rw------- 1 mtk users 57344 Nov 30 13:39 core
In this example, the message Quit (core dumped) is printed by the shell, which
detects that its child (the process running sleep) was killed by SIGQUIT and did a core
dump.
The core dump file was created in the working directory of the process, with
the name core. This is the default location and name for a core dump file; shortly,
we explain how these defaults can be changed.
Many implementations provide a tool (e.g., gcore on FreeBSD and Solaris) to
obtain a core dump of a running process. Similar functionality is available on
Linux by attaching to a running process using gdb and then using the gcore
command.
Circumstances in which core dump files are not produced
A core dump is not produced in the following circumstances:
z The process doesn’t have permission to write the core dump file. This could
happen because the process doesn’t have write permission for the directory in
which the core dump file is to be created, or because a file with the same name
already exists and either is not writable or is not a regular file (e.g., it is a directory or a symbolic link).
z A regular file with the same name already exists, and is writable, but there is
more than one (hard) link to the file.
z The directory in which the core dump file is to be created doesn’t exist.
z The process resource limit on the size of a core dump file is set to 0. This limit,
RLIMIT_CORE, is discussed in more detail in Section 36.3. In the example above,
we used the ulimit command (limit in the C shell) to ensure that there is no
limit on the size of core files.
z The process resource limit on the size of a file that may be produced by the
process is set to 0. We describe this limit, RLIMIT_FSIZE, in Section 36.3.
z The binary executable file that the process is executing doesn’t have read permission enabled. This prevents users from using a core dump to obtain a copy
of the code of a program that they would otherwise be unable to read.
Signals: Advanced Features 449
z The file system on which the current working directory resides is mounted
read-only, is full, or has run out of i-nodes. Alternatively, the user has reached
their quota limit on the file system.
z Set-user-ID (set-group-ID) programs executed by a user other than the file
owner (group owner) don’t generate core dumps. This prevents malicious
users from dumping the memory of a secure program and examining it for
sensitive information such as passwords.
Using the PR_SET_DUMPABLE operation of the Linux-specific prctl() system call, we
can set the dumpable flag for a process, so that when a set-user-ID (set-groupID) program is run by a user other than the owner (group owner), a core
dump can be produced. The PR_SET_DUMPABLE operation is available from Linux
2.4 onward. See the prctl(2) manual page for further details. In addition, since
kernel 2.6.13, the /proc/sys/fs/suid_dumpable file provides system-wide control
over whether or not set-user-ID and set-group-ID processes produce core
dumps. For details, see the proc(5) manual page.
Since kernel 2.6.23, the Linux-specific /proc/PID/coredump_filter can be used on a
per-process basis to determine which types of memory mappings are written to a core
dump file. (We explain memory mappings in Chapter 49.) The value in this file is a
mask of four bits corresponding to the four types of memory mappings: private
anonymous mappings, private file mappings, shared anonymous mappings, and
shared file mappings. The default value of the file provides traditional Linux behavior: only private anonymous and shared anonymous mappings are dumped. See
the core(5) manual page for further details.
Naming the core dump file: /proc/sys/kernel/core_pattern
Starting with Linux 2.6, the format string contained in the Linux-specific /proc/sys/
kernel/core_pattern file controls the naming of all core dump files produced on the
system. By default, this file contains the string core. A privileged user can define this
file to include any of the format specifiers shown in Table 22-1. These format specifiers are replaced by the value indicated in the right column of the table. Additionally, the string may include slashes (/). In other words, we can control not just the
name of the core file, but also the (absolute or relative) directory in which it is created. After all format specifiers have been replaced, the resulting pathname string
is truncated to a maximum of 128 characters (64 characters before Linux 2.6.19).
Since kernel 2.6.19, Linux supports an additional syntax in the core_pattern file.
If this file contains a string starting with the pipe symbol (|), then the remaining
characters in the file are interpreted as a program—with optional arguments that
may include the % specifiers shown in Table 22-1—that is to be executed when a process dumps core. The core dump is written to the standard input of that program
instead of to a file. See the core(5) manual page for further details.
Some other UNIX implementations provide facilities similar to core_pattern.
For example, in BSD derivatives, the program name is appended to the filename, thus core.progname. Solaris provides a tool (coreadm) that allows the user
to choose the filename and directory where core dump files are placed.
450 Chapter 22
22.2 Special Cases for Delivery, Disposition, and Handling
For certain signals, special rules apply regarding delivery, disposition, and handling, as described in this section.
SIGKILL and SIGSTOP
It is not possible to change the default action for SIGKILL, which always terminates a
process, and SIGSTOP, which always stops a process. Both signal() and sigaction()
return an error on attempts to change the disposition of these signals. These two
signals also can’t be blocked. This is a deliberate design decision. Disallowing
changes to the default actions of these signals means that they can always be used
to kill or stop a runaway process.
SIGCONT and stop signals
As noted earlier, the SIGCONT signal is used to continue a process previously stopped
by one of the stop signals (SIGSTOP, SIGTSTP, SIGTTIN, and SIGTTOU). Because of their
unique purpose, in certain situations the kernel deals with these signals differently
from other signals.
If a process is currently stopped, the arrival of a SIGCONT signal always causes the
process to resume, even if the process is currently blocking or ignoring SIGCONT.
This feature is necessary because it would otherwise be impossible to resume such
stopped processes. (If the stopped process was blocking SIGCONT, and had established a handler for SIGCONT, then, after the process is resumed, the handler is
invoked only when SIGCONT is later unblocked.)
If any other signal is sent to a stopped process, the signal is not actually delivered
to the process until it is resumed via receipt of a SIGCONT signal. The one exception is SIGKILL, which always kills a process—even one that is currently stopped.
Whenever SIGCONT is delivered to a process, any pending stop signals for the process
are discarded (i.e., the process never sees them). Conversely, if any of the stop signals
is delivered to a process, then any pending SIGCONT signal is automatically discarded.
These steps are taken in order to prevent the action of a SIGCONT signal from being
subsequently undone by a stop signal that was actually sent beforehand, and vice versa.
Table 22-1: Format specifiers for /proc/sys/kernel/core_pattern
Specifier Replaced by
%c Core file size soft resource limit (bytes; since Linux 2.6.24)
%e Executable filename (without path prefix)
%g Real group ID of dumped process
%h Name of host system
%p Process ID of dumped process
%s Number of signal that terminated process
%t Time of dump, in seconds since the Epoch
%u Real user ID of dumped process
%% A single % character
Signals: Advanced Features 451
Don’t change the disposition of ignored terminal-generated signals
If, at the time it was execed, a program finds that the disposition of a terminalgenerated signals has been set to SIG_IGN (ignore), then generally the program
should not attempt to change the disposition of the signal. This is not a rule
enforced by the system, but rather a convention that should be followed when writing applications. We explain the reasons for this in Section 34.7.3. The signals for
which this convention is relevant are SIGHUP, SIGINT, SIGQUIT, SIGTTIN, SIGTTOU, and
SIGTSTP.
22.3 Interruptible and Uninterruptible Process Sleep States
We need to add a proviso to our earlier statement that SIGKILL and SIGSTOP always
act immediately on a process. At various times, the kernel may put a process to
sleep, and two sleep states are distinguished:
z TASK_INTERRUPTIBLE: The process is waiting for some event. For example, it is
waiting for terminal input, for data to be written to a currently empty pipe, or
for the value of a System V semaphore to be increased. A process may spend
an arbitrary length of time in this state. If a signal is generated for a process in
this state, then the operation is interrupted and the process is woken up by the
delivery of a signal. When listed by ps(1), processes in the TASK_INTERRUPTIBLE
state are marked by the letter S in the STAT (process state) field.
z TASK_UNINTERRUPTIBLE: The process is waiting on certain special classes of event,
such as the completion of a disk I/O. If a signal is generated for a process in
this state, then the signal is not delivered until the process emerges from this
state. Processes in the TASK_UNINTERRUPTIBLE state are listed by ps(1) with a D in
the STAT field.
Because a process normally spends only very brief periods in the TASK_UNINTERRUPTIBLE
state, the fact that a signal is delivered only when the process leaves this state is
invisible. However, in rare circumstances, a process may remain hung in this state,
perhaps as the result of a hardware failure, an NFS problem, or a kernel bug. In
such cases, SIGKILL won’t terminate the hung process. If the underlying problem
can’t otherwise be resolved, then we must restart the system in order to eliminate
the process.
The TASK_INTERRUPTIBLE and TASK_UNINTERRUPTIBLE states are present on most
UNIX implementations. Starting with kernel 2.6.25, Linux adds a third state to
address the hanging process problem just described:
z TASK_KILLABLE: This state is like TASK_UNINTERRUPTIBLE, but wakes the process if a
fatal signal (i.e., one that would kill the process) is received. By converting relevant parts of the kernel code to use this state, various scenarios where a hung
process requires a system restart can be avoided. Instead, the process can be
killed by sending it a fatal signal. The first piece of kernel code to be converted
to use TASK_KILLABLE was NFS.
452 Chapter 22
22.4 Hardware-Generated Signals
SIGBUS, SIGFPE, SIGILL, and SIGSEGV can be generated as a consequence of a hardware
exception or, less usually, by being sent by kill(). In the case of a hardware exception, SUSv3 specifies that the behavior of a process is undefined if it returns from a
handler for the signal, or if it ignores or blocks the signal. The reasons for this are
as follows:
z Returning from the signal handler: Suppose that a machine-language instruction
generates one of these signals, and a signal handler is consequently invoked.
On normal return from the handler, the program attempts to resume execution at the point where it was interrupted. But this is the very instruction that
generated the signal in the first place, so the signal is generated once more.
The consequence is usually that the program goes into an infinite loop, repeatedly calling the signal handler.
z Ignoring the signal: It makes little sense to ignore a hardware-generated signal,
as it is unclear how a program should continue execution after, say, an arithmetic exception. When one of these signals is generated as a consequence of a
hardware exception, Linux forces its delivery, even if the program has
requested that the signal be ignored.
z Blocking the signal: As with the previous case, it makes little sense to block a
hardware-generated signal, as it is unclear how a program should then continue execution. On Linux 2.4 and earlier, the kernel simply ignores attempts
to block a hardware-generated signal; the signal is delivered to the process anyway, and then either terminates the process or is caught by a signal handler, if
one has been established. Starting with Linux 2.6, if the signal is blocked, then
the process is always immediately killed by that signal, even if the process has
installed a handler for the signal. (The rationale for the Linux 2.6 change in the
treatment of blocked hardware-generated signals was that the Linux 2.4 behavior hid bugs and could cause deadlocks in threaded programs.)
The signals/demo_SIGFPE.c program in the source code distribution for this
book can be used to demonstrate the results of ignoring or blocking SIGFPE or
catching the signal with a handler that performs a normal return.
The correct way to deal with hardware-generated signals is either to accept their
default action (process termination) or to write handlers that don’t perform a normal return. Other than returning normally, a handler can complete execution by
calling _exit() to terminate the process or by calling siglongjmp() (Section 21.2.1) to
ensure that control passes to some point in the program other than the instruction
that generated the signal.
22.5 Synchronous and Asynchronous Signal Generation
We have already seen that a process generally can’t predict when it will receive a
signal. We now need to qualify this observation by distinguishing between
synchronous and asynchronous signal generation.
Signals: Advanced Features 453
The model we have implicitly considered so far is asynchronous signal generation, in which the signal is sent either by another process or generated by the kernel
for an event that occurs independently of the execution of the process (e.g., the
user types the interrupt character or a child of this process terminates). For asynchronously generated signals, the earlier statement that a process can’t predict
when the signal will be delivered holds true.
However, in some cases, a signal is generated while the process itself is executing. We have already seen two examples of this:
z The hardware-generated signals (SIGBUS, SIGFPE, SIGILL, SIGSEGV, and SIGEMT)
described in Section 22.4 are generated as a consequence of executing a specific
machine-language instruction that results in a hardware exception.
z A process can use raise(), kill(), or killpg() to send a signal to itself.
In these cases, the generation of the signal is synchronous—the signal is delivered
immediately (unless it is blocked, but see Section 22.4 for a discussion of what happens
when blocking hardware-generated signals). In other words, the earlier statement
about the unpredictability of the delivery of a signal doesn’t apply. For synchronously generated signals, delivery is predictable and reproducible.
Note that synchronicity is an attribute of how a signal is generated, rather than
of the signal itself. All signals may be generated synchronously (e.g., when a process sends itself a signal using kill()) or asynchronously (e.g., when the signal is sent
by another process using kill()).
22.6 Timing and Order of Signal Delivery
As the first topic of this section, we consider exactly when a pending signal is delivered. We then consider what happens if multiple pending blocked signals are
simultaneously unblocked.
When is a signal delivered?
As noted in Section 22.5, synchronously generated signals are delivered immediately. For example, a hardware exception triggers an immediate signal, and when a
process sends itself a signal using raise(), the signal is delivered before the raise()
call returns.
When a signal is generated asynchronously, there may be a (small) delay while
the signal is pending between the time when it was generated and the time it is
actually delivered, even if we have not blocked the signal. The reason for this is that
the kernel delivers a pending signal to a process only at the next switch from kernel
mode to user mode while executing that process. In practice, this means the signal
is delivered at one of the following times:
z when the process is rescheduled after it earlier timed out (i.e., at the start of a
time slice); or
z at completion of a system call (delivery of the signal may cause a blocking system call to complete prematurely).
454 Chapter 22
Order of delivery of multiple unblocked signals
If a process has multiple pending signals that are unblocked using sigprocmask(),
then all of these signals are immediately delivered to the process.
As currently implemented, the Linux kernel delivers the signals in ascending
order. For example, if pending SIGINT (signal 2) and SIGQUIT (signal 3) signals were
both simultaneously unblocked, then the SIGINT signal would be delivered before
SIGQUIT, regardless of the order in which the two signals were generated.
We can’t, however, rely on (standard) signals being delivered in any particular
order, since SUSv3 says that the delivery order of multiple signals is implementationdefined. (This statement applies only to standard signals. As we’ll see in Section 22.8,
the standards governing realtime signals do provide guarantees about the order in
which multiple unblocked realtime signals are delivered.)
When multiple unblocked signals are awaiting delivery, if a switch between
kernel mode and user mode occurs during the execution of a signal handler, then
the execution of that handler will be interrupted by the invocation of a second signal
handler (and so on), as shown in Figure 22-1.
Figure 22-1: Delivery of multiple unblocked signals
22.7 Implementation and Portability of signal()
In this section, we show how to implement signal() using sigaction(). The implementation is straightforward, but needs to account for the fact that, historically and
across different UNIX implementations, signal() has had different semantics. In
particular, early implementations of signals were unreliable, meaning that:
z On entry to a signal handler, the disposition of the signal was reset to its
default. (This corresponds to the SA_RESETHAND flag described in Section 20.13.)
In order to have the signal handler invoked again for a subsequent delivery of
the same signal, the programmer needed to make a call to signal() from within the
handler to explicitly reestablish the handler. The problem in this scenario is
that there is a small window of time between entering the signal handler and
reestablishment of the handler, during which, if the signal arrives a second
time, it would be processed according to its default disposition.
Main program
return
SIGINT
handler
2 4
3
flow of execution
1
return
SIGQUIT
handler
1. Pending SIGINT and SIGQUIT unblocked
2. Kernel invokes handler for SIGINT
3. SIGINT handler makes a system call
4. Kernel invokes handler for SIGQUIT
Signals: Advanced Features 455
z Delivery of further occurrences of a signal was not blocked during execution
of a signal handler. (This corresponds to the SA_NODEFER flag described in Section 20.13.) This meant that if the signal was delivered again while the handler
was still executing, then the handler would be recursively invoked. Given a sufficiently rapid stream of signals, the resulting recursive invocations of the handler could overflow the stack.
As well as being unreliable, early UNIX implementations did not provide automatic restarting of system calls (i.e., the behavior described for the SA_RESTART flag in
Section 21.5).
The 4.2BSD reliable signals implementation rectified these limitations, and
several other UNIX implementations followed suit. However, the older semantics
live on today in the System V implementation of signal(), and even contemporary
standards such as SUSv3 and C99 leave these aspects of signal() deliberately
unspecified.
Tying the above information together, we implement signal() as shown in Listing 22-1. By default, this implementation provides the modern signal semantics. If
compiled with –DOLD_SIGNAL, then it provides the earlier unreliable signal
semantics and doesn’t enable automatic restarting of system calls.
Listing 22-1: An implementation of signal()
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––signals/signal.c
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t
signal(int sig, sighandler_t handler)
{
 struct sigaction newDisp, prevDisp;
 newDisp.sa_handler = handler;
 sigemptyset(&newDisp.sa_mask);
#ifdef OLD_SIGNAL
 newDisp.sa_flags = SA_RESETHAND | SA_NODEFER;
#else
 newDisp.sa_flags = SA_RESTART;
#endif
 if (sigaction(sig, &newDisp, &prevDisp) == -1)
 return SIG_ERR;
 else
 return prevDisp.sa_handler;
}
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––signals/signal.c
Some glibc details
The glibc implementation of the signal() library function has changed over time. In
newer versions of the library (glibc 2 and later), the modern semantics are provided
456 Chapter 22
by default. In older versions of the library, the earlier unreliable (System V-compatible)
semantics are provided.
The Linux kernel contains an implementation of signal() as a system call. This
implementation provides the older, unreliable semantics. However, glibc
bypasses this system call by providing a signal() library function that calls
sigaction().
If we want to obtain unreliable signal semantics with modern versions of glibc, we
can explicitly replace our calls to signal() with calls to the (nonstandard) sysv_signal()
function.
The sysv_signal() function takes the same arguments as signal().
If the _BSD_SOURCE feature test macro is not defined when compiling a program,
glibc implicitly redefines all calls to signal() to be calls to sysv_signal(), meaning that
signal() has unreliable semantics. By default, _BSD_SOURCE is defined, but it is disabled
(unless also explicitly defined) if other feature test macros such as _SVID_SOURCE or
_XOPEN_SOURCE are defined when compiling a program.
sigaction() is the preferred API for establishing a signal handler
Because of the System V versus BSD (and old versus recent glibc) portability issues
described above, it is good practice always to use sigaction(), rather than signal(), to
establish signal handlers. We follow this practice throughout the remainder of this
book. (An alternative is to write our own version of signal(), probably similar to Listing 22-1, specifying exactly the flags that we require, and employ that version with
our applications.) Note, however, that it is portable (and shorter) to use signal() to set
the disposition of a signal to SIG_IGN or SIG_DFL, and we’ll often use signal() for that
purpose.
22.8 Realtime Signals
Realtime signals were defined in POSIX.1b to remedy a number of limitations of
standard signals. They have the following advantages over standard signals:
z Realtime signals provide an increased range of signals that can be used for
application-defined purposes. Only two standard signals are freely available for
application-defined purposes: SIGUSR1 and SIGUSR2.
z Realtime signals are queued. If multiple instances of a realtime signal are sent
to a process, then the signal is delivered multiple times. By contrast, if we send
further instances of a standard signal that is already pending for a process, that
signal is delivered only once.
#define _GNU_SOURCE
#include <signal.h>
void ( *sysv_signal(int sig, void (*handler)(int)) ) (int);
Returns previous signal disposition on success, or SIG_ERR on error
Signals: Advanced Features 457
z When sending a realtime signal, it is possible to specify data (an integer or
pointer value) that accompanies the signal. The signal handler in the receiving
process can retrieve this data.
z The order of delivery of different realtime signals is guaranteed. If multiple different realtime signals are pending, then the lowest-numbered signal is delivered first. In other words, signals are prioritized, with lower-numbered signals
having higher priority. When multiple signals of the same type are queued,
they are delivered—along with their accompanying data—in the order in which
they were sent.
SUSv3 requires that an implementation provide a minimum of _POSIX_RTSIG_MAX
(defined as 8) different realtime signals. The Linux kernel defines 32 different realtime signals, numbered from 32 to 63. The <signal.h> header file defines the constant RTSIG_MAX to indicate the number of available realtime signals, and the
constants SIGRTMIN and SIGRTMAX to indicate the lowest and highest available realtime
signal numbers.
On systems employing the LinuxThreads threading implementation, SIGRTMIN
is defined as 35 (rather than 32) to allow for the fact that LinuxThreads makes
internal use of the first three realtime signals. On systems employing the
NPTL threading implementation, SIGRTMIN is defined as 34 to allow for the fact
that NPTL makes internal use of the first two realtime signals.
Realtime signals are not individually identified by different constants in the manner of standard signals. However, an application should not hard-code integer values for them, since the range used for realtime signals varies across UNIX
implementations. Instead, a realtime signal number can be referred to by adding a
value to SIGRTMIN; for example, the expression (SIGRTMIN + 1) refers to the second
realtime signal.
Be aware that SUSv3 doesn’t require SIGRTMAX and SIGRTMIN to be simple integer
values. They may be defined as functions (as they are on Linux). This means that
we can’t write code for the preprocessor such as the following:
#if SIGRTMIN+100 > SIGRTMAX /* WRONG! */
#error "Not enough realtime signals"
#endif
Instead, we must perform equivalent checks at run time.
Limits on the number of queued realtime signals
Queuing realtime signals (with associated data) requires that the kernel maintain
data structures listing the signals queued to each process. Since these data structures consume kernel memory, the kernel places limits on the number of realtime
signals that may be queued.
SUSv3 allows an implementation to place an upper limit on the number of realtime signals (of all types) that may be queued to a process, and requires that this
limit be at least _POSIX_SIGQUEUE_MAX (defined as 32). An implementation can define
the constant SIGQUEUE_MAX to indicate the number of realtime signals it allows to be
queued. It can also make this information available through the following call:
lim = sysconf(_SC_SIGQUEUE_MAX);
458 Chapter 22
On Linux, this call returns –1. The reason for this is that Linux employs a different
model for limiting the number of realtime signals that may be queued to a process. In
Linux versions up to and including 2.6.7, the kernel enforces a system-wide limit on the
total number of realtime signals that may be queued to all processes. This limit can be
viewed and (with privilege) changed via the Linux-specific /proc/sys/kernel/rtsig-max
file. The default value in this file is 1024. The number of currently queued realtime signals can be found in the Linux-specific /proc/sys/kernel/rtsig-nr file.
Starting with Linux 2.6.8, this model was changed, and the aforementioned /proc
interfaces were removed. Under the new model, the RLIMIT_SIGPENDING soft resource
limit defines a limit on the number of signals that can be queued to all processes
owned by a particular real user ID. We describe this limit further in Section 36.3.
Using realtime signals
In order for a pair of processes to send and receive realtime signals, SUSv3
requires the following:
z The sending process sends the signal plus its accompanying data using the
sigqueue() system call.
A realtime signal can also be sent using kill(), killpg(), and raise(). However,
SUSv3 leaves it as implementation-dependent whether realtime signals sent
using these interfaces are queued. On Linux, these interfaces do queue realtime signals, but on many other UNIX implementations, they do not.
z The receiving process establishes a handler for the signal using a call to
sigaction() that specifies the SA_SIGINFO flag. This causes the signal handler to be
invoked with additional arguments, one of which includes the data accompanying the realtime signal.
On Linux, it is possible to queue realtime signals even if the receiving process
doesn’t specify the SA_SIGINFO flag when establishing the signal handler
(although it is not then possible to obtain the data associated with the signal in
this case). However, SUSv3 doesn’t require implementations to guarantee this
behavior, so we can’t portably rely on it.
22.8.1 Sending Realtime Signals
The sigqueue() system call sends the realtime signal specified by sig to the process
specified by pid.
The same permissions are required to send a signal using sigqueue() as are required
with kill() (see Section 20.5). A null signal (i.e., signal 0) can be sent, with the same
meaning as for kill(). (Unlike kill(), we can’t use sigqueue() to send a signal to an
entire process group by specifying a negative value in pid.)
#define _POSIX_C_SOURCE 199309
#include <signal.h>
int sigqueue(pid_t pid, int sig, const union sigval value);
Returns 0 on success, or –1 on error
Signals: Advanced Features 459
Listing 22-2: Using sigqueue() to send realtime signals
–––––––––––––––––––––––––––––––––––––––––––––––––––––– signals/t_sigqueue.c
#define _POSIX_C_SOURCE 199309
#include <signal.h>
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 int sig, numSigs, j, sigData;
 union sigval sv;
 if (argc < 4 || strcmp(argv[1], "--help") == 0)
 usageErr("%s pid sig-num data [num-sigs]\n", argv[0]);
 /* Display our PID and UID, so that they can be compared with the
 corresponding fields of the siginfo_t argument supplied to the
 handler in the receiving process */
 printf("%s: PID is %ld, UID is %ld\n", argv[0],
 (long) getpid(), (long) getuid());
 sig = getInt(argv[2], 0, "sig-num");
 sigData = getInt(argv[3], GN_ANY_BASE, "data");
 numSigs = (argc > 4) ? getInt(argv[4], GN_GT_0, "num-sigs") : 1;
 for (j = 0; j < numSigs; j++) {
 sv.sival_int = sigData + j;
 if (sigqueue(getLong(argv[1], 0, "pid"), sig, sv) == -1)
 errExit("sigqueue %d", j);
 }
 exit(EXIT_SUCCESS);
}
–––––––––––––––––––––––––––––––––––––––––––––––––––––– signals/t_sigqueue.c
The value argument specifies the data to accompany the signal. This argument has
the following form:
union sigval {
 int sival_int; /* Integer value for accompanying data */
 void *sival_ptr; /* Pointer value for accompanying data */
};
The interpretation of this argument is application-dependent, as is the choice of
whether to set the sival_int or the sival_ptr field of the union. The sival_ptr field is
seldom useful with sigqueue(), since a pointer value that is useful in one process is
rarely meaningful in another process. However, this field is useful in other functions
that employ sigval unions, as we’ll see when we consider POSIX timers in Section 23.6
and POSIX message queue notification in Section 52.6.
Several UNIX implementations, including Linux, define a sigval_t data type as a
synonym for union sigval. However, this type is not specified in SUSv3 and is not
available on some implementations. Portable applications should avoid using it.
460 Chapter 22
A call to sigqueue() may fail if the limit on the number of queued signals has been
reached. In this case, errno is set to EAGAIN, indicating that we need to send the signal
again (at some later time when some of the currently queued signals have been
delivered).
An example of the use of sigqueue() is provided in Listing 22-2 (page 459). This
program takes up to four arguments, of which the first three are mandatory: a signal number, a target process ID, and an integer value to accompany the realtime
signal. If more than one instance of the specified signal is to be sent, the optional
fourth argument specifies the number of instances; in this case, the accompanying
integer data value is incremented by one for each successive signal. We demonstrate the use of this program in Section 22.8.2.
22.8.2 Handling Realtime Signals
We can handle realtime signals just like standard signals, using a normal (singleargument) signal handler. Alternatively, we can handle a realtime signal using a
three-argument signal handler established using the SA_SIGINFO flag (Section 21.4).
Here is an example of using SA_SIGINFO to establish a handler for the sixth realtime
signal:
struct sigaction act;
sigemptyset(&act.sa_mask);
act.sa_sigaction = handler;
act.sa_flags = SA_RESTART | SA_SIGINFO;
if (sigaction(SIGRTMIN + 5, &act, NULL) == -1)
 errExit("sigaction");
When we employ the SA_SIGINFO flag, the second argument passed to the signal handler is a siginfo_t structure that contains additional information about the realtime
signal. We described this structure in detail in Section 21.4. For a realtime signal,
the following fields are set in the siginfo_t structure:
z The si_signo field is the same value as is passed in the first argument of the signal handler.
z The si_code field indicates the source of the signal, and contains one of the values
shown in Table 21-2 (page 441). For a realtime signal sent via sigqueue(), this
field always has the value SI_QUEUE.
z The si_value field contains the data specified in the value argument (the sigval
union) by the process that sent the signal using sigqueue(). As noted already, the
interpretation of this data is application-defined. (The si_value field doesn’t
contain valid information if the signal was sent using kill().)
z The si_pid and si_uid fields contain, respectively, the process ID and real user
ID of the process sending the signal.
Listing 22-3 provides an example of handling realtime signals. This program
catches signals and displays various fields from the siginfo_t structure passed to the
signal handler. The program takes two optional integer command-line arguments.
Signals: Advanced Features 461
If the first argument is supplied, the main program blocks all signals, and then
sleeps for the number of seconds specified by this argument. During this time, we
can queue multiple realtime signals to the process and observe what happens when
the signals are unblocked. The second argument specifies the number of seconds
that the signal handler should sleep before returning. Specifying a nonzero value
(the default is 1 second) is useful for slowing down the program so that we can
more easily see what is happening when multiple signals are handled.
We can use the program in Listing 22-3, along with the program in Listing 22-2
(t_sigqueue.c) to explore the behavior of realtime signals, as shown in the following
shell session log:
$ ./catch_rtsigs 60 &
[1] 12842
$ ./catch_rtsigs: PID is 12842 Shell prompt mixed with program output
./catch_rtsigs: signals blocked - sleeping 60 seconds
Press Enter to see next shell prompt
$ ./t_sigqueue 12842 54 100 3 Send signal three times
./t_sigqueue: PID is 12843, UID is 1000
$ ./t_sigqueue 12842 43 200
./t_sigqueue: PID is 12844, UID is 1000
$ ./t_sigqueue 12842 40 300
./t_sigqueue: PID is 12845, UID is 1000
Eventually, the catch_rtsigs program completes sleeping, and displays messages as
the signal handler catches various signals. (We see a shell prompt mixed with the
next line of the program’s output because the catch_rtsigs program is writing output
from the background.) We first observe that realtime signals are delivered lowestnumbered signal first, and that the siginfo_t structure passed to the handler
includes the process ID and user ID of the process that sent the signal:
$ ./catch_rtsigs: sleep complete
caught signal 40
 si_signo=40, si_code=-1 (SI_QUEUE), si_value=300
 si_pid=12845, si_uid=1000
caught signal 43
 si_signo=43, si_code=-1 (SI_QUEUE), si_value=200
 si_pid=12844, si_uid=1000
The remaining output is produced by the three instances of the same realtime signal.
Looking at the si_value values, we can see that these signals were delivered in the
order they were sent:
caught signal 54
 si_signo=54, si_code=-1 (SI_QUEUE), si_value=100
 si_pid=12843, si_uid=1000
caught signal 54
 si_signo=54, si_code=-1 (SI_QUEUE), si_value=101
 si_pid=12843, si_uid=1000
caught signal 54
 si_signo=54, si_code=-1 (SI_QUEUE), si_value=102
 si_pid=12843, si_uid=1000
462 Chapter 22
We continue by using the shell kill command to send a signal to the catch_rtsigs program. As before, we see that the siginfo_t structure received by the handler includes
the process ID and user ID of the sending process, but in this case, the si_code value
is SI_USER:
Press Enter to see next shell prompt
$ echo $$ Display PID of shell
12780
$ kill -40 12842 Uses kill(2) to send a signal
$ caught signal 40
 si_signo=40, si_code=0 (SI_USER), si_value=0
 si_pid=12780, si_uid=1000 PID is that of the shell
Press Enter to see next shell prompt
$ kill 12842 Kill catch_rtsigs by sending SIGTERM
Caught 6 signals
Press Enter to see notification from shell about terminated background job
[1]+ Done ./catch_rtsigs 60
Listing 22-3: Handling realtime signals
––––––––––––––––––––––––––––––––––––––––––––––––––––– signals/catch_rtsigs.c
#define _GNU_SOURCE
#include <string.h>
#include <signal.h>
#include "tlpi_hdr.h"
static volatile int handlerSleepTime;
static volatile int sigCnt = 0; /* Number of signals received */
static volatile int allDone = 0;
static void /* Handler for signals established using SA_SIGINFO */
siginfoHandler(int sig, siginfo_t *si, void *ucontext)
{
 /* UNSAFE: This handler uses non-async-signal-safe functions
 (printf()); see Section 21.1.2) */
 /* SIGINT or SIGTERM can be used to terminate program */
 if (sig == SIGINT || sig == SIGTERM) {
 allDone = 1;
 return;
 }
 sigCnt++;
 printf("caught signal %d\n", sig);
 printf(" si_signo=%d, si_code=%d (%s), ", si->si_signo, si->si_code,
 (si->si_code == SI_USER) ? "SI_USER" :
 (si->si_code == SI_QUEUE) ? "SI_QUEUE" : "other");
 printf("si_value=%d\n", si->si_value.sival_int);
 printf(" si_pid=%ld, si_uid=%ld\n", (long) si->si_pid, (long) si->si_uid);
 sleep(handlerSleepTime);
}
Signals: Advanced Features 463
int
main(int argc, char *argv[])
{
 struct sigaction sa;
 int sig;
 sigset_t prevMask, blockMask;
 if (argc > 1 && strcmp(argv[1], "--help") == 0)
 usageErr("%s [block-time [handler-sleep-time]]\n", argv[0]);
 printf("%s: PID is %ld\n", argv[0], (long) getpid());
 handlerSleepTime = (argc > 2) ?
 getInt(argv[2], GN_NONNEG, "handler-sleep-time") : 1;
 /* Establish handler for most signals. During execution of the handler,
 mask all other signals to prevent handlers recursively interrupting
 each other (which would make the output hard to read). */
 sa.sa_sigaction = siginfoHandler;
 sa.sa_flags = SA_SIGINFO;
 sigfillset(&sa.sa_mask);
 for (sig = 1; sig < NSIG; sig++)
 if (sig != SIGTSTP && sig != SIGQUIT)
 sigaction(sig, &sa, NULL);
 /* Optionally block signals and sleep, allowing signals to be
 sent to us before they are unblocked and handled */
 if (argc > 1) {
 sigfillset(&blockMask);
 sigdelset(&blockMask, SIGINT);
 sigdelset(&blockMask, SIGTERM);
 if (sigprocmask(SIG_SETMASK, &blockMask, &prevMask) == -1)
 errExit("sigprocmask");
 printf("%s: signals blocked - sleeping %s seconds\n", argv[0], argv[1]);
 sleep(getInt(argv[1], GN_GT_0, "block-time"));
 printf("%s: sleep complete\n", argv[0]);
 if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)
 errExit("sigprocmask");
 }
 while (!allDone) /* Wait for incoming signals */
 pause();
}
–––––––––––––––––––––––––––––––––––––––––––––––––––– signals/catch_rtsigs.c
464 Chapter 22
22.9 Waiting for a Signal Using a Mask: sigsuspend()
Before we explain what sigsuspend() does, we first describe a situation where we
need to use it. Consider the following scenario that is sometimes encountered
when programming with signals:
1. We temporarily block a signal so that the handler for the signal doesn’t interrupt the execution of some critical section of code.
2. We unblock the signal, and then suspend execution until the signal is delivered.
In order to do this, we might try using code such as that shown in Listing 22-4.
Listing 22-4: Incorrectly unblocking and waiting for a signal
 sigset_t prevMask, intMask;
 struct sigaction sa;
 sigemptyset(&intMask);
 sigaddset(&intMask, SIGINT);
 sigemptyset(&sa.sa_mask);
 sa.sa_flags = 0;
 sa.sa_handler = handler;
 if (sigaction(SIGINT, &sa, NULL) == -1)
 errExit("sigaction");
 /* Block SIGINT prior to executing critical section. (At this
 point we assume that SIGINT is not already blocked.) */
 if (sigprocmask(SIG_BLOCK, &intMask, &prevMask) == -1)
 errExit("sigprocmask - SIG_BLOCK");
 /* Critical section: do some work here that must not be
 interrupted by the SIGINT handler */
 /* End of critical section - restore old mask to unblock SIGINT */
 if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)
 errExit("sigprocmask - SIG_SETMASK");
 /* BUG: what if SIGINT arrives now... */
 pause(); /* Wait for SIGINT */
There is a problem with the code in Listing 22-4. Suppose that the SIGINT signal is
delivered after execution of the second sigprocmask(), but before the pause() call.
(The signal might actually have been generated at any time during the execution of
the critical section, and then be delivered only when it is unblocked.) Delivery of the
SIGINT signal will cause the handler to be invoked, and after the handler returns
Signals: Advanced Features 465
and the main program resumes, the pause() call will block until a second instance
of SIGINT is delivered. This defeats the purpose of the code, which was to unblock
SIGINT and then wait for its first occurrence.
Even if the likelihood of SIGINT being generated between the start of the critical
section (i.e., the first sigprocmask() call) and the pause() call is small, this nevertheless
constitutes a bug in the above code. This time-dependent bug is an example of a
race condition (Section 5.1). Normally, race conditions occur where two processes
or threads share common resources. However, in this case, the main program is
racing against its own signal handler.
To avoid this problem, we require a means of atomically unblocking a signal
and suspending the process. That is the purpose of the sigsuspend() system call.
The sigsuspend() system call replaces the process signal mask by the signal set
pointed to by mask, and then suspends execution of the process until a signal is
caught and its handler returns. Once the handler returns, sigsuspend() restores the
process signal mask to the value it had prior to the call.
Calling sigsuspend() is equivalent to atomically performing these operations:
sigprocmask(SIG_SETMASK, &mask, &prevMask); /* Assign new mask */
pause();
sigprocmask(SIG_SETMASK, &prevMask, NULL); /* Restore old mask */
Although restoring the old signal mask (i.e., the last step in the above sequence)
may at first appear inconvenient, it is essential to avoid race conditions in situations
where we need to repeatedly wait for signals. In such situations, the signals must
remain blocked except during the sigsuspend() calls. If we later need to unblock the
signals that were blocked prior to the sigsuspend() call, we can employ a further call
to sigprocmask().
When sigsuspend() is interrupted by delivery of a signal, it returns –1, with errno set
to EINTR. If mask doesn’t point to a valid address, sigsuspend() fails with the error EFAULT.
Example program
Listing 22-5 demonstrates the use of sigsuspend(). This program performs the following steps:
z Display the initial value of the process signal mask using the printSigMask()
function (Listing 20-4, on page 408) q.
z Block SIGINT and SIGQUIT, and save the original process signal mask w.
z Establish the same handler for both SIGINT and SIGQUIT e. This handler displays
a message, and, if it was invoked via delivery of SIGQUIT, sets the global variable
gotSigquit.
#include <signal.h>
int sigsuspend(const sigset_t *mask);
(Normally) returns –1 with errno set to EINTR
466 Chapter 22
z Loop until gotSigquit is set r. Each loop iteration performs the following steps:
– Display the current value of the signal mask using our printSigMask() function.
– Simulate a critical section by executing a CPU busy loop for a few seconds.
– Display the mask of pending signals using our printPendingSigs() function
(Listing 20-4).
– Uses sigsuspend() to unblock SIGINT and SIGQUIT and wait for a signal (if one
is not already pending).
z Use sigprocmask() to restore the process signal mask to its original state t, and
then display the signal mask using printSigMask() y.
Listing 22-5: Using sigsuspend()
–––––––––––––––––––––––––––––––––––––––––––––––––––– signals/t_sigsuspend.c
#define _GNU_SOURCE /* Get strsignal() declaration from <string.h> */
#include <string.h>
#include <signal.h>
#include <time.h>
#include "signal_functions.h" /* Declarations of printSigMask()
 and printPendingSigs() */
#include "tlpi_hdr.h"
static volatile sig_atomic_t gotSigquit = 0;
static void
handler(int sig)
{
 printf("Caught signal %d (%s)\n", sig, strsignal(sig));
 /* UNSAFE (see Section 21.1.2) */
 if (sig == SIGQUIT)
 gotSigquit = 1;
}
int
main(int argc, char *argv[])
{
 int loopNum;
 time_t startTime;
 sigset_t origMask, blockMask;
 struct sigaction sa;
q printSigMask(stdout, "Initial signal mask is:\n");
 sigemptyset(&blockMask);
 sigaddset(&blockMask, SIGINT);
 sigaddset(&blockMask, SIGQUIT);
w if (sigprocmask(SIG_BLOCK, &blockMask, &origMask) == -1)
 errExit("sigprocmask - SIG_BLOCK");
 sigemptyset(&sa.sa_mask);
 sa.sa_flags = 0;
 sa.sa_handler = handler;
Signals: Advanced Features 467
e if (sigaction(SIGINT, &sa, NULL) == -1)
 errExit("sigaction");
 if (sigaction(SIGQUIT, &sa, NULL) == -1)
 errExit("sigaction");
r for (loopNum = 1; !gotSigquit; loopNum++) {
 printf("=== LOOP %d\n", loopNum);
 /* Simulate a critical section by delaying a few seconds */
 printSigMask(stdout, "Starting critical section, signal mask is:\n");
 for (startTime = time(NULL); time(NULL) < startTime + 4; )
 continue; /* Run for a few seconds elapsed time */
 printPendingSigs(stdout,
 "Before sigsuspend() - pending signals:\n");
 if (sigsuspend(&origMask) == -1 && errno != EINTR)
 errExit("sigsuspend");
 }
t if (sigprocmask(SIG_SETMASK, &origMask, NULL) == -1)
 errExit("sigprocmask - SIG_SETMASK");
y printSigMask(stdout, "=== Exited loop\nRestored signal mask to:\n");
 /* Do other processing... */
 exit(EXIT_SUCCESS);
}
–––––––––––––––––––––––––––––––––––––––––––––––––––– signals/t_sigsuspend.c
The following shell session log shows an example of what we see when running the
program in Listing 22-5:
$ ./t_sigsuspend
Initial signal mask is:
 <empty signal set>
=== LOOP 1
Starting critical section, signal mask is:
 2 (Interrupt)
 3 (Quit)
Type Control-C; SIGINT is generated, but remains pending because it is blocked
Before sigsuspend() - pending signals:
 2 (Interrupt)
Caught signal 2 (Interrupt) sigsuspend() is called, signals are unblocked
The last line of output appeared when the program called sigsuspend(), which
caused SIGINT to be unblocked. At that point, the signal handler was called and displayed that line of output.
468 Chapter 22
The main program continues its loop:
=== LOOP 2
Starting critical section, signal mask is:
 2 (Interrupt)
 3 (Quit)
Type Control-\ to generate SIGQUIT
Before sigsuspend() - pending signals:
 3 (Quit)
Caught signal 3 (Quit) sigsuspend() is called, signals are unblocked
=== Exited loop Signal handler set gotSigquit
Restored signal mask to:
 <empty signal set>
This time, we typed Control-\, which caused the signal handler to set the gotSigquit
flag, which in turn caused the main program to terminate its loop.
22.10 Synchronously Waiting for a Signal
In Section 22.9, we saw how to use a signal handler plus sigsuspend() to suspend execution of a process until a signal is delivered. However, the need to write a signal
handler and to handle the complexities of asynchronous delivery makes this
approach cumbersome for some applications. Instead, we can use the sigwaitinfo()
system call to synchronously accept a signal.
The sigwaitinfo() system call suspends execution of the process until one of the signals in the signal set pointed to by set is delivered. If one of the signals in set is
already pending at the time of the call, sigwaitinfo() returns immediately. The delivered signal is removed from the process’s list of pending signals, and the signal
number is returned as the function result. If the info argument is not NULL, then it
points to a siginfo_t structure that is initialized to contain the same information provided to a signal handler taking a siginfo_t argument (Section 21.4).
The delivery order and queuing characteristics of signals accepted by
sigwaitinfo() are the same as for signals caught by a signal handler; that is, standard
signals are not queued, and realtime signals are queued and delivered lowest signal
number first.
As well as saving us the extra baggage of writing a signal handler, waiting for
signals using sigwaitinfo() is somewhat faster than the combination of a signal handler plus sigsuspend() (see Exercise 22-3.).
It usually makes sense to use sigwaitinfo() only in conjunction with blocking the
set of signals for which we were interested in waiting. (We can fetch a pending signal
with sigwaitinfo() even while that signal is blocked.) If we fail to do this and a signal
arrives before the first, or between successive calls to sigwaitinfo(), then the signal
will be handled according to its current disposition.
#define _POSIX_C_SOURCE 199309
#include <signal.h>
int sigwaitinfo(const sigset_t *set, siginfo_t *info);
Returns number of delivered signal on success, or –1 on error
Signals: Advanced Features 469
An example of the use of sigwaitinfo() is shown in Listing 22-6. This program
first blocks all signals, then delays for the number of seconds specified in its
optional command-line argument. This allows signals to be sent to the program
before sigwaitinfo(). The program then loops continuously using sigwaitinfo() to
accept incoming signals, until SIGINT or SIGTERM is received.
The following shell session log demonstrates the use of the program in
Listing 22-6. We run the program in the background, specifying that it should
delay 60 seconds before calling sigwaitinfo(), and then send it two signals:
$ ./t_sigwaitinfo 60 &
./t_sigwaitinfo: PID is 3837
./t_sigwaitinfo: signals blocked
./t_sigwaitinfo: about to delay 60 seconds
[1] 3837
$ ./t_sigqueue 3837 43 100 Send signal 43
./t_sigqueue: PID is 3839, UID is 1000
$ ./t_sigqueue 3837 42 200 Send signal 42
./t_sigqueue: PID is 3840, UID is 1000
Eventually, the program completes its sleep interval, and the sigwaitinfo() loop
accepts the queued signals. (We see a shell prompt mixed with the next line of the
program’s output because the t_sigwaitinfo program is writing output from the
background.) As with realtime signals caught with a handler, we see that signals are
delivered lowest number first, and that the siginfo_t structure passed to the signal
handler allows us to obtain the process ID and user ID of the sending process:
$ ./t_sigwaitinfo: finished delay
got signal: 42
 si_signo=42, si_code=-1 (SI_QUEUE), si_value=200
 si_pid=3840, si_uid=1000
got signal: 43
 si_signo=43, si_code=-1 (SI_QUEUE), si_value=100
 si_pid=3839, si_uid=1000
We continue, using the shell kill command to send a signal to the process. This
time, we see that the si_code field is set to SI_USER (instead of SI_QUEUE):
Press Enter to see next shell prompt
$ echo $$ Display PID of shell
3744
$ kill -USR1 3837 Shell sends SIGUSR1 using kill()
$ got signal: 10 Delivery of SIGUSR1
 si_signo=10, si_code=0 (SI_USER), si_value=100
 si_pid=3744, si_uid=1000 3744 is PID of shell
Press Enter to see next shell prompt
$ kill %1 Terminate program with SIGTERM
$
Press Enter to see notification of background job termination
[1]+ Done ./t_sigwaitinfo 60
470 Chapter 22
In the output for the accepted SIGUSR1 signal, we see that the si_value field has the
value 100. This is the value to which the field was initialized by the preceding signal
that was sent using sigqueue(). We noted earlier that the si_value field contains valid
information only for signals sent using sigqueue().
Listing 22-6: Synchronously waiting for a signal with sigwaitinfo()
––––––––––––––––––––––––––––––––––––––––––––––––––– signals/t_sigwaitinfo.c
#define _GNU_SOURCE
#include <string.h>
#include <signal.h>
#include <time.h>
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 int sig;
 siginfo_t si;
 sigset_t allSigs;
 if (argc > 1 && strcmp(argv[1], "--help") == 0)
 usageErr("%s [delay-secs]\n", argv[0]);
 printf("%s: PID is %ld\n", argv[0], (long) getpid());
 /* Block all signals (except SIGKILL and SIGSTOP) */
 sigfillset(&allSigs);
 if (sigprocmask(SIG_SETMASK, &allSigs, NULL) == -1)
 errExit("sigprocmask");
 printf("%s: signals blocked\n", argv[0]);
 if (argc > 1) { /* Delay so that signals can be sent to us */
 printf("%s: about to delay %s seconds\n", argv[0], argv[1]);
 sleep(getInt(argv[1], GN_GT_0, "delay-secs"));
 printf("%s: finished delay\n", argv[0]);
 }
 for (;;) { /* Fetch signals until SIGINT (^C) or SIGTERM */
 sig = sigwaitinfo(&allSigs, &si);
 if (sig == -1)
 errExit("sigwaitinfo");
 if (sig == SIGINT || sig == SIGTERM)
 exit(EXIT_SUCCESS);
 printf("got signal: %d (%s)\n", sig, strsignal(sig));
 printf(" si_signo=%d, si_code=%d (%s), si_value=%d\n",
 si.si_signo, si.si_code,
 (si.si_code == SI_USER) ? "SI_USER" :
 (si.si_code == SI_QUEUE) ? "SI_QUEUE" : "other",
 si.si_value.sival_int);
Signals: Advanced Features 471
 printf(" si_pid=%ld, si_uid=%ld\n",
 (long) si.si_pid, (long) si.si_uid);
 }
}
––––––––––––––––––––––––––––––––––––––––––––––––––– signals/t_sigwaitinfo.c
The sigtimedwait() system call is a variation on sigwaitinfo(). The only difference is
that sigtimedwait() allows us to specify a time limit for waiting.
The timeout argument specifies the maximum time that sigtimedwait() should wait
for a signal. It is a pointer to a structure of the following type:
struct timespec {
 time_t tv_sec; /* Seconds ('time_t' is an integer type) */
 long tv_nsec; /* Nanoseconds */
};
The fields of the timespec structure are filled in to specify the maximum number of
seconds and nanoseconds that sigtimedwait() should wait. Specifying both fields of
the structure as 0 causes an immediate timeout—that is, a poll to check if any of the
specified set of signals is pending. If the call times out without a signal being delivered, sigtimedwait() fails with the error EAGAIN.
If the timeout argument is specified as NULL, then sigtimedwait() is exactly equivalent to sigwaitinfo(). SUSv3 leaves the meaning of a NULL timeout unspecified, and
some UNIX implementations instead interpret this as a poll request that returns
immediately.
22.11 Fetching Signals via a File Descriptor
Starting with kernel 2.6.22, Linux provides the (nonstandard) signalfd() system call,
which creates a special file descriptor from which signals directed to the caller can
be read. The signalfd mechanism provides an alternative to the use of sigwaitinfo()
for synchronously accepting signals.
#define _POSIX_C_SOURCE 199309
#include <signal.h>
int sigtimedwait(const sigset_t *set, siginfo_t *info,
 const struct timespec *timeout);
Returns number of delivered signal on success,
or –1 on error or timeout (EAGAIN)
#include <sys/signalfd.h>
int signalfd(int fd, const sigset_t *mask, int flags);
Returns file descriptor on success, or –1 on error
472 Chapter 22
The mask argument is a signal set that specifies the signals that we want to be able
to read via the signalfd file descriptor. As with sigwaitinfo(), we should normally also
block all of the signals in mask using sigprocmask(), so that the signals don’t get handled according to their default dispositions before we have a chance to read them.
If fd is specified as –1, then signalfd() creates a new file descriptor that can be
used to read the signals in mask; otherwise, it modifies the mask associated with fd,
which must be a file descriptor created by a previous call to signalfd().
In the initial implementation, the flags argument was reserved for future use
and had to be specified as 0. However, since Linux 2.6.27, two flags are supported:
SFD_CLOEXEC
Set the close-on-exec flag (FD_CLOEXEC) for the new file descriptor. This flag
is useful for the same reasons as the open() O_CLOEXEC flag described in
Section 4.3.1.
SFD_NONBLOCK
Set the O_NONBLOCK flag on the underlying open file description, so that
future reads will be nonblocking. This saves additional calls to fcntl() to achieve
the same result.
Having created the file descriptor, we can then read signals from it using read().
The buffer given to read() must be large enough to hold at least one signalfd_siginfo
structure, defined as follows in <sys/signalfd.h>:
struct signalfd_siginfo {
 uint32_t ssi_signo; /* Signal number */
 int32_t ssi_errno; /* Error number (generally unused) */
 int32_t ssi_code; /* Signal code */
 uint32_t ssi_pid; /* Process ID of sending process */
 uint32_t ssi_uid; /* Real user ID of sender */
 int32_t ssi_fd; /* File descriptor (SIGPOLL/SIGIO) */
 uint32_t ssi_tid; /* Kernel timer ID (POSIX timers) */
 uint32_t ssi_band; /* Band event (SIGPOLL/SIGIO) */
 uint32_t ssi_tid; /* (Kernel-internal) timer ID (POSIX timers) */
 uint32_t ssi_overrun; /* Overrun count (POSIX timers) */
 uint32_t ssi_trapno; /* Trap number */
 int32_t ssi_status; /* Exit status or signal (SIGCHLD) */
 int32_t ssi_int; /* Integer sent by sigqueue() */
 uint64_t ssi_ptr; /* Pointer sent by sigqueue() */
 uint64_t ssi_utime; /* User CPU time (SIGCHLD) */
 uint64_t ssi_stime; /* System CPU time (SIGCHLD) */
 uint64_t ssi_addr; /* Address that generated signal
 (hardware-generated signals only) */
};
The fields in this structure return the same information as the similarly named
fields in the traditional siginfo_t structure (Section 21.4).
Each call to read() returns as many signalfd_siginfo structures as there are signals
pending and will fit in the supplied buffer. If no signals are pending at the time of
the call, then read() blocks until a signal arrives. We can also use the fcntl() F_SETFL
Signals: Advanced Features 473
operation (Section 5.3) to set the O_NONBLOCK flag for the file descriptor, so that reads
are nonblocking and will fail with the error EAGAIN if no signals are pending.
When a signal is read from a signalfd file descriptor, it is consumed and ceases
to be pending for the process.
Listing 22-7: Using signalfd() to read signals
–––––––––––––––––––––––––––––––––––––––––––––––––– signals/signalfd_sigval.c
#include <sys/signalfd.h>
#include <signal.h>
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
 sigset_t mask;
 int sfd, j;
 struct signalfd_siginfo fdsi;
 ssize_t s;
 if (argc < 2 || strcmp(argv[1], "--help") == 0)
 usageErr("%s sig-num...\n", argv[0]);
 printf("%s: PID = %ld\n", argv[0], (long) getpid());
 sigemptyset(&mask);
 for (j = 1; j < argc; j++)
 sigaddset(&mask, atoi(argv[j]));
 if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)
 errExit("sigprocmask");
 sfd = signalfd(-1, &mask, 0);
 if (sfd == -1)
 errExit("signalfd");
 for (;;) {
 s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));
 if (s != sizeof(struct signalfd_siginfo))
 errExit("read");
 printf("%s: got signal %d", argv[0], fdsi.ssi_signo);
 if (fdsi.ssi_code == SI_QUEUE) {
 printf("; ssi_pid = %d; ", fdsi.ssi_pid);
 printf("ssi_int = %d", fdsi.ssi_int);
 }
 printf("\n");
 }
}
–––––––––––––––––––––––––––––––––––––––––––––––––– signals/signalfd_sigval.c
474 Chapter 22
A signalfd file descriptor can be monitored along with other descriptors using
select(), poll(), and epoll (described in Chapter 63). Among other uses, this feature provides an alternative to the self-pipe trick described in Section 63.5.2. If signals are
pending, then these techniques indicate the file descriptor as being readable.
When we no longer require a signalfd file descriptor, we should close it, in
order to release the associated kernel resources.
Listing 22-7 (on page 473) demonstrates the use of signalfd(). This program creates a mask of the signal numbers specified in its command-line arguments, blocks
those signals, and then creates a signalfd file descriptor to read those signals. It then
loops, reading signals from the file descriptor and displaying some of the information from the returned signalfd_siginfo structure. In the following shell session, we
run the program in Listing 22-7 in the background and send it a realtime signal
with accompanying data using the program in Listing 22-2 (t_sigqueue.c):
$ ./signalfd_sigval 44 &
./signalfd_sigval: PID = 6267
[1] 6267
$ ./t_sigqueue 6267 44 123 Send signal 44 with data 123 to PID 6267
./t_sigqueue: PID is 6269, UID is 1000
./signalfd_sigval: got signal 44; ssi_pid=6269; ssi_int=123
$ kill %1 Kill program running in background

22.12 Interprocess Communication with Signals
From one viewpoint, we can consider signals as a form of interprocess communication
(IPC). However, signals suffer a number of limitations as an IPC mechanism. First, by
comparison with other methods of IPC that we examine in later chapters, programming with signals is cumbersome and difficult. The reasons for this are as follows:
z The asynchronous nature of signals means that we face various problems,
including reentrancy requirements, race conditions, and the correct handling
of global variables from signal handlers. (Most of these problems do not occur
if we are using sigwaitinfo() or signalfd() to synchronously fetch signals.)
z Standard signals are not queued. Even for realtime signals, there are upper limits
on the number of signals that may be queued. This means that in order to
avoid loss of information, the process receiving the signals must have a method
of informing the sender that it is ready to receive another signal. The most
obvious method of doing this is for the receiver to send a signal to the sender.
A further problem is that signals carry only a limited amount of information: the
signal number, and in the case of realtime signals, a word (an integer or a pointer)
of additional data. This low bandwidth makes signals slow by comparison with
other methods of IPC such as pipes.
As a consequence of the above limitations, signals are rarely used for IPC.
Signals: Advanced Features 475
22.13 Earlier Signal APIs (System V and BSD)
Our discussion of signals has focused on the POSIX signal API. We now briefly
look at the historical APIs provided by System V and BSD. Although all new applications should use the POSIX API, we may encounter these obsolete APIs when
porting (usually older) applications from other UNIX implementations. Because
Linux (like many other UNIX implementations) provides System V and BSD compatibility APIs, often all that is required to port programs using these older APIs is
to recompile them on Linux.
The System V signal API
As noted earlier, one important difference in the System V signal API is that when
a handler is established with signal(), we get the older, unreliable signal semantics.
This means that the signal is not added to the process signal mask, the disposition
of the signal is reset to the default when the handler is called, and system calls are
not automatically restarted.
Below, we briefly describe the functions in the System V signal API. The manual pages provide full details. SUSv3 specifies all of these functions, but notes that
the modern POSIX equivalents are preferred. SUSv4 marks these functions obsolete.
To establish a signal handler with reliable semantics, System V provided the sigset()
call (with a prototype similar to that of signal()). As with signal(), the handler argument for sigset() can be specified as SIG_IGN, SIG_DFL, or the address of a signal handler.
Alternatively, it can be specified as SIG_HOLD, to add the signal to the process signal
mask while leaving the disposition of the signal unchanged.
If handler is specified as anything other than SIG_HOLD, sig is removed from the
process signal mask (i.e., if sig was blocked, it is unblocked).
The sighold() function adds a signal to the process signal mask. The sigrelse() function removes a signal from the signal mask. The sigignore() function sets a signal’s
#define _XOPEN_SOURCE 500
#include <signal.h>
void (*sigset(int sig, void (*handler)(int)))(int);
On success: returns the previous disposition of sig, or SIG_HOLD
if sig was previously blocked; on error –1 is returned
#define _XOPEN_SOURCE 500
#include <signal.h>
int sighold(int sig);
int sigrelse(int sig);
int sigignore(int sig);
All return 0 on success, or –1 on error
int sigpause(int sig);
Always returns –1 with errno set to EINTR
476 Chapter 22
disposition to ignore. The sigpause() function is similar to sigsuspend(), but removes
just one signal from the process signal mask before suspending the process until
the arrival of a signal.
The BSD signal API
The POSIX signal API drew heavily on the 4.2BSD API, so the BSD functions are
mainly direct analogs of those in POSIX.
As with the functions in the System V signal API described above, we present
the prototypes of the functions in the BSD signal API, and briefly explain the operation of each function. Once again, the manual pages provide full details.
The sigvec() function is analogous to sigaction(). The vec and ovec arguments are
pointers to structures of the following type:
struct sigvec {
 void (*sv_handler)();
 int sv_mask;
 int sv_flags;
};
The fields of the sigvec structure correspond closely with those of the sigaction structure. The first notable difference is that the sv_mask field (the analog of sa_mask)
was an integer rather than a sigset_t, which meant that, on 32-bit architectures,
there was a maximum of 31 different signals. The other difference is the use of the
SV_INTERRUPT flag in the sv_flags field (the analog of sa_flags). Since system call
restarting was the default on 4.2BSD, this flag was used to specify that slow system
calls should be interrupted by signal handlers. (This contrasts with the POSIX API,
where we must explicitly specify SA_RESTART in order to enable restarting of system
calls when establishing a signal handler with sigaction().)
#define _BSD_SOURCE
#include <signal.h>
int sigvec(int sig, struct sigvec *vec, struct sigvec *ovec);
Returns 0 on success, or –1 on error
#define _BSD_SOURCE
#include <signal.h>
int sigblock(int mask);
int sigsetmask(int mask);
Both return previous signal mask
int sigpause(int sigmask);
Always returns –1 with errno set to EINTR
int sigmask(sig);
Returns signal mask value with bit sig set
Signals: Advanced Features 477
The sigblock() function adds a set of signals to the process signal mask. It is analogous to the sigprocmask() SIG_BLOCK operation. The sigsetmask() call specifies an absolute value for the signal mask. It is analogous to the sigprocmask() SIG_SETMASK
operation.
The sigpause() function is analogous to sigsuspend(). Note that this function is
defined with different calling signatures in the System V and BSD APIs. The GNU
C library provides the System V version by default, unless we specify the _BSD_SOURCE
feature test macro when compiling a program.
The sigmask() macro turns a signal number into the corresponding 32-bit mask
value. Such bit masks can then be ORed together to create a set of signals, as in the
following:
sigblock(sigmask(SIGINT) | sigmask(SIGQUIT));
22.14 Summary
Certain signals cause a process to create a core dump and terminate. This file contains information that can be used by a debugger to inspect the state of a process at
the time that it terminated. By default, a core dump file is named core, but Linux
provides the /proc/sys/kernel/core_pattern file to control the naming of core dump files.
A signal may be generated asynchronously or synchronously. Asynchronous
generation occurs when a signal is sent a process by the kernel or by another process. A process can’t predict precisely when an asynchronously generated signal
will be delivered. (We noted that asynchronous signals are normally delivered the
next time the receiving process switches from kernel mode to user mode.) Synchronous generation occurs when the process itself executes code that directly generates
the signal—for example, by executing an instruction that causes a hardware exception
or by calling raise(). The delivery of a synchronously generated signal is precisely
predictable (it occurs immediately).
Realtime signals are a POSIX addition to the original signal model, and differ
from standard signals in that they are queued, have a specified delivery order, and
can be sent with an accompanying piece of data. Realtime signals are designed to
be used for application-defined purposes. A realtime signal is sent using the
sigqueue() system call, and an additional argument (the siginfo_t structure) is supplied to the signal handler so that it can obtain the data accompanying the signal, as
well as the process ID and real user ID of the sending process.
The sigsuspend() system call allows a program to atomically modify the process
signal mask and suspend execution until a signal arrives, The atomicity of
sigsuspend() is essential to avoid race conditions when unblocking a signal and then
suspending execution until that signal arrives.
We can use sigwaitinfo() and sigtimedwait() to synchronously wait for a signal.
This saves us the work of designing and writing a signal handler, which may be
unnecessary if our only aim is to wait for the delivery of a signal.
Like sigwaitinfo() and sigtimedwait(), the Linux-specific signalfd() system call can
be used to synchronously wait for a signal. The distinctive feature of this interface
is that signals can be read via a file descriptor. This file descriptor can also be monitored using select(), poll(), and epoll.
478 Chapter 22
Although signals can be viewed as a method of IPC, many factors make them
generally unsuitable for this purpose, including their asynchronous nature, the fact
that they are not queued, and their low bandwidth. More usually, signals are used
as a method of process synchronization and for a variety of other purposes (e.g.,
event notification, job control, and timer expiration).
Although the fundamental signal concepts are straightforward, our discussion
has stretched over three chapters, since there were many details to cover. Signals
play an important role in various parts of the system call API, and we’ll revisit their
use in several later chapters. In addition, various signal-related functions are specific to threads (e.g., pthread_kill() and pthread_sigmask()), and we defer discussion
of these functions until Section 33.2.
