---
title: "Sorting (DRAFT)"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#insertion-sort">Insertion Sort</a>
      </li>
      <li>
        <a href="#selection-sort">Selection Sort</a>
      </li>
      <li>
        <a href="#bubble-sort">Bubble Sort</a>
      </li>
      <li>
        <a href="#merge-sort">Merge Sort</a>
      </li>
      <li>
        <a href="#quick-sort">Quick Sort</a>
      </li>
      <li>
        <a href="#radix-sort">Radix Sort</a>
      </li>
      <li>
        <a href="#resources">Resources</a>
      </li>
		</ul>
	</li>
</ul>



<h3 id="introduction">Introduction</h3>

<p>
  A sorting algorithm is an algorithm that puts elements of a list in a certain order.
</p>



<h3 id="insertion-sort">Insertion Sort</h3>

<p>
  Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms but is efficient for quite small data sets.
</p>


<h4>Procedure</h4>

<p>
  Sorting is typically done in-place, by iterating up the array, growing the sorted list behind it. At each array-position, it checks the value there against the largest value in the sorted list (which happens to be next to it, in the previous array-position checked). If larger, it leaves the element in place and moves to the next. If smaller, it finds the correct position within the sorted list, shifts all the larger values up to make a space, and inserts into that correct position.
</p>

<ol>
  <li>
    Start at the second element in the array.
  </li>
  <li>
    Compare the second element to the first element. 
  </li>
  <li>
    
  </li>
  <li>

  </li>
  <li>

  </li>
</ol>

<p>
  1. The first element in the array is assumed to be sorted. Take the second element and store it separately in key.
  2. Compare key with the first element. If the first element is greater than key, then key is placed in front of the first element.
  3. Now, the first two elements are sorted. Take the third element and compare it with the elements on the left of it. Placed it just behind the element smaller than it. If there is no element smaller than it, then place it at the beginning of the array.
  4. Similarly, place every unsorted element at its correct position.
</p>


<h4>Complexity</h4>

<table>
  <tr>
    <td>Worst case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Best case time</td>
    <td>\(O(n)\)</td>
  </tr>
  <tr>
    <td>Average case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Space</td>
    <td>\(O(1)\)</td>
  </tr>
</table>



<h3 id="selection-sort">Selection Sort</h3>

<p>
  Selection sort is an in-place comparison sorting algorithm. It has an O(n2) time complexity, which makes it inefficient on large lists, and generally performs worse than the similar insertion sort.
</p>


<h4>Procedure</h4>

<p>
  The algorithm divides the input list into two parts: a sorted sublist of items which is built up from left to right at the front (left) of the list and a sublist of the remaining unsorted items that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.
</p>

<p>
  1. Set the first element as minimum.
2. Compare minimum with the second element. If the second element is smaller than minimum, assign the second element as minimum. Compare minimum with the third element. Again, if the third element is smaller, then assign minimum to the third element otherwise do nothing. The process goes on until the last element.
3. After each iteration, minimum is placed in the front of the unsorted list.
4. For each iteration, indexing starts from the first unsorted element. Step 1 to 3 are repeated until all the elements are placed at their correct positions.
</p>


<h4>Complexity</h4>

<table>
  <tr>
    <td>Worst case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Best case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Average case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Space</td>
    <td>\(O(1)\)</td>
  </tr>
</table>




<h3 id="bubble-sort">Bubble Sort</h3>

<p>
  Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements "bubble" to the top of the list.
</p>


<h4>Procedure</h4>

<ol>
  <li>
    Start at the first index of the array.
  </li>
  <li>
    Compare the first and second elements. If the first element is larger than the second element then swap the elements.
  </li>
  <li>
    Compare the second and third elements. If the second element is larger than the third element then swap the elements.
  </li>
  <li>
    Continue to compare elements in this manner until the last unsorted element is reached.
  </li>
  <li>
    Repeat the above process. In each iteration, the largest element among the unsorted elements is placed at the end.
  </li>
  <li>
    The array is sorted when all the unsorted elements are placed at their correct positions.
  </li>
</ol>


<h4>Example</h4>

<p>
  In the following example we sort the array with values \(5, 3, 1, 2, 6, 4\):
</p>

<figure>
  <img src="/img/sorting/bubble-sort.svg" style="max-width: 550px">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>


<h4>Complexity</h4>

<table>
  <tr>
    <td>Worst case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Best case time</td>
    <td>\(O(n)\)</td>
  </tr>
  <tr>
    <td>Average case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Space</td>
    <td>\(O(1)\)</td>
  </tr>
</table>



<h3 id="merge-sort">Merge Sort</h3>

<p>
  Merge sort is an efficient comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the order of equal elements is the same in the input and output. Conceptually, a merge sort works as follows:
</p>

<ol>
  <li>
    Divide the unsorted list into n sub-lists, each containing one element (a list of one element is considered sorted).
  </li>
  <li>
    Repeatedly merge sub-lists to produce new sorted sub-lists until there is only one sub-list remaining. This will be the sorted list.
  </li>
</ol>


<h4>Time Complexity</h4>

<ul>
  <li>
    Best-case performance: \(O(n \log n)\)
  </li>
  <li>
    Average-case performance: \(O(n \log n)\)
  </li>
  <li>
    Worst-case performance: \(O(n \log n)\)
  </li>
  <li>
    Worst-case space complexity: \(О(n)\)
  </li>
</ul>



<h3 id="quick-sort">Quick Sort</h3>

<p>
  Quicksort is a sorting algorithm that works by selecting a pivot element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. This can be done in-place, requiring small additional amounts of memory to perform the sorting.
</p>


<h4>Procedure</h4>

<ol>
  <li>
    Choose the leftmost element as the pivot.
  </li>
  <li>
    Partition the array so that elements less than the pivot come before it and elements larger than the pivot come after it.
  </li>
  <li>
    Recursively apply the above steps to the sub-array of smaller elements and separately to the sub-array of larger elements.
  </li>
  <li>
    Continue until a sub-array of length one or zero is encountered.
  </li>
</ol>

<p>
  To partition the array elements using the Hoare partition scheme we proceed as follows:
</p>

<ol>
  <li>
    Place a left pointer at the leftmost index of the array after the pivot and a right pointer at the rightmost index of the array.
  </li>
  <li>
    Move the left pointer to the right until it reaches an element larger than (or equal to) the pivot.
  </li>
  <li>
    Move the right pointer to the left until it reaches an element smaller than (or equal to) the pivot.
  </li>
  <li>
    Swap the element at the left pointer with the element at the right pointer.
  </li>
  <li>
    Repeat steps 2-4 until the pointers cross each other.
  </li>
  <li>
    Move the pivot to its correct position by swapping it with the element at the right pointer.
  </li>
</ol>


<h4>Complexity</h4>

<table>
  <tr>
    <td>Worst case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Best case time</td>
    <td>\(O(n \log n)\)</td>
  </tr>
  <tr>
    <td>Average case time</td>
    <td>\(O(n \log n)\)</td>
  </tr>
  <tr>
    <td>Space</td>
    <td>\(O(\log n)\)</td>
  </tr>
</table>



<h3 id="radix-sort">Radix Sort</h3>

<p>
  In computer science, radix sort is a non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix. For elements with more than one significant digit, this bucketing process is repeated for each digit, while preserving the ordering of the prior step, until all digits have been considered.

  Radix sort only works when sorting numbers with a fixed number of digits. It won't work for arbitrarily-large numbers.
</p>


<h4>Procedure</h4>

<ol>
  <li>
    Find the largest element in the array and determine the number of digits in this largest element.
  </li>
  <li>
    Use any stable sorting technique to sort the elements based on the unit place digits.
  </li>
  <li>
    Then sort the elements based on digits at tens place.
  </li>
  <li>
    Continue this process for each of number of digits in the largest element.
  </li>
</ol>

<p>
  Any stable sorting algorithm ↴ can be used here. In practice, counting sort works well, since the digits can only take on a small number of values (i.e.: 0 - 9 for base-10 numbers; 0 - 1 for base-2 numbers).

  Notice how whenever there was a tie in the tens place the number with a lower ones digit came first. This is why using a stable sorting algorithm is important. It means that if there's a tie on the current digit we'll fall back to how the numbers were ordered based on the digits we already sorted.
</p>


1. Find out the maximum element (let it be max) from the given array.
2. Initialize an array of length max+1 with all elements 0. This array is used for storing the count of the elements in the array.
3. Store the count of each element at their respective index in count array.
4. Store cumulative sum of the elements of the count array. It helps in placing the elements into the correct index of the sorted array.
5. Find the index of each element of the original array in the count array. This gives the cumulative count. Place the element at the index calculated as shown in figure below.
6. After placing each element at its correct position, decrease its count by one.


<h4>Complexity</h4>

<table>
  <tr>
    <td>Worst case time</td>
    <td>\(O(n)\)</td>
  </tr>
  <tr>
    <td>Best case time</td>
    <td>\(O(n)\)</td>
  </tr>
  <tr>
    <td>Average case time</td>
    <td>\(O(n)\)</td>
  </tr>
  <tr>
    <td>Space</td>
    <td>\(O(n)\)</td>
  </tr>
</table>

<!-- 
  https://www.interviewcake.com/concept/java/radix-sort
-->


<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href=""></a>
  </li>
</ul>


<!-- 
  Insertion Sort

  https://en.wikipedia.org/wiki/Insertion_sort
  https://www.programiz.com/dsa/insertion-sort


  Selection Sort

  https://www.programiz.com/dsa/selection-sort
  https://en.wikipedia.org/wiki/Selection_sort
  https://www.youtube.com/watch?v=g-PGLbMth_g

  
  Bubble Sort

  https://www.youtube.com/watch?v=6Gv8vg0kcHc
  https://www.programiz.com/dsa/bubble-sort
  https://en.wikipedia.org/wiki/Bubble_sort
  https://brilliant.org/wiki/bubble-sort/


  Merge Sort

  https://en.wikipedia.org/wiki/Merge_sort


  Quick Sort

  https://www.youtube.com/watch?v=SLauY6PpjW4
  https://www.youtube.com/watch?v=Hoixgm4-P4M
  https://en.wikipedia.org/wiki/Quicksort
  https://www.hackerearth.com/practice/algorithms/sorting/quick-sort/visualize/
-->
