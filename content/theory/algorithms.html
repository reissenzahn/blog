



<h3 id="floyd-warshall-algorithm">Floyd-Warshall Algorithm</h3>

<p>
  The Floyd-Warshall algorithm finds the shortest path between all pairs of vertices in a directed weighted graph. The algorithm works with positive or negative edge weights (but no negative cycles).
</p>

<p>
  We start by representing our graph as an adjacency matrix m where m[i][j] represents the edge weight of the edge from vertex i to vertex j. If there is no edge from vertex i to vertex j then m[i][j] is set to positive infinity (where ∞ + ∞ = ∞ and x + ∞ = ∞).
</p>

<p>
  The algorithm proceeds by gradually building up all intermediate shortest paths between any given vertices i and j. 
</p>

<p>
  The worst, best and average-case performance of the algorithm is O(n^3) where n is the number of vertices in the graph.
</p>


<h3 id="boyer-moore-majority-vote-algorithm">Boyer-Moore Majority Vote Algorithm</h3>

<p>
  The Boyer-Moore majority vote algorithms finds the majority of a list using linear time and constant space. That is, it finds an element that appears more than ⌊n / 2⌋ times provided the majority exists.
</p>

<p>
  The algorithm proceeds as follows:
</p>

{{% code python %}}def findMajority(list):
  m = null
  i = 0

  for x in list:
    if i == 0:
      m = x
      i = 1
    else if m = x:
      i++
    else:
      i--
  
  return m{{% /code %}}

<p>
  Intuitively, the algorithm uses the fact that there must be more majority elements than other elements so eventually m will be the majority as there are not a sufficient number of other elements to switch m to something else.
</p>

<p>
  This algorithm has O(n) time complexity and, crucially, O(1) space complexity.
</p>

<!-- 
  https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm
  https://leetcode.com/problems/majority-element/
 -->
