---
title: "Algorithms"
date: 2020-09-29
draft: false
---

<ul>

</ul>


<h3 id="binary-search">Binary Search</h3>

<p>
  Binary search finds the position of a target value in a sorted array. The algorithm begins by comparing the target value to the element in the middle of the array. If the target value matches the element, we are done. If the target value is less than the element, then search continues in the lower half of the array. Otherwise, the search continues in the upper half of the array.
</p>

<p>
  Let {{% inline-code %}}arr{{% /inline-code %}} be an array of {{% inline-code %}}n{{% /inline-code %}} sorted values. To search for a target value {{% inline-code %}}t{{% /inline-code %}}, we proceed as follows:
</p>

<ol>
  <li>
    Set {{% inline-code %}}l = 0{{% /inline-code %}} and {{% inline-code %}}r = n - 1{{% /inline-code %}}.
  </li>
  <li>
    If {{% inline-code %}}l < r{{% /inline-code %}} terminate unsuccessfully.
  </li>
  <li>
    Set {{% inline-code %}}m = floor((L+R)/2)){{% /inline-code %}}.
  </li>
  <li>
    If {{% inline-code %}}arr[m] < t{{% /inline-code %}} set {{% inline-code %}}l = m + 1{{% /inline-code %}} and go to step 2.
  </li>
  <li>
    If {{% inline-code %}}arr[m] > t{{% /inline-code %}} set {{% inline-code %}}r = m - 1{{% /inline-code %}} and go to step 2.
  </li>
  <li>
    Otherwise we have {{% inline-code %}}arr[m] == t{{% /inline-code %}} so return {{% inline-code %}}m{{% /inline-code %}}.
  </li>
</ol>

<!-- <p>
  In the following example, we search for 56:
</p>

{{% code text %}}l=0                                         r=9
[7] [14] [19] [27] [31] [38] [45] [56] [63] [72]    (31 < 45)
                   m=4

                        l=5                 r=9
[7] [14] [19] [27] [31] [38] [45] [56] [63] [72]    (56 > 45)
                                  m=7

                        l=5  r=6
[7] [14] [19] [27] [31] [38] [45] [56] [63] [72]    (38 < 45)
                        m=5

                             l=r=6
[7] [14] [19] [27] [31] [38] [45] [56] [63] [72]    Done!
                             m=6{{% /code %}} -->

<!-- The time complexity of binary search is \(O(1)\) in the best case and \(O(\log n)\) in the average and worst-case. The worst-case space complexity is \(O(1)\). -->




<h3 id="floyd-warshall-algorithm">Floyd-Warshall Algorithm</h3>

<p>
  The Floyd-Warshall algorithm finds the shortest path between all pairs of vertices in a directed weighted graph. The algorithm works with positive or negative edge weights (but no negative cycles).
</p>

<p>
  We start by representing our graph as an adjacency matrix m where m[i][j] represents the edge weight of the edge from vertex i to vertex j. If there is no edge from vertex i to vertex j then m[i][j] is set to positive infinity (where ∞ + ∞ = ∞ and x + ∞ = ∞).
</p>

<p>
  The algorithm proceeds by gradually building up all intermediate shortest paths between any given vertices i and j. 
</p>

<p>
  The worst, best and average-case performance of the algorithm is O(n^3) where n is the number of vertices in the graph.
</p>


<h3 id="boyer-moore-majority-vote-algorithm">Boyer-Moore Majority Vote Algorithm</h3>

<p>
  The Boyer-Moore majority vote algorithms finds the majority of a list using linear time and constant space. That is, it finds an element that appears more than ⌊n / 2⌋ times provided the majority exists.
</p>

<p>
  The algorithm proceeds as follows:
</p>

{{% code python %}}def findMajority(list):
  m = null
  i = 0

  for x in list:
    if i == 0:
      m = x
      i = 1
    else if m = x:
      i++
    else:
      i--
  
  return m{{% /code %}}

<p>
  Intuitively, the algorithm uses the fact that there must be more majority elements than other elements so eventually m will be the majority as there are not a sufficient number of other elements to switch m to something else.
</p>

<p>
  This algorithm has O(n) time complexity and, crucially, O(1) space complexity.
</p>

<!-- 
  https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm
  https://leetcode.com/problems/majority-element/
 -->
