---
title: "Trie"
date: 2021-11-24
draft: false
---

<p>
  A trie is a tree data structure that is used to store a set of keys. Typically, these keys will consist of strings and the nodes of the tree will store the individual characters of these strings. Accessing a key is performed by traversing the tree from the root node by following the links between nodes which correspond to the characters in the key.
</p>

<figure>
  <img src="/img/data-structures/trie.svg" height="100%" width="100%" style="max-width: 350px;">
</figure>

<p>
  A trie is a data structure that consists of a search tree that is built from the characters of the string keys that allows the characters of the search key to guide the search. The position of a node in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node and the root is associated with the empty string.
</p>

<p>
  Each node in a trie has \(R\) links which each correspond to one of the \(R\) characters in the given alphabet. A node may also have a corresponding value associated with a given key. Specifically, we store the value associated with each key in the node corresponding to its last character. Nodes with null values exist to facilitate search in the trie and do not correspond to keys.
</p>

<p>
  To search for the value associated with a given key we proceed as follows:
</p>

<ol>
  <li>
    Start at the root node.
  </li>
  <li>
    Follow the link associated with the first character in the key.
  </li>
  <li>
    Follow the link associated with the second character in the key.
  </li>
  <li>
    Continue to follow links in this manner until reaching the last character of the key or a null link.
  </li>
  <li>
    If the value at the node corresponding to the key is not null then return the associated value.
  </li>
  <li>
    Otherwise, if the value is null or the search terminated with a null link then return unsuccessfully.
  </li>
</ol>

<!-- As with binary search trees, we insert by first doing a search: in a trie that means using the characters of the key to guide us down the trie until reaching the last character of the key or a null link. At this point, one of the following two conditions holds:

- We encountered a null link before reaching the last character of the key. In this case, there is no trie node corresponding to the last character in the key, so we need to create nodes for each of the characters in the key not yet encountered and set the value in the last one to the value to be associated with the key.

- We encountered the last character of the key before reaching a null link. In this case, we set that node's value to the value to be associated with the key whether or not that value is null.

In all cases, we examine or create a node in the trie for each key character.

The linked structure (shape) of a trie is independent of the key insertion/ deletion order: there is a unique trie for any given set of keys. -->

<p>
  To remove the value associated with a given key we proceed as follows:
</p>

<ol>
  <li>
    Search for the appropriate node by key and set its associated value to null.
  </li>
  <li>
    If the node has a non-null link to a child then return successfully.
  </li>
  <li>
    Otherwise, if all the links are null, then remove the node from the tree.
  </li>
  <li>
    If removing the node leaves all the links null in its parent, then remove that node.
  </li>
  <li>
    Repeat this process until a parent with a non-null link is found.
  </li>
</ol>


<table>
  <tr>
    <th>Algorithm</th>
    <th>Worst case</th>
  </tr>
  <tr>
    <td>
      Insert
    </td>
    <td>
      \(O(k)\)
    </td>
  </tr>
  <tr>
    <td>
      Search
    </td>
    <td>
      \(O(k)\)
    </td>
  </tr>
  <tr>
    <td>
      Space
    </td>
    <td>
      \(O(n \times k)\)
    </td>
  </tr>
</table>



<h3>Problems</h3>

<ul>
  <li>
    <a href="/leetcode/208">208. Implement Trie</a>
  </li>
</ul>
