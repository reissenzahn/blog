---
title: "Dynamic Programming"
date: 2021-11-24
draft: false
---

<p>
  Dynamic programming refers to simplifying a problem by breaking it down into simpler sub-problems recursively. 
</p>


<h3>Optimal Overlapping Sub-problems</h3>

<p>
  In order to apply dynamic programming to a problem, we require that:
</p>

<ol>
  <li>
    An optimal solution can be constructed from optimal solutions of its sub-problems (optimal substructure).
  </li>
  <li>
    The can be broken down into sub-problems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over (overlapping sub-problems).
  </li>
</ol>

<p>
  The optimal substructures are usually described by means of recursion.
</p>


<h3>Top-down and Bottom-up</h3>

<p>
  Solving each sub-problem only once can be achieved in two ways:
</p>

<ul>
  <li>
    Top-down: If the solution to any problem can be formulated recursively using the solution to its sub-problems, and if its sub-problems are overlapping, then one can easily memoize or store the solutions to the sub-problems in a table. Whenever we attempt to solve a new sub-problem, we first check the table to see if it is already solved. If a solution has been recorded, we can use it directly, otherwise we solve the sub-problem and add its solution to the table.
  </li>
  <li>
    Bottom-up: Once we formulate the solution to a problem recursively as in terms of its sub-problems, we can try reformulating the problem in a bottom-up fashion: try solving the sub-problems first and use their solutions to build-on and arrive at solutions to bigger sub-problems. This is also usually done in a tabular form by iteratively generating solutions to bigger and bigger sub-problems by using the solutions to small sub-problems.
  </li>
</ul>


<h3>Motivating Example: Fibonacci</h3>

<p>
  Calculating the n-th member of the Fibonacci sequence is a typical case where dynamic programming can be applied. Indeed, for the typical recursive approach, notice that if we call, say, fib(5), we produce a call tree that calls the function on the same value many different times.
</p>

{{% code-file file="/static/code/techniques/Fibonacci.java" lang="java" %}}

<p>
  In both the top-down and bottom-up cases, we only calculate, say, fib(2) one time, and then use it to calculate both fib(4) and fib(3), instead of computing it every time either of them is evaluated. Further, given that its fine to forget solutions to sub-problems that will not be used again, the second version of the bottom-up case uses this to only require constant space.

</p>


<h3>Standard Template</h3>

<ol>
  <li>
    Derive a recursive solution to the problem.
  </li>
  <li>
    Analyse sub-problem parameters to see if you can save sub-problem solutions.
  </li>
  <li>
    Memoize by allocating a table to hold stored answers and checking if you have computer an answer before solving recursively.
  </li>
  <li>
    Move to an iterative version.
  </li>
  <li>
    Check if you can optimize for space.
  </li>
</ol>


<h3>Problems</h3>

<ul>
  <li>
    <a href="/leetcode/343/">343. Integer Break</a>
  </li>
</ul>
