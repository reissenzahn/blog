Boyer-Moore Majority Vote Algorithm


<p>
  The Boyer-Moore majority vote algorithms finds the majority of a list using linear time and constant space. That is, it finds an element that appears more than ⌊n / 2⌋ times provided the majority exists.
</p>

<p>
  The algorithm proceeds as follows:
</p>

{{% code python %}}def findMajority(list):
  m = null
  i = 0

  for x in list:
    if i == 0:
      m = x
      i = 1
    else if m = x:
      i++
    else:
      i--
  
  return m{{% /code %}}

<p>
  Intuitively, the algorithm uses the fact that there must be more majority elements than other elements so eventually m will be the majority as there are not a sufficient number of other elements to switch m to something else.
</p>

<p>
  This algorithm has O(n) time complexity and, crucially, O(1) space complexity.
</p>

<!-- 
  https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm
  https://leetcode.com/problems/majority-element/
 -->
