---
title: "Binary Heap"
date: 2021-02-21
draft: false
---


<h3 id="introduction">Introduction</h3>

<p>
  A binary heap is a complete binary tree that satisfies the heap ordering property. A complete tree is such that every level (except possibly the last) is filled with nodes and all nodes in the last level are as far left as possible. The heap ordering property can be one of two variants:
</p>

<ul>
  <li>
    Min-heap: the key of each node is less than or equal to the keys of its children.
  </li>
  <li>
    Max-heap: the key of each node is greater than or equal to the keys of its children.
  </li>
</ul>

<p>
  We will consider the case of the min-heap in <i>figure 1</i> where the minimum value is at the root.
</p>

<figure>
  <img src="/img/data-structures/binary-heap/introduction.svg" style="max-width: 400px">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>



<h3 id="structure">Structure</h3>

<p>
  A binary heap can be represented by storing its level order traversal in an array such that the root node is at index \(0\). Let \(n\) be the number of nodes in the heap and \(i\) be an arbitrary valid index of the array storing the heap. Then a node at index \(i\) has its
</p>

<ul>
  <li>
    left child at index \(2i+1\)
  </li>
  <li>
    right child at index \(2i+2\)
  </li>
  <li>
    parent at index \(\lfloor(i-1)/2\rfloor\)
  </li>
</ul>

<figure>
  <img src="/img/data-structures/binary-heap/structure.svg" style="max-width: 400px">
  <figcaption>
    <i>figure 2</i>
  </figcaption>
</figure>


<h3 id="operations">Operations</h3>

<h4 id="insertion">Insertion</h4>

<p>
  To insert an element into the heap we insert it in the bottom level and percolate up as follows:
</p>

<ol>
  <li>
    Insert the element as a new node at the bottom level of the heap at the leftmost available position.
  </li>
  <li>
    Compare the added node to its parent. If the node is smaller than its parent then swap it with its parent.
  </li>
  <li>
    Repeat step 2 until the parent node is smaller than the inserted node.
  </li>
</ol>

<figure>
  <img src="/img/data-structures/binary-heap/insertion-1.svg" style="max-width: 400px">
  <img src="/img/data-structures/binary-heap/insertion-2.svg" style="max-width: 400px; margin-top: 30px">
  <img src="/img/data-structures/binary-heap/insertion-3.svg" style="max-width: 400px; margin-top: 30px">
  <img src="/img/data-structures/binary-heap/insertion-4.svg" style="max-width: 400px; margin-top: 30px">
  <figcaption>
    <i>figure 3</i>
  </figcaption>
</figure>



<h4 id="extract">Extraction</h4>

<p>
  To extract the node with the minimum element we remove the root node and percolate down as follows:
</p>

<ol>
  <li>
    Remove the root node and replace it with the last element on the last level.
  </li>
  <li>
    If the replacement node is larger than one of its children then swap it with the smaller node.
  </li>
  <li>
    Repeat step 2 until the replacement node does not have any children smaller than it.
  </li>
</ol>


<h3 id="complexity">Complexity</h3>

<table>
  <tr>
    <th>Operation</th>
    <th>Average case</th>
    <th>Worst case</th>
  </tr>
  <tr>
    <td>Insert</td>
    <td>\(O(1)\)</td>
    <td>\(O(\log n)\)</td>
  </tr>
  <tr>
    <td>Extract</td>
    <td>\(O(\log n)\)</td>
    <td>\(O(\log n)\)</td>
  </tr>
  <tr>
    <td>Space</td>
    <td>\(O(n)\)</td>
    <td>\(O(n)\)</td>
  </tr>
</table>

