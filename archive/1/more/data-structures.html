---
title: "Data Structures (DRAFT)"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#resources">Resources</a></li>
		</ul>
	</li>
</ul>


<h3 id="introduction">Introduction</h3>


<h3 id="linked-list">Linked List</h3>

<p>
  A linked list is a data structure that consists of a set of nodes that collectively form a sequence. Each node contains a reference to an element of the list and one or more other nodes in the sequence. The first node is called the head and the last node is called the tail.
</p>

<h4 id="singly-linked-list">Singly Linked List</h4>

<p>
  In a singly linked list, each node contains a reference to the next node in the sequence and a reference to an element of the list. The next reference of the tail points to null.
</p>

<figure>
  <img src="/img/data-structures/singly-linked-list.svg" style="max-width: 380px;">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>


<h4 id="doubly-linked-list">Doubly Linked List</h4>

<p>
  In a doubly linked list, each node contains a reference to the previous node in the sequence, a reference to the next node in the sequence and a reference to an element of the list. The previous reference of the head node and the next reference of the tail point to null.
</p>

<figure>
  <img src="/img/data-structures/doubly-linked-list.svg" style="max-width: 550px;">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>


<h4 id="circularly-linked-list">Circularly Linked List</h4>

<p>
  In a circularly linked list, each node contains a reference to the next node in the sequence and a reference to an element of the list. The next reference of the tail points to the head.
</p>

<figure>
  <img src="/img/data-structures/circularly-linked-list.svg" style="max-width: 330px;">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>


<h4 id="complexity-analysis">Complexity Analysis</h4>

<p>
  Unlike an array, a linked list does not provide constant time access to a particular "index" within the list. If you'd like to find the K-th element in the list, you will need to iterate through K elements. The benefit of a linked list is that you can add and remove items from the beginning of the list in constant time.
</p>


<h3 id="stack">Stack</h3>

<p>
  A stack is a collection of elements that allows values to be inserted and removed on a last in, first out (LIFO) basis. The push operation adds an element at the top of the stack the pop operation removes an element from the top of the stack. Both these operations have \(O(1)\) time complexity as they do not depend on how many elements are in the stack.
</p>

<figure>
  <img src="/img/data-structures/stack.svg" style="max-width: 350px;">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>


<h3 id="stack">Queue</h3>

<p>
  A queue is a collection of elements that allows elements to be inserted and removed on a first in, first out (FIFO) basic. The enqueue operation inserts an element at the rear of the queue and the dequeue operation removes the element at the front of the queue. Both these operations have \(O(1)\) time complexity as they do not depend on how many elements are in the stack.
</p>

<figure>
  <img src="/img/data-structures/queue.svg" style="max-width: 270px;">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>


<h3 id="hash-table">Hash Table</h3>

<h4 id="hash-table-linear-probing">Linear Probing</h4>

<p>
  In linear probing we search sequentially for vacant cells. If the appropriate entry is occupied when we try to insert a data item there, we go to the next entry and then next until we find an empty cell. Following a collision, the find algorithm simply steps along the array looking at each cell in sequence. If it encounters an empty cell before finding the key it's looking for, it knows the search has failed.
</p>

<figure>
  <img src="/img/data-structures/hash-table-linear-probing.svg" style="max-width: 370px;">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>



<h4 id="hash-table-separate-chaining">Separate Chaining</h4>

<p>
  In separate chaining, each bucket is independent, and has some sort of list of entries with the same index. A data item's key is hashed to the index in the usual way, and the item is inserted into the list at that index. Other items that hash to the same index are simply added to the list; there's no need to search for empty cells in the primary array.
</p>

<figure>
  <img src="/img/data-structures/hash-table-separate-chaining.svg" style="max-width: 430px;">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>



<h3 id="binary-heap">Binary Heap</h3>

<p>
  A binary heap is a complete binary tree that satisfies the heap condition: every node's key is smaller than (or equal to) the keys of its children. This weak ordering is sufficient to allow fast removal of the maximum node and fast insertion of new nodes.
</p>

<!-- TODO: difference between min/max heap -->


<h4>Insertion</h4>

<p>
  To insert an element to the heap, we start by adding it at the bottom level of the heap at the leftmost available position. Then, we compare the added element to its parent. If the node is smaller than its parent, then we swap the element with its parent. This bubbling up process is repeated until the parent node is smaller than the inserted node. 
</p>


<h4>Extract</h4>

<p>
  To extract the root element, we remove it and replace it with the last element on the last level. Then, we compare the new root with its children. If the root node is larger than one of its children we swap it with the smaller child node. This bubbling down process is repeated until the children are smaller than the replacement node.
</p>


<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href=""></a>
  </li>
</ul>