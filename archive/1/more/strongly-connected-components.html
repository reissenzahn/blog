---
title: "Strongly Connected Components (DRAFT)"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#resources">Resources</a>
      </li>
		</ul>
	</li>
</ul>


<h3 id="introduction">Introduction</h3>

<!-- 
  A strongly connected component or SCC of a directed graph is a maximal subset S \subseteq V of vertices such that there is a directed path from any vertex in S to any other vertex in S.

  More generally, if you squint, every directed graph can be viewed as a directed acyclic graph built up from its SCCs.
-->

<!-- 
  Strongly Connected Components (SCCs) can be thought of as self-contained cycles within a directed graph where every vertex in a given cycle can reach every other vertex in the same cycle.
 -->


<h3 id="">Tarjan's Algorithm</h3>

Tarjan's algorithm is an algorithm in graph theory for finding the strongly connected components of a directed graph.









<!-- 
  The low-link value of a node is the smallest node id reachable from that node when doing a DFS (including itself).

  Depending on where the DFS starts and the order in which nodes/edges are visited, the low-link values for identifying SCCs could be wrong. As such we maintain an invariant that prevents SCCs from interfering with the low link value of other SCCs.


  The stack invariant
  
  To cope with the random traversal order of the DFS, we maintain a stack of valid nodes from which to update low-link values.

  Nodes are added to the stack of valid nodes as they're explored for the first time.

  Nodes are removed from the stack each time a complete SCC is found.


  low-link update condition

  If u and v are nodes in a graph and we're currently exploring u then our new low-link update condition is that: 

  To update node u's low-link value to node v's low-link value there has to be a path of edges from u to v and node v must be on the stack.
-->

<!-- 
1. Mark the id of each node as unvisited.

2. Start DFS. Upon visiting a node assign it an id and a low-link value. Also mark current nodes as visited and add them to a seen stack.

3. On DFS callback, if the previous node is on the stack then min the current node's low-link value with the last node's low-link value.

4. After visiting all neighbors, if the current node started a connected component then pop nodes off stack until current node is reached.
-->




<h3 class="complexity">Complexity</h3>

<!--
  The Tarjan procedure is called once for each node; the forall statement considers each edge at most once. The algorithm's running time is therefore linear in the number of edges and nodes in G, i.e. O(|V|+|E|).
-->



<h3 class="implementation">Implementation</h3>

<pre><code class="java"></code></pre>


<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan's Algorithm (Wikipedia)</a>
  </li>
  <li>
    <a href="https://www.youtube.com/watch?v=wUgWX0nc4NY">Tarjan's Strongly Connected Component Algorithm (William Fiset)</a>
  </li>
</ul>


<!--
  10 7 Computing Strong Components The Algorithm
  https://www.youtube.com/watch?v=O98hLTYVN3c&list=PLXFMmlk03Dt7Q0xr1PIAriY5623cKiH7V&index=51

  Tarjan's Strongly Connected Component (SCC) Algorithm (UPDATED) | Graph Theory
  https://www.youtube.com/watch?v=wUgWX0nc4NY

  https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm
-->
