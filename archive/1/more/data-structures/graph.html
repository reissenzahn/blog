---
title: "Graph (DRAFT)"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
				<li>
          <a href="#introduction">Introduction</a>
        </li>
				<li>
          <a href="#complexity">Complexity</a>
        </li>
				<li>
          <a href="#resources">Resources</a>
        </li>
		</ul>
	</li>
</ul>


<h3 id="introduction">Introduction</h3>

<p>
  A graph is a data structure that consists of a finite set of vertices \(V\) together with a set of edges \(E\) which each consist of a pair of vertices. These pairs are unordered for an undirected graph and ordered for a directed graph. Each edge may also have an associated weight value.
</p>








<h3 id="adjacency-matrix">Adjacency Matrix</h3>

<p>
  An adjacency matrix is a square matrix used to represent a graph.The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph. The adjacency matrix for a graph with vertex set \(V\) is a square \(|V| \times |V|\) matrix \(A\) such that element \(A_{ij}\) is one when there is an edge from vertex \(i\) to vertex \(j\) and zero when there is no edge. If the graph is undirected then the adjacency matrix is symmetric.
</p>


<!-- 
  https://www.youtube.com/watch?v=9C2cpQZVRBA
  https://en.wikipedia.org/wiki/Adjacency_matrix
-->



<h3 id="adjacency-list">Adjacency List</h3>

<p>
  
</p>

<!-- In graph theory and computer science, an adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a vertex in the graph. This is one of several commonly used representations of graphs for use in computer programs.

Implementation details
An adjacency list representation for a graph associates each vertex in the graph with the collection of its neighboring vertices or edges. There are many variations of this basic idea, differing in the details of how they implement the association between vertices and collections, in how they implement the collections, in whether they include both vertices and edges or only vertices as first class objects, and in what kinds of objects are used to represent the vertices and edges.

An implementation suggested by Guido van Rossum uses a hash table to associate each vertex in a graph with an array of adjacent vertices. In this representation, a vertex may be represented by any hashable object. There is no explicit representation of edges as objects.[1]
Cormen et al. suggest an implementation in which the vertices are represented by index numbers.[2] Their representation uses an array indexed by vertex number, in which the array cell for each vertex points to a singly linked list of the neighboring vertices of that vertex. In this representation, the nodes of the singly linked list may be interpreted as edge objects; however, they do not store the full information about each edge (they only store one of the two endpoints of the edge) and in undirected graphs there will be two different linked list nodes for each edge (one within the lists for each of the two endpoints of the edge).
The object oriented incidence list structure suggested by Goodrich and Tamassia has special classes of vertex objects and edge objects. Each vertex object has an instance variable pointing to a collection object that lists the neighboring edge objects. In turn, each edge object points to the two vertex objects at its endpoints.[3] This version of the adjacency list uses more memory than the version in which adjacent vertices are listed directly, but the existence of explicit edge objects allows it extra flexibility in storing additional information about edges.
Operations
The main operation performed by the adjacency list data structure is to report a list of the neighbors of a given vertex. Using any of the implementations detailed above, this can be performed in constant time per neighbor. In other words, the total time to report all of the neighbors of a vertex v is proportional to the degree of v.

It is also possible, but not as efficient, to use adjacency lists to test whether an edge exists or does not exist between two specified vertices. In an adjacency list in which the neighbors of each vertex are unsorted, testing for the existence of an edge may be performed in time proportional to the minimum degree of the two given vertices, by using a sequential search through the neighbors of this vertex. If the neighbors are represented as a sorted array, binary search may be used instead, taking time proportional to the logarithm of the degree.

Trade-offs
The main alternative to the adjacency list is the adjacency matrix, a matrix whose rows and columns are indexed by vertices and whose cells contain a Boolean value that indicates whether an edge is present between the vertices corresponding to the row and column of the cell. For a sparse graph (one in which most pairs of vertices are not connected by edges) an adjacency list is significantly more space-efficient than an adjacency matrix (stored as a two-dimensional array): the space usage of the adjacency list is proportional to the number of edges and vertices in the graph, while for an adjacency matrix stored in this way the space is proportional to the square of the number of vertices. However, it is possible to store adjacency matrices more space-efficiently, matching the linear space usage of an adjacency list, by using a hash table indexed by pairs of vertices rather than an array.

The other significant difference between adjacency lists and adjacency matrices is in the efficiency of the operations they perform. In an adjacency list, the neighbors of each vertex may be listed efficiently, in time proportional to the degree of the vertex. In an adjacency matrix, this operation takes time proportional to the number of vertices in the graph, which may be significantly higher than the degree. On the other hand, the adjacency matrix allows testing whether two vertices are adjacent to each other in constant time; the adjacency list is slower to support this operation. -->

<!-- 
  https://www.youtube.com/watch?v=k1wraWzqtvQ
  https://www.youtube.com/watch?v=WtfGRS1BsBI
-->


<h3 id="complexity">Complexity</h3>

<table>
  <tr>
    <th>Algorithm</th>
    <th>Average</th>
    <th>Worst</th>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>



<h3 id="implementation">Implementation</h3>

<pre><code class="java"></code></pre>


<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://en.wikipedia.org/wiki/Adjacency_list">Adjacency List (Wikipedia)</a>
  </li>
</ul>

<!-- 
  9 1 Graphs and Minimum Cuts
  https://www.youtube.com/watch?v=4Ih3UhVuEtw&list=PLXFMmlk03Dt7Q0xr1PIAriY5623cKiH7V&index=40

  9 2 Graph Representations
  https://www.youtube.com/watch?v=b-Mfu8dPv9U&list=PLXFMmlk03Dt7Q0xr1PIAriY5623cKiH7V&index=41

  9 3 Random Contraction Algorithm
  https://www.youtube.com/watch?v=c75gg0wicus&list=PLXFMmlk03Dt7Q0xr1PIAriY5623cKiH7V&index=42

  9 4 Analysis of Contraction Algorithm 30 min
  https://www.youtube.com/watch?v=b-_jx2-cK8c&list=PLXFMmlk03Dt7Q0xr1PIAriY5623cKiH7V&index=43
 -->
