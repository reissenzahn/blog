---
title: "Selection Sort (DRAFT)"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#procedure">Procedure</a>
      </li>
      <li>
        <a href="#implementation">Implementation</a>
      </li>
      <li>
        <a href="#complexity">Complexity</a>
      </li>
      <li>
        <a href="#resources">Resources</a>
      </li>
		</ul>
	</li>
</ul>


<h3 id="introduction">Introduction</h3>

<p>
  Selection sort is an in-place comparison sorting algorithm. The algorithm builds up a sorted sub-array from left to right. This is achieved iteratively finding the smallest element in the remaining unsorted sub-array, swapping it with the leftmost unsorted element and moving the boundary of the sorted sub-array one element to the right.
</p>


<h3 id="introduction">Procedure</h3>

<p>
  Selection sort proceeds as follows:
</p>

<ol>
  <li>
    Start at the first element, search the remainder of the array of the smallest element and swap the first element with the smallest element.
  </li>
  <li>
    Move to the second element, search the remainder of the array for the smallest element and swap the second element with the smallest element.
  </li>
  <li>
    Repeat this process until the last element is reached.
  </li>
</ol>



<h3 id="complexity">Implementation</h3>

<pre><code class="java">public class Selection {

  public static void sort(int[] array) {
    if (array == null) {
      return;
    }

    for (int i = 0; i &lt; array.length; i++) {
      int min = i;
      for (int j = i + 1; j &lt; array.length; j++) {
        if (array[j] &lt; array[min]) {
          min = j;
        }
      }
      swap(array, i, min);
    }
  }

  private static void swap(int[] array, int i, int j) {
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }

  public static void main(String[] args) {
    int[] array = { 6, 4, 2, 8, 9, 1, 5, 3, 7 };
    Selection.sort(array);
  }
}</code></pre>



<h3 id="complexity">Complexity</h3>

<table>
  <tr>
    <td>Worst case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Best case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Average case time</td>
    <td>\(O(n^2)\)</td>
  </tr>
  <tr>
    <td>Space</td>
    <td>\(O(1)\)</td>
  </tr>
</table>



<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://en.wikipedia.org/wiki/Selection_sort">Selection Sort (Wikipedia)</a>
  </li>
  <li>
    <a href="https://www.youtube.com/watch?v=g-PGLbMth_g">Selection sort in 3 minutes (YouTube)</a>
  </li>
</ul>


<!-- 
  
Running time is insensitive to input. The process of finding the smallest item on one
pass through the array does not give much information about where the smallest item
might be on the next pass. This property can be disadvantageous in some situations.
For example, the person using the sort client might be surprised to realize that it takes
about as long to run selection sort for an array that is already in order or for an array
with all keys equal as it does for a randomly-ordered array! As we shall see, other algorithms
are better able to take advantage of initial order in the input.

Data movement is minimal. Each of the N exchanges changes the value of two array
entries, so selection sort uses N exchangesâ€”the number of array accesses is a linear
function of the array size. None of the other sorting algorithms that we consider have
this property (most involve linearithmic or quadratic growth).
-->
