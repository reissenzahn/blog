---
title: "Flyweight"
date: 2020-09-29
draft: false
---

<ul>
  <li>
    <a href="#introduction">Introduction</a>
  </li>
  <li>
    <a href="#structure">Structure</a>
  </li>
  <li>
    <a href="#example">Example</a>
  </li>
  <li>
    <a href="#resources">Resources</a>
  </li>
</ul>


<h3 id="introduction">Introduction</h3>

<p>
  The Flyweight Pattern is a structural design pattern that allows an object to minimize its memory usage by sharing common state with other similar objects. The pattern distinguishes between extrinsic state that is unique to the object and intrinsic state that is constant and may be shared. A flyweight object stores the intrinsic state and provides an interface through which extrinsic state can be passed in. The flyweight object may then be reused in different contexts.
</p>

<!-- 
  Flyweight is a structural design pattern that allows programs to support vast quantities of objects by keeping their memory consumption low.

  The pattern achieves it by sharing parts of object state between multiple objects. In other words, the Flyweight saves RAM by caching the same data used by different objects.
-->


<h3 id="structure">Structure</h3>

<figure>
  <img src="/img/design-patterns/flyweight.svg" style="max-width: 530px; width: 100%; height: auto">
</figure>

<ul>
  <li>

  </li>
</ul>


<!--
The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can’t be solved in any other meaningful way.

The Flyweight class contains the portion of the original object’s state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called intrinsic. The state passed to the flyweight’s methods is called extrinsic.

The Context class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.

Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight’s method must also pass appropriate bits of the extrinsic state into the method’s parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.

The Client calculates or stores the extrinsic state of flyweights. From the client’s perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.

The Flyweight Factory manages a pool of existing flyweights. With the factory, clients don’t create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.
-->



<h3 id="example">Example</h3>

<pre><code class="java"></code></pre>



<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://refactoring.guru/design-patterns/flyweight">Flyweight (Refactoring Guru)</a>
  </li>
  <li>
    <a href="https://stackoverflow.com/questions/14425671/what-is-the-difference-between-intrinsic-and-extrinsic-state-as-described-in-fly">Intrinsic vs Extrinsic State (Stack Overflow)</a>
  </li>
</ul>

