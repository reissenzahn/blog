---
title: "C"
date: 2020-09-29
draft: false
---

<ul>
  <li>
    <a href="#hello-world">Hello World</a>
  </li>
  <li>
    <a href="#primitive-types">Primitive Types</a>
  </li>
  <li>
    <a href="#variables">Variables</a>
  </li>
  <li>
    <a href="#pointers">Pointers</a>
  </li>
  <li>
    <a href="#pointer-arithmetic">Pointer Arithmetic</a>
  </li>
  <li>
    <a href="#operators">Operators</a>
  </li>
  <li>
    <a href="#arrays">Arrays</a>
  </li>
  <li>
    <a href="#strings">Strings</a>
  </li>
  <li>
    <a href="#functions">Functions</a>
  </li>
  <li>
    <a href="#variadic-functions">Variadic Functions</a>
  </li>
  <li>
    <a href="#static">Static</a>
  </li>
  <li>
    <a href="#conditionals">Conditionals</a>
  </li>
  <li>
    <a href="#switch">Switch</a>
  </li>
  <li>
    <a href="#iteration">Iteration</a>
  </li>
  <li>
    <a href="#enumerations">Enumerations</a>
  </li>
  <li>
    <a href="#structures">Structures</a>
  </li>
  <li>
    <a href="#unions">Unions</a>
  </li>
  <li>
    <a href="#preprocessor">Preprocessor</a>
  </li>
  <li>
    <a href="#assertions">Assertions</a>
  </li>
  <li>
    <a href="#heap-allocation">Heap Allocation</a>
  </li>
  <li>
    <a href="#resources">Resources</a>
  </li>
</ul>



<h3 id="hello-world">Hello World</h3>

<pre><code class="c">#include &lt;stdio.h>

int main() {
  printf("Hello, C!");
  return 0;
}</code></pre>

<pre><code class="c">#include &lt;stdio.h>

int main(int argc, char* argv[]) {

  for (int i = 0; i &lt; argc; i++) {
    printf("%s\n", argv[i]);`
  }

  return 0;
}
</code></pre>



<h3 id="primitive-types">Primitive Types</h3>

<pre><code class="c">#include &lt;stdbool.h>

// integers
short s = 1;
int i = 2;
long l = 3;

// unsigned integers only store positive numbers
unsigned int u = 42;

// floating point
float f = 3.14159;   // single-precision
double d = 2.71828;  // double-precision

// character (single byte)
char c = 'A';

// boolean
bool b = true;</code></pre>



<h3 id="variables">Variables</h3>



<h3 id="pointers">Pointers</h3>

<pre><code class="c">#include &lt;stdio.h>

int i = 1;

// a pointer is a variable that contains the address of a variable
int *ptr;

// the & operator gives the address of an object in memory
ptr = &amp;i;
printf("%p\n", (void*) ptr);  // 000000000064fe10

// the * operator dereferences a pointer
*ptr = *ptr + 1;
printf("%d\n", *ptr);  // 2</code></pre>

<pre><code class="c">#include &lt;stdio.h>

void swap(int *p, int *q) {
  int temp;

  temp = *p;
  *p = *q;
  *q = temp;
}

// ...

int i = 1, j = 2;

swap(&amp;i, &amp;j);

printf("%d\n", i);  // 2
printf("%d\n", j);  // 1</code></pre>



<h3 id="pointer-arithmetic">Pointer Arithmetic</h3>

<pre><code class="c">// there is a strong relationship between pointers and arrays

int arr[5];

for (int i = 0; i &lt; 5; i++) {
  arr[i] = i;
}
  
// any operation that can be achieved by array subscripting can also be done with pointers  
int *ptr;

// set ptr to point to the first element of arr
ptr = &arr[0];

// the name of an array is a synonym for the location of the initial element
ptr = arr;

// ptr + i points to the i-th object beyond ptr
printf("%d\n", *(ptr + 0));  // 0
printf("%d\n", *(ptr + 1));  // 1
printf("%d\n", *(ptr + 2));  // 2
printf("%d\n", *(ptr + 3));  // 3
printf("%d\n", *(ptr + 4));  // 4</code></pre>

<pre><code class="c">
// pointer arithmetic and array subscripting
int arr[] = {0, 1, 2, 3, 4, 5};
int n = 2;

int* ptr = arr;

printf("addr = %p, val = %d\n", (void*) (ptr + n), *(ptr + n));
printf("addr = %p, val = %d\n", (void*) &ptr[n], ptr[n]);
printf("addr = %p, val = %d\n", (void*) &n[ptr], n[ptr]);

// array subscripting and pointer arithmetic work on both arrays any pointers
int arr[] = {0, 1, 2, 3, 4, 5};
int* ptr = arr;

printf("%d\n", arr[2]);  // 2
printf("%d\n", ptr[2]);  // 2

printf("%d\n", *(arr + 2));  // 2
printf("%d\n", *(ptr + 2));  // 2

// we can use a char* to point to the bytes of an int
int x = 0x04030201;
char* ptr = &amp;x;

printf("byte 1: addr = %p, val = %d\n", (void*) ptr, *ptr);
printf("byte 2: addr = %p, val = %d\n", (void*) (ptr + 1), *(ptr + 1));
printf("byte 3: addr = %p, val = %d\n", (void*) (ptr + 2), *(ptr + 2));
printf("byte 4: addr = %p, val = %d\n", (void*) (ptr + 3), *(ptr + 3));</code></pre>

<!--
  Rather more surprising, at first sight, is the fact that a reference to a[i] can also be written as *(a+i). In evaluating a[i], C converts it to *(a+i) immediately; the two forms are equivalent. Applying the operator & to both parts of this equivalence, it follows that &a[i] and a+i are also identical: a+i is the address of the i-th element beyond a. As the other side of this coin, if pa is a pointer, expressions might use it with a subscript; pa[i] is identical to *(pa+i). In short, an array-and-index expression is equivalent to one written as a pointer and offset.

  https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c

  https://stackoverflow.com/questions/4622461/difference-between-pointer-index-and-pointer
-->


<h3 id="constants">Constants</h3>

<pre><code class="c">  // const declares a variable whose value cannot be changed
const int i = 1;
i = 2;  // error

int const j = 1;
j = 2;  // error

// a constant can be modified through a pointer
const int i = 1;

int *ptr = &amp;i;
*ptr = 2;  // warning

printf("%d\n", i);  // 2

// using const before a pointer declaration delcares a pointer to a constant
const int i = 1;
const int *ptr = &amp;i;

*ptr = 2;  // error

int j = 2;
ptr = &amp;j;  // ok

// using const after the type and asterisk declares a pointer to a constant
int i = 1;
int * const ptr = &amp;i;

*ptr = 2;  // ok

int j = 2;
ptr = &j  // error</code></pre>


<h3 id="function-pointers">Function Pointers</h3>

<pre><code class="c">#include &lt;stdio.h>

int sum(int n, int m) {
  return n + m;
}

int apply(int (*ptr)(int, int), int n) {
  return (*ptr)(n, n);
}

int main() {
  int (*ptr)(int, int);
  
  ptr = &amp;sum;

  printf("%d\n", (*ptr)(1, 2));  // 3

  printf("%d\n", apply(ptr, 2));  // 4
}</code></pre>



<h3 id="operators">Operators</h3>

<pre><code class="c">unsigned char x = 5;  // 00000101
unsigned char y = 9;  // 00001001

printf("%d\n", x & y);   // 00000001
printf("%d\n", x | y);   // 00001101
printf("%d\n", x ^ y);   // 00001100
printf("%d\n", ~x);      // 11111010
printf("%d\n", y &lt;&lt; 1);  // 00010010
printf("%d\n", y >> 1);  // 00000100</code></pre>

<pre><code class="c">#include &amp;stdio.h>

// sizeof yields the size in bytes of the object representation of a type or the type of a expression

printf("%zu\n", sizeof(char));    // 1
printf("%zu\n", sizeof(short));   // 2
printf("%zu\n", sizeof(int));     // 4
printf("%zu\n", sizeof(long));    // 4
printf("%zu\n", sizeof(float));   // 4
printf("%zu\n", sizeof(double));  // 8

printf("%zu\n", sizeof(char *));    // 8
printf("%zu\n", sizeof(short *));   // 8
printf("%zu\n", sizeof(int *));     // 8
printf("%zu\n", sizeof(long *));    // 8
printf("%zu\n", sizeof(float *));   // 8
printf("%zu\n", sizeof(double *));  // 8

int i = 42;
int *ptr = &amp;i;

printf("%zu\n", sizeof(i));    // 4
printf("%zu\n", sizeof(ptr));  // 8

struct point {
  int x;
  int y;
};

printf("%zu\n", sizeof(struct point));  // 8</code></pre>

<!-- 
  SIZE_T

  size_t is the result type of the sizeof operator.

Use size_t for variables that model size or index in an array. size_t conveys semantics: you immediately know it represents a size in bytes or an index, rather than just another integer.

Also, using size_t to represent a size in bytes helps making the code portable.
 -->

<h3 id="arrays">Arrays</h3>

<pre><code class="c">// declaration
int numbers[5];

numbers[0] = 0;
numbers[1] = 1;
numbers[2] = 2;
numbers[3] = 3;
numbers[4] = 4;

// declaration with initialization
int numbers[] = {0, 1, 2, 3, 4};

// iterate over array
for (size_t i = 0; i &lt; sizeof(numbers); i++) {
  numbers[i] = numbers[i] * 2;
}

printf("%d\n", numbers[2]);  // 4

// if an array is partially initialized then elements that are not initialized receive the zero value of the appropriate type
char zeros[1024] = {0};  // {0, ..., 0}</code></pre>

<!--
  When an array name is passed to a function, what is passed is the location of the initial element. Within the called function, this argument is a local variable, and so an array name parameter is a pointer, that is, a variable containing an address.

  When passing an array as a parameter, this

  void arraytest(int a[])

  means exactly the same as

  void arraytest(int *a)

  so you are modifying the values in main.

  For historical reasons, arrays are not first class citizens and cannot be passed by value.
-->


<h3 id="strings">Strings</h3>

<pre><code class="c">#include &amp;stdio.h>
#include &amp;string.h>

// a string is an array of characters terminated with \0

// when used to initialize a char[] a string literal provides a shortcut to initialize the elements of the array
char arr[] = "hello";

// shortcut for
// char arr[] = {'h', 'e', 'l', 'l', 'o', '\0' }

// the array can be modified like any other array
arr[0] = 'H';

printf("%zu\n", sizeof(arr));  // 6

// everywhere else a string literal generates unamed static array of characters that gives undefined behavior if modified
char *ptr = "hello";

printf("%zu\n", sizeof(ptr));  // 8 (64-bit)

// the strlen() function can be used in either case
printf("%zu\n", strlen(arr));  // 5
printf("%zu\n", strlen(ptr));  // 5</code></pre>

<!-- 
  https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s
-->


<h3 id="functions">Functions</h3>

<pre><code class="c">int max(int x, int y) {
  if (x > y) {
    return x;
  }

  return y;
}

void inc(int* x) {
  *x += 1;
}

// const parameters cannot be modified
void count(const int to) {
  for (int i = 0; i &lt; to; i++) {
    printf("%d", i);
  }
}

// arrays passed to functions are converted to pointers
float avg(int n, float arr[]) {
  float total = 0;
  
  for (int i = 0; i &lt; n; i++) {
    total += arr[i];
  }

  return total / n;
}</code></pre>



<h3 id="variadic-functions">Variadic Functions</h3>

<pre><code class="c">#include &lt;stdio.h>
#include &lt;stdarg.h>
  
int sum(int count, ...) {	
  int total = 0;
  va_list args;

  va_start(args, count);

  for (int i = 0; i &lt; count; i++) {
    int temp = va_arg(args, int);
    total += temp;
  }

  va_end(args);

  return total;
}

// ...

int total = sum(3, 1, 2, 3);
printf("%d\n", total);  // 6</code></pre>



<h3 id="static">Static</h3>

<pre><code class="c">#include &lt;stdio.h>

// static global variables and functions are only visible within their translation unit (the .c file after header file have been included)
static int i = 0;

static void global() {
  i++;
}

// a static local variable is persistent across function calls
void local() {
  int i = 0;
  static int j = 0;

  i++;
  j++;

  printf("i = %d, j = %d\n", i, j);
}

local();  // i = 1, j = 1
local();  // i = 1, j = 2
local();  // i = 1, j = 3</code></pre>


<h3 id="conditionals">Conditionals</h3>

<pre><code class="c">int x = 0;

if (!x) {
  printf("zero\n");
} else if (x > 0) {
  printf("positive\n");
} else {
  printf("negative\n");
}

// ternary operator
x > 0 ? printf("positive\n") : printf("negative\n");</code></pre>



<h3 id="switch">Switch</h3>

<pre><code class="c">char answer = 'y';

switch (answer) {
  case 'y':
    printf("Yes!\n");
    break;
  case 'n':
    printf("No!\n");
    break;
  default:
    printf("Huh?\n");
    break;
}</code></pre>



<h3 id="iteration">Iteration</h3>

<pre><code class="c">int i = 0;
while (i &lt; 5) {
  printf("%d\n", i++);
}

for (int i = 0; i &lt; 5; i++) {
  printf("%d\n", i);
}</code></pre>


<h3 id="goto">Goto</h3>

<pre><code class="c">// goto causes execution to jump to a specified label
  goto skip;
  printf("here\n");
skip:
  printf("there\n");

// labels have function scope so you can only goto labels that are in the same function
again:
  printf("again!\n");
  goto again;

// this can be used to bail out of nested loops
  while (1) {
    while (1) {
      goto bail;
    }
  }
bail:
  printf("escaped!");</code></pre>

<h3 id="enumerations">Enumerations</h3>

<pre><code class="c">enum day {
  MONDAY,
  TUESDAY,
  WEDNESDAY,
  THURSDAY,
  FRIDAY,
  SATURDAY,
  SUNDAY
};

// ...

for (int i = MONDAY; i &lt;= SUNDAY; i++) {
  printf("%d\n", i);
}</code></pre>



<h3 id="structures">Structures</h3>

<pre><code class="c">struct point {
  int x;
  int y;
};

// ...

struct point p;

// initialization with struct literal;
// struct point p = {0, 0};

p.x = 1;
(&p)->y = 2;

printf("(%d, %d)\n", p.x, (&amp;p)->y);  // (1, 2)

struct point* ptr = &amp;p;

ptr->x = 3;
(*ptr).y = 4;

printf("(%d, %d)\n", ptr->x, (*ptr).y);  // (3, 4)

// assignment performs a memory copy
struct point q;

q = p;
p.x = 2;

printf("(%d, %d)\n", p.x, p.y);  // (2, 4)
printf("(%d, %d)\n", q.x, q.y);  // (3, 4)</code></pre>



<h3 id="unions">Unions</h3>

<pre><code class="c">union various {
  int i;
  float f;
  char c[20];
};

// ...

union various v;
printf("%d\n", sizeof(v));  // 20</code></pre>



<h3 id="typedef">Typedef</h3>

<pre><code class="c">// there is a separate namespace for tag identifiers (for struct/union/enum)
struct Point {
  int x;
  int y;
};

// so you have to refer to those types with a prefix
struct Point p;

// typedef can be used to avoid this
typedef struct {
  int x;
  int y;
} Point;</code></pre>

<pre><code class="c">// typedef creates an alias for an existing type.
typedef int count;

count c = 0;

// this can be used to avoid needing to refer to a struct with the struct keyword
struct point {
  int x;
  int y;
};

typedef struct point point;

struct point p = { 1, 2 };
point q = { 3, 4 };

// frequently this is written in one line
typedef struct point {
  int x;
  int y;
} point;

// an anonymous structure can also be used
typedef struct {
  int x;
  int y;
} point;</code></pre>

<!-- 
  https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c
-->


<h3 id="preprocessor">Preprocessor</h3>

<pre><code class="c">// main.c
#include &lt;stdio.h>
#include "hello.h"

// hello.h
#ifndef HELLO_H
#define HELLO_H

// ...

#endif</code></pre>

<!--
  A #define line defines a symbolic name or symbolic constant to be a particular string of characters. Thereafter, any occurrence of name (not in quotes and not part of another name) will be replaced by the corresponding replacement text. The name has the same form as a variable name: a sequence of letters and digits that begins with a letter. The replacement text can be any sequence of characters; it is not limited to numbers.

  #define LOWER 0
  #define UPPER 300
  #define STEP  20
-->



<h3 id="assertions">Assertions</h3>

<pre><code class="c">#include &lt;assert.h>

int x = 1;
assert (x == 2);  // boom</code></pre>



<h3 id="heap-allocation">Heap Allocation</h3>

<pre><code class="c">#include&lt;stdio.h>
#include&lt;stdlib.h>

// malloc() allocates a specified number of bytes and returns a void pointer to the allocated memory
int n = 5;

int* ptr = (int*) malloc(n * sizeof(int));

// null indicates an error occurred when allocating memory 
if (ptr == NULL) {
  printf("failed to allocate memory!\n");
} else {
  for (int i = 0; i &lt; n; i++) {
    *(ptr + i) = i;
  }

  for (int i = 0; i &lt; n; i++) {
    printf("%d\n", *(ptr + i));
  }

  // free() deallocates memory allocated by malloc(), calloc() or realloc()
  free(ptr);
}</code></pre>

<pre><code class="c">#include&lt;stdio.h>
#include&lt;stdlib.h>

// calloc() dynamically allocates zero-initialized memory for a specified number of elements of a specified size

int n = 5;

int* ptr = (int*) calloc(n, sizeof(int));

if (ptr == NULL) {
  printf("failed to allocate memory!\n");
} else {
  for (int i = 0; i &lt; n; i++) {
    printf("%d\n", ptr[i]);  // 0 0 0 0 0
  }

  for (int i = 0; i &lt; n; i++) {
    ptr[i] = i;
  }

  for (int i = 0; i &lt; n; i++) {
    printf("%d\n", ptr[i]);  // 0 1 2 3 4 5
  }

  free(ptr);
}</code></pre>

<pre><code class="c">// realloc() resizes a block of memory allocated by malloc or calloc

int n = 5;
int m = 10;

int* ptr = (int*) malloc(n * sizeof(int));

for (int i = 0; i &lt; n; i++) {
  ptr[i] = i;
}

int* new_ptr = (int*) realloc(ptr, m);

for (int i = n; i &lt; m; i++) {
  ptr[i] = i;
}

for (int i = 0; i &lt; m; i++) {
  printf("%d\n", ptr[i]);
}

free(new_ptr);</code></pre>



<h3 id="file-io">File IO</h3>

<pre><code class="c">#include &amp;stdio.h>

// writing
FILE *fp = fopen("./example.txt", "w");

fputc('a', fp);  
fputc('p', fp);  
fputc('p', fp);  
fputc('l', fp);  
fputc('e', fp);  
fputc('\n', fp);  

fputs("orange\n", fp);

fprintf(fp, "banana\n");

fclose(fp);

// reading
FILE *fp = fopen("./example.txt", "r");

char c;
while ((c = fgetc(fp)) != '\n')
  printf("%c\n", c);

char buf[32];
fgets(buf, 32, fp);
printf("%s", buf);

fscanf(fp, "%s", buf);
printf("%s", buf);

fclose(fp);</code></pre>

<ul>
  <li>
    <code>r</code>: Opens an existing text file for reading.
  </li>
  <li>
    <code>w</code>: Opens a text file for writing. The file will be created if it does not exist.
  </li>
  <li>
    <code>a</code>: Opens a text file for appending. The file will be created if it does not exist.
  </li>
  <li>
    <code>r+</code>: Opens a text file for reading and writing.
  </li>
  <li>
    <code>w+</code>: Opens a text file for both reading and writing. The file will be truncated or created if it does not exist.
  </li>
  <li>
    <code>a+</code>: Opens a text file for both reading and appending. The file will be created if it does not exist.
  </li>
</ul>


<!-- 
  COPYING MEMORY

  

-->


<!--
// MMAP
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <ctype.h>

int main() {

  // mmap can be used to map files into memory
  int fd = open("./example.txt", O_RDWR);
  
  // get the filesize
  struct stat stats; 
  fstat(fd, &stats);
  printf("%ld\n", stats.st_size);

  char *data = mmap(NULL, stats.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

  // read from file
  for (size_t i = 0; i < stats.st_size; i++) {
    printf("%c", data[i]);
  }

  // write to file
  for (size_t i = 0; i < stats.st_size; i++) {
    data[i] = toupper(data[i]);
  }

  munmap(data, stats.st_size);

  return EXIT_SUCCESS;
}

// https://en.wikipedia.org/wiki/Memory-mapped_file
// https://en.wikipedia.org/wiki/Mmap
// https://www.youtube.com/watch?v=m7E9piHcfr4
// https://beej.us/guide/bgipc/html/multi/mmap.html


FORMATTED OUTPUT

%d print as decimal integer
%6d print as decimal integer, at least 6 characters wide
%f print as floating point
%6f print as floating point, at least 6 characters wide
%.2f print as floating point, 2 characters after decimal point
%6.2f print as floating point, at least 6 wide and 2 after decimal point

Among others, printf also recognizes %o for octal, %x for hexadecimal, %c for character, %s for character string and %% for itself.



CHARACTER INPUT AND OUTPUT

The model of input and output supported by the standard library is very simple. Text input or output, regardless of where it originates or where it goes to, is dealt with as streams of characters. A text stream is a sequence of characters divided into lines; each line consists of zero or more characters followed by a newline character.



MAKE

https://stackoverflow.com/questions/30573481/path-include-and-src-directory-makefile



PTHREAD


// create and join

// #include <stdio.h>
// #include <unistd.h>
// #include <pthread.h>

// void *count(void *arg) {
//   for (int i = 0; i < 10; i++) {
//     printf("%d\n", i);
//   }
  
//   return NULL;
// }

// int main() {
//   pthread_t t;

//   // run function in separate thread
//   pthread_create(&t, NULL, count, NULL);

//   for (int i = 0; i < 10; i++) {
//     printf("%d\n", i);
//   }

//   // wait for thread to terminate
//   pthread_join(t, NULL);
// } 


// arguments and return values

// #include <stdio.h>
// #include <unistd.h>
// #include <stdlib.h>
// #include <pthread.h>

// void *count(void *to) {
//   int *sum = malloc(sizeof(int));

//   for (int i = 0; i < *((int *) to); i++) {
//     printf("%d\n", i);
//     *sum += i;
//   }
  
//   return sum;
// }

// int main() {
//   pthread_t t;
//   int to = 5;

//   // pass in function argument
//   pthread_create(&t, NULL, count, &to);

//   // get return value
//   int *sum;
//   pthread_join(t, (void *) &sum);
//   printf("%d\n", *sum);
// }


// race conditions

// #include <stdio.h>
// #include <pthread.h>

// int counter = 0;

// void *count(void *arg) {
//   for (int i = 0; i < 1000000; i++) {
//     counter++;

//     // int tmp = i;
//     // i = tmp + 1;
//   }
// }

// int main() {
//   pthread_t t;

//   pthread_create(&t, NULL, count, NULL);

//   count(NULL);

//   pthread_join(t, NULL);

//   printf("%d\n", counter);
// }


// race conditions

// #include <stdio.h>
// #include <pthread.h>

// int counter = 0;
// pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

// void *count(void *arg) {
//   for (int i = 0; i < 1000000; i++) {
//     pthread_mutex_lock(&lock);
//     counter++;
//     pthread_mutex_unlock(&lock);
//   }
// }

// int main() {
//   pthread_t t;

//   pthread_create(&t, NULL, count, NULL);

//   count(NULL);

//   pthread_join(t, NULL);

//   printf("%d\n", counter);
// }


// volatile

// #include <stdio.h>
// #include <pthread.h>
// #include <stdbool.h>
// #include <unistd.h>

// // volatile tells the compiler not to cache the value of this variable
// volatile bool done = false;

// void *wait(void *arg) {
//   sleep(1);
//   done = true;
//   return NULL;
// }

// int main() {
//   pthread_t t;
//   pthread_create(&t, NULL, wait, NULL);

//   printf("waiting...\n");

//   // if done is not declared as volatile then compiling with -O2 will change with to while(true)
//   while (!done) {}

//   printf("done!\n");
// }

 -->




<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://modernc.gforge.inria.fr/">Modern C</a>
  </li>
  <li>
    <a href="http://c-faq.com/index.html">comp.lang.c Frequently Asked Questions</a>
  </li>
  <li>
    <a href="https://en.cppreference.com/w/">cppreference.com</a>
  </li>
</ul>
